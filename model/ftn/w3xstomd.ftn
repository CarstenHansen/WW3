#include "w3macros.h"
!/ ------------------------------------------------------------------- /
      MODULE W3XSTOMD
!/
!/                  +------------------------------------------+
!/                  | Extended spectral tail for Stokes drift  |
!/                  |          Carsten Hansen                  |
!/                  | Joint GEOMETOC Support Center Denmark    |
!/                  |                            FORTRAN 90    |
!/                  | Last update :             09-OCT-2019    |
!/                  +------------------------------------------+
!/
!/
!/    02-May-2011 : Origination. Development program w3stokes.ftn converted
!/                  from tested Python code
!/    27-Jun-2011 : First module version w3dstkmd.ftn. Output tested with
!/                  a stand-alone program w3stokes.ftn. Implementation plan.
!/    18-Aug-2011 : Calculate fit to J. Mattsson parametric profile (ver.0.12)
!/    10-Oct-2011 : Interface subroutine w3dstk() to ww3_shel (version 0.22)
!/    21-Oct-2011 : Detailed description of implementation into WW3 v.3.14
!/                  First compilation of ww3_shel in parallel mode
!/                  Test-scripts run_ww3test.sh,
!/                     $PERL5LIB/bin/ww3job_preproc (version 0.32)
!/    08-Nov-2011 : Full functioning module. Un-physical spatial discontinuities
!/                  identified: May need to match the Stokes profiles to
!/                  integral wave pseudo-momentum/depth-integrated Stokes drift.
!/    23-Nov-2011 : Ajust the deep profile to match the depth-integrated
!/                  Stokes drift. Function AJUST_FIT() (version 0.33).
!/    30-Nov-2011 : Re-formulated the look-up tables for the diagnostic tail.
!/                  Simplified tail extension (version 0.40)
!/    07-Dec-2011 : Refined ajustment of Mattsson profiles to integral
!/                  pseudo-momentum (version 0.41).
!/    16-Dec-2011 : Calculate integrated pseudo-momemtum directly (ver. 0.44).
!/                  For the prognostic spectrum, the momentum density is
!/                    m(K) = rho G K A(K), where K is the wave number vector
!/                  and A(K) is the action spectrum.
!/                  For the diagnostic tail, we apply a look-up array Im(n),
!/                    Im(n) = sum_fhn^fhcut m1t(fh) fh^-2 log(DFH)
!/                  where
!/                    fhn = ft/fP = DFH**(n-1), n = 1, ..., Np
!/                  m1t(fh) is the 1'st circular moment in Ewans' formulae,
!/                  and fh = f/fP.
!/                  The integrated pseudo-momentum (per m^2) from ft to fcut is
!/                    M(ft) = rho G alpha U sigP^-2 Im(n), where
!/                  n = log(ft/fP)/log(DFH) + 1,
!/                  sigP = 2 pi fP is the peak frequency in Ewans' formulae,
!/                  G is gravitational acceleration, alpha is the spectral
!/                  constant of Donelan et al., 1985.
!/    22-Dec-2017 : Adoption to version WW3 v5.16:
!/                  + Call CALC_XSTOKES() from W3OUTG(), outside loop over JSEA
!/    09-Mar-2020 : Adoption to version WW3 v7.??
!/                  + Mattsson fitting is separated to module 'W3XSMFMD'
!/                  + Namelist group &XSTO
!/                  + from W3OUTG pass the array A of spectra to CALC_XSTOKES(A)
!/                  + Collect technical doc. in comments in diag_DE_init()
!/                  + For the extended tail to be representative, the local wind
!/                    sea peak must be within the prognostic range, fp < IKTT
!/    21-Jan-2021 : Match the exact expressions in C. Hansen, 2020 (DRAFT):
!/                  "Mean Stokes drift profile from a wave model with a
!/                  parametric extension of the spectral tail".
!-------------------
!/
!  1. Purpose, and output data
!
!  Calculate the vertical profile of the Stokes drift, using a directional
!  distribution (Ewans, 1997) for the diagnostic parts of the spectrum at
!  high frequencies in conjunction with an assumed power-law spectral tail.
!
!  All calculations are performed in parallel and the Stokes drift is calculated
!  at NDEPTH discrete depths given in an array Z_S(1:NDEPTH).
!  The sum of prognostic and diagonostic (tail) contributions are stored in
!  arrays U_S(1:NDEPTH), V_S(1:NDEPTH).
!
!  2. Usage
!
!  a) In ww3_grid.inp/ww3_grid.nml, you may modify three namelist variables:
!     $ NDP: Number of depths (->NDEPTH)
!     $ DSC: Depth scale specifying the largest depth Z(NDP)=DSC/(2pi/Tz)^2*GRAV
!     $ TYP: Tail type (C*4); 'DoEw': Donelan-Ewans,
!     $                       'DE20': Donelan-Ewans truncated at 2.0 Hz,
!     $                       'DE'IF: Donelan-Ewans truncated at I.F Hz
!     $                       'None': Prognostic spectrum frequencies, only
!     &XSTO NDP = 11, DSC = 1.0, TYP = 'DE20' /
!
!  ( TODO: In ww3_shel.nml, you may in the future set namelist variable
!     XSVB: Verboseness level [0..4] of output. Default XSVB=1 )
!
!  3. Estimation of Stokes drift of the diagnostic tail.
!
!  For wind waves over deep water, and following Ewans (1997), the
!  contribution in the frequency bin df to the directionally integrated
!  Stokes drift is
!    d Stokes(omega) = 2 g omega^3 m1(omega) S(omega) d omega
!  where the directionally integrated spectrum is
!    S(omega) = int_-pi^pi S(omega,theta) d theta
!
!  Following Ewans (1997) m1(omega) is denoted the 'first circular moment' of
!  the spectrum S(omega,theta),
!    m1(omega) = int_-pi^pi cos(theta) S(omega,theta) d theta / S(omega)
!
!  Based on observational data (the 'Maui' experiment) Ewans (1997) suggests
!  a mathematical model to fit the data, which results in the
!  following expression for the first circular moment:
!    m1E(omega) = cos(theta_E(f/fP)) exp( -(sigma(f/fP)**2)/2 ),
!  where f/fP is the ratio of local spectral frequency f=omega/2pi over the
!  peak frequency fP. Ewans provides expressions for theta_E, the reflection
!  from the mean direction of two 'binodal' directional peaks, and sigma, the
!  standard deviation of Gaussian-shaped distributions around each of the two
!  peaks.

!  In the present usage ('Donelan-Ewans': subroutine diag_DE_init(NP)),
!  Ewans' m1 is approximated by a function,
!    m1t(f/fP) = m1E(f/fP=1) * exp( a sinh(phih * (f/fP - 1)) )
!  where a = 1.25 and phih = -0.187 is a negative factor representing the
!  increasing directional spread with increasing f/fP.

!  A formula for the spectral tail is assumed in the form of Donelan et. al
!  (1985),
!    S(omega) = alpha U10 g omega^-4,
!  where the factor alpha may vary with the integral wave properties, among
!  which the dependance on wave age (U10/cP)*cos(theta_mean-theta_U) has been
!  investigated. In the present usage, alpha is estimated based on a few of
!  the highest frequency bins of the prognostic spectrum.
!  We note that the resulting estimates of alpha is sensitive to the choice of
!  formulation of wind input. It was first tested (and tuned) with the
!  Tolman-Chalikov input terms formulation ( WW3 switch '/ST2'), and is
!  also consistent with ST4-Romero or ST6, which are supposed with certain
!  parameter combinations to have an omega^-4 spectral tail up to f/fP ~ 3-4.
!
!  With the spectrum of Donelan et. al and Ewans' formula for m1(omega), the
!  integrated Stokes drift int_omegat^inf d Stokes(omega) will *not* converge,
!  because the binodal direction theta_E(f/fP) converges to a value slightly
!  larger that pi/2 as f/fP -> infinity. However, it is realistic that
!  at values of f/fP in the range 3 to 6 there exist a further transition to
!  a spectrum of satutated form, going asymptotically as omega^-5. Such
!  spectral tail works as a low-pass filter, and the exact shape of m1 beyond
!  frequencies of order f/fP ~ 6 does only influence the integrated Stokes
!  drift by a small amount. The applied approximation m1t(omega) to Ewans'
!  formula for m1(omega) provides a low-pass filter at an equivalent frequency
!  scale. Thus it is suggested that there will be little effect of applying
!  an explicit formula of an omega^-5 spectral tail.
!
!  4. Integrated pseudo-momentum over the diagnostic spectral tail
!
!  A common look-up table for this, Im(nt), is calculated in a subroutine
!  specfic for the parametric tail (for Donelan-Ewans: subroutine
!  diag_DE_init(NP)).
!
!  The index nt corresponds to fd/fp rounded to nearest integer:
!  fd/fp = DFH**ntf; nt=nint( ntf )

!  The spectrum is normalized by the spectral level. For Donelan-Ewans
!  this is estimated from the omnidirectional spectrum S(omega) as
!  Dsn = S(omega)*omega^4.

!  Im(nt), where ft/fP = fhn = DFH**n, n = 1, ..., Np
!  Im(nt) = sum_fhn^fhcut m1(fh) fh^-2 log(DFH)
!  The integrated momentum of the spectral tail is
!  M(ft) = GRAV * Dsn sigP^-2 Im(n), n = log(ft/fP)/log(DFH)
!
!  M is a first 'kv/sig'-moment - like the the first spectral moment
!  (that determines the mean wave period) but considered a vector sum.
!  kv is the wave number vector, kv = k * (cos(theta), sin(theta))
!
!
!  5. Diagnostic tail until Ncut
!
!  The diagnostic tail contribution is calculated in the subroutine
!  CALC_XSTOKES(A) using a common 2-D array SBDiaZ(:,:) for the
!  normalized Stokes drift.
!
!  The look-up array start index nt, and the spectral level Dsn, are
!  defined as above
!
!  StkDiag(:) = SBDiaZ(:,nt) * (1. - ntf) ! Fraction at fd/fp
!  do ntt = nt+1, min(ntr,NP)
!    StkDiag(:) = StkDiag(:) + SBDiaZ(:,ntt)
!  end do
!
!  Starting at the surface, SBDiaZ(0,:) = DStkOsn(:). This is calculated
!  in a subroutine specfic for the parametric tail. This example is for
!  Donelan-Ewans, subroutine diag_DE_init(NP):
!
!  fh = fht
!  do ntt = Np+1, Ncut
!        DStkOsn(ntt) = exp( aa * sinh(phih * (fh - 1.)) )
!        Sum = Sum + DStkOsn(ntt)
!        fh = fh * DFH
!  end do
!  DStkOsn(Np+1)=Sum
!
!  The depth dependent array SBDiaZ(1:NZ,:) is calculated in the
!  subroutine XSTOKES_INIT:
!
!  Let XKH = DFH**2
!
!  Initial value of ratio of wavenumbers:
!  Rk = fOfp(JSEA)**2
!  ! Loop over spectral bins
!  do ntt = NP + 1, Ncut
!    ! Loop over depth bins
!    do iz = 1,NZ
!      ! Assume no shallow water effect at high frequencies
!      A2S = EXP( - 2 * Rk * ZK_S(iz) )
!      SBDiaZ(iz,ntt) =  DStkOsn(ntt) * A2S
!      end do
!    ! Increment the ratio of wavenumbers
!    Rk = Rk * XKH
!    end do
!
!  5b. Tail of the tail:
!  ! Not implemented for now: 
!  ! A supplement tail may be appended at the *end* of the discretized
!  ! diagnostic range, see end of SUBROUTINE diag_DE_init.
!
!  6. Implementation in the WW3 code:
!
!  Code lines in WW3 cource files other than w3xstomd.ftn have all been
!  added under the compile switch '!/XSTO'
!
!  a) In w3iogomd.ftn
!     In CALC_XSTOKES() (w3xstomd.ftn) the stokes drift profile is calculated
!     by a call of DSTOKES(A, JSEA, U10, UDIR, T02). (For the initial scale
!     value for wave period [Ts] the zero upcrossing period T02 is chosen.)
!
!
!  b) In w3gdatmd.ftn, w3iogrmd.ftn, ww3_grid.ftn:
!       Part of the GRIDS structure (W3GDATMD) and stored in mod_def
!       XSND: Number of depths for Stokes profile U_S(1:XSND)
!       XSDS: Depth scale specifying the largest depth Z(XSND) for the profile
!       XSBP: Power of profile depth progression
!       XSTY: Tail par. type. 'DoEw': Donelan-Ewans,
!                             'None': Prognostic spectrum frequencies, only
!
!  c) In w3adatmd.ftn:
!       Declare and allocate arrays ZK_S (Z*K_S) and
!       UXSP: The full Stokes 2D profile and integral parameters M_X, M_Y, K_S
!
!  d) Modify the makefile scripts (make_makefile.sh, w3_new) as
!     described in the WW3 manual chpt. 5.5
!     make_makefile.sh:
!       for type in ...  xsto; do
!       (...)
!
!     w3_new:
!       case $... in
!       (...)
!
!  7. Subroutines and functions :
!
!      Name      Type  Scope    Description
!     ----------------------------------------------------------------
!      CALC_XSTOKES    Public  Interface routine for Stokes drift
!                              profile calculation
!     ----------------------------------------------------------------
!
!  8. Switches :
!
!       !/SHRD  Switch for shared / distributed memory architecture.
!       !/DIST  Id.
!
!
!  9. Source code :
!

!/ ------------------------------------------------------------------- /
      USE CONSTANTS, ONLY: GRAV, TPI, RADE, TSTOUT
!/
      USE W3ADATMD, ONLY: CG, WN, DW

! Integral pseudo-momentum vector and wave number scale K_S
      USE W3ADATMD, ONLY: M_X, M_Y, K_S
! Full Stokes profile vectors
      USE W3ADATMD, ONLY: U_S, V_S, ZK_S

! Stokes drift parameters
! Part of the GRIDS structure (W3GDATMD) and stored in mod_def
! XSND: Number of depths for Stokes profile U_S(1:XSND)
! XSDS: Depth scale specifying the largest depth Z(XSND) for the profile
! XSBP: Power of profile depth progression
! XSTY: Tail parametric type. 'DoEw': Donelan-Ewans,
!                             'None': Prognostic spectrum frequencies, only
      USE W3GDATMD, ONLY: XSND, XSDS, XSBP, XSTY, NSEAL, DMIN, XFR, DTH, &
                          SIG, DDEN, ECOS, ESIN, NK, NTH

! XSVB: Verboseness level [0..4] of XSTO output to NDSV
      USE W3ODATMD, ONLY: NDST, NDSO, NDSE, IAPROC, NAPROC, NAPOUT, XSVB
      USE W3DISPMD, ONLY: DSIE, N1MAX, ECG1, EWN1

      USE W3NMLSHELMD, ONLY: OFCUT, OFCUT_COUNT

! TODO, like OFCUT:
!   XSND, XSDS,XSBP and XSTY may be set at run init from WW3_shel.nml, and also:
!   XSVB: Verboseness level [0..4] of XSTO output to NDSV

!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/

      PRIVATE

! Stokes drift for the diagnostic tail. Scalable array and depths factor
! DFH: Relative increment from frequency bin-to bin for the scalable
!      diagnostic Stokes array
! NP: Number of frequency bins in the scalable diagnostic stokes array.

      REAL               :: DFH, XKH
      INTEGER            :: NP

! File id. for verbose output
      INTEGER            :: NDSV
!
      integer            :: xsto_verbose = 1

! Look-up lists for Stokes spectral tail calculation
      real, allocatable  :: DStkOsn(:), Im(:)
      real, allocatable  :: SBDiaZ(:,:) ! (NZ,NK)

      real, allocatable  :: fOfp(:)

! Spectral integral parameters in Ewans functions
      real               :: sa, sb, ta, tb, tc
      real               :: m1_max, m_deriv_min, fOfp_min, fOfpCut
! 1st circular moment fit to spectrum at diagnostic frequency
      real               :: m1E

! Spectral parameters for Stokes spectral tail calculation
      real               :: SBDia

! CHA 20200603  ftr: truncation frequency, default 2 Hz
!              ntre: relative truncation bin ntre = ntr - nt
      real               :: ftr = 2.0
      integer            :: ntre

! Profile arrays
      real, allocatable  :: StkDiag(:)

      real, allocatable  :: A2S(:), TZ_S(:), EZTK(:), DZK_S(:)

! Depth integrated Stokes drift. Equals the integral wave pseudo-momentum.
      real               :: MW_U, MW_V

! Tail transition indices
! IKTT: Lower edge of tail estimation from prognostic spectrum
! IKT:  Upper edge of tail estimation.
      INTEGER            :: IKTT, IKT

! For calculation of shallow water Stokes drift
      REAL               :: fkd2,fkdm2,kd,e2kd,shkd4
      REAL, allocatable  :: fkd(:,:), fkdm(:,:) ! (1:NK,1:NSEAL)

! 2* (WN(IK,JSEA)-WN(IK-1,JSEA))
      real, allocatable  :: DWN(:)

      PUBLIC :: CALC_XSTOKES
!/
      CONTAINS


!/ ------------------------------------------------------------------- /
!/ Step a) XSTOKES_INIT(): Initialisation. A few
!/         input lines are read from ww3_shel.inp. Lookup tables are
!/         calculated for the diagnostic tail
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE XSTOKES_INIT ()

!/                  +-------------------------------------+
!/                  | FCOO Stokes Drift for WAVEWATCH III |
!/                  |           Carsten Hansen            |
!/                  |                        FORTRAN 90   |
!/                  | Last update :         22-Dec-2017   |
!/                  +-------------------------------------+
!/
!/    02-May-2011 : Origination. Development program w3stokes.ftn converted
!/                  from tested Python code
!/    27-Jun-2011 : First module version w3dstkmd.ftn
!/    16-Aug-2011 :
!/    22-Dec-2017 : Adoption to version WW3 v5.16
!/    15-Aug-2019 : Adoption to version WW3 v6.07
!/                  Called in first call CALC_XINIT()
!
!  1. Purpose :
!
!      Initialize parameters and control arrays.
!      Stokes drift for the diagnostic tail: Calculate the scalable array
!      StokesOsn(XSND,NK+1)
!
! 10. Source code :
!
      USE W3SERVMD, ONLY : EXTCDE

      IMPLICIT NONE

!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
! Location in spatial/spectral grid
      integer                  :: JSEA, ISEA, IK
! Control integers
      integer                  :: IERR

! Common Stokes drift depth distribution parameters
      real                     :: DEPTH, tRk, XZK
      integer                  :: IZ, ntt, ikd
      logical                  :: OPENED

      XSVB = 1
      NDSV = NDST
      ! Highly verbose output only with test output
      if ( XSVB .gt. 0 ) then
        INQUIRE (NDSV,OPENED=OPENED)
        IF ( .NOT. OPENED ) THEN
          XSVB = 0
          if ( IAPROC == NAPOUT) then
            NDSV = NDSO
            XSVB = 1
            end if
          end if
        end if
      xsto_verbose = XSVB

!/ ------------------------------------------------------------- /
! Initialization for step b) CALC_XSTOKES (). An interface to DSTOKES()

!/ ------------------------------------------------------------- /
! Allocate arrays for depths, prognostic stokes and tail stokes
!
      if ( xsto_verbose .gt. 0 ) &
        WRITE (NDSV, 904),  'INITIALIZE Stokes drift for ', XSND, 'depths'

      ! Shallow water Stokes parameters
      allocate ( fkd(NK,NSEAL), stat=IERR )
      allocate ( fkdm(NK,NSEAL), stat=IERR )

      allocate( EZTK(XSND), stat=IERR )

      ALLOCATE( A2S(XSND), stat=IERR )

      allocate( TZ_S(XSND), stat=IERR )

      allocate( StkDiag(XSND), stat=IERR )

      ! For calculating exp(2 K Z) = exp(2 K0 Z) * exp( 2 (K-K0) Z )
      allocate( DWN(NK), stat=IERR )


      ! Construct a scalable array ZK_S of the stokes profile for each
      ! individual sea point:
      !   ZK_S  = K_S * Z(m),
      ! where K_S is a wave number scale and Z are the depths.

      ! Configured values:
      ! XSND: Number of depths for the Stokes profile
      ! XSDS: Depth scale so that the deepest point of the profile is
      ! XSBP: Power of profile depth progression
      !   Z_S(XSND) = XSDS / K_S
      ! Let K_S = (TPI/Tm02)**2 / GRAV
      ! Dimensionless depths will be constructed as
      !      ZK_S(IZ) = XSDS*(XZK**((IZ-1.)**XSBP) - 1.) for IZ = 1 .. XSND
      ! The exponential base XZK is defined so that the deepest point is
      ! ZK_S(XSND) = XSDS,

      ! Old hardcoded value: XSBP = 1.

      XZK = 2.**((XSND*1.-1.)**(-XSBP))
      do IZ = 1,XSND
        ZK_S(IZ) = XZK**((IZ*1.-1.)**XSBP)
      enddo
      ZK_S(:) = XSDS*(ZK_S(:) - 1.)

      if ( xsto_verbose .gt. 1 ) then
        ! DZK_S = K_S * approximate thicknesses (m) of each layer
        ! Used in control calculation of the integrated pseudo momentum

        allocate( DZK_S(XSND), stat=IERR )

        ! The uppermost layer at the surface has approximately half thickness.
        DZK_S(1) = ZK_S(1) * 0.5
        DZK_S(2:XSND-1) = (ZK_S(3:XSND) - ZK_S(1:XSND-2)) * (XZK-1./XZK) * 0.5
        DZK_S(XSND) = (XSDS*(XZK**(XSND**XSBP)-1.)-ZK_S(XSND-1)) * (XZK-1./XZK)*0.5
        ! DZK_S(2:XSND) = ( ZK_S(2:XSND) + 1 ) * (XZK - 1./XZK) * 0.5
        end if

      ! Shallow water Stokes profile parameters fkd(1:NSEAL), fkdm(1:NSEAL)

      kd = 1.
      e2kd = exp (2.*kd)
      shkd4 = 4. * (sinh( kd ))**2

      fkd2 = e2kd/shkd4
      fkdm2 = 1./ (e2kd * shkd4)
      fkd = 1.
      fkdm = 0.

      do JSEA = 1,NSEAL
!/DIST      ISEA       = IAPROC + (JSEA-1)*NAPROC
!/SHRD      ISEA       = JSEA

        ! For finite depth Stokes profile shape, parameters fkd, fkdm:
        DEPTH  = MAX ( DMIN, DW(ISEA) )

        do IK=1,NK
          kd = WN(IK, ISEA) * DEPTH

          ! kd>2: pure deep water (then fkd(IK,JSEA)=1 and fkdm(IK,JSEA)=0)
          if (kd .gt. 2.0) exit

          ! 1 <= k2d <= 2: Linear interpolation of transitional to deep water
          if (kd .gt. 1.0) then
            fkd(IK,JSEA) = fkd2 * (2. - kd) + (kd - 1.)
            fkdm(IK,JSEA) = fkdm2 * (2. - kd)
            continue
            end if

          ! kd<1: shallow water or transitional to deep water
          e2kd = exp (2.*kd)
          shkd4 = 4. * (sinh( kd ))**2
          fkd(IK,JSEA) = e2kd / shkd4
          fkdm(IK,JSEA) = 1./ (e2kd * shkd4)

          end do ! IK=1,NK

        end do ! JSEA = 1,NSEAL

!/ ------------------------------------------------------------- /
! Initializations for calculations related to the diagnostic, tail range

! cha 20110627: IKT:  Upper edge of prognostic range.
!                     NK is the highest possible such limit
!
! cha 20121123: Shift fitting interval limits away from NK, from NK-5 to NK-2
      if ( XSTY == 'DoEw' ) then
          ! Donelan-Ewans
          IKT = NK - MAX( 2, NINT( 0.2/log(XFR) ) )
! cha 20110627: IKTT: Lower edge of tail fitting to the prognostic spectrum
          IKTT = NK - MAX( 5, NINT( 0.5/log(XFR) ) )
      else if ( XSTY == 'None' ) then
          ! 'None': Truncated spectrum
          IKT = NK-1
          IKTT = NK
      else
        WRITE (NDSV, 916), 'XSTOKES_INIT: Unknown spectral tail type: ', XSTY
        CALL EXTCDE ( 73 )
        end if

      if ( XSTY == 'None' ) return

      allocate ( fOfp(NSEAL), stat=IERR )
      ! A zero value will cause fd/fp to be initialized at the first timestep
      fOfp = 0.0

! DFH: Relative increment from frequency/wavenumber bin-to bin for the
!     scalable diagnostic stokes arrays
      DFH = XFR
      XKH = DFH**2
      NP = IKT

      ! SBDiaZ(z,bin): A 'normalized, look-up' vertical Stokes Drift profile
      ! shape for spectral bins of the diagnostic tail.
      ! Factorized as DStkOsn(bin) * exp( -tRk(bin) * ZK_S(z) )
      !
      ! For the Diagnostic range the surface Stokes drift for every spectral
      ! bin is multiplied with a depth factor EXP( -2 K Z), assuming deep water
      ! dispersion at the high frequencies. We apply a look-up array
      !  SBDiaZ(1:NZ,1:NP) = DStkOsn(1:NP) * exp ( -2*Rk(1:NP)*ZK_S(1:NZ) )
      ! where Rk is a discrete array representing (f/fp)**2

      ! Let tRk = 2*Rk = 2 * XKH**ntt.

      ! NP  should span the full prognostic range, from F1 to
      ! F1 * DFH**NP == F1 * XFR**IKT or NP = ceiling(IKT * log(XFR)/log(DFH))
      ! If DFH==XFR, then NP=IKT
      ! Index shift to the next bin in DStkOsn: log(XFR) / log(DFH)
      ! NP = ceiling(IKT * log(XFR) / log(DFH))

      if ( .not. allocated(SBDiaZ) ) allocate( SBDiaZ(XSND, NP), stat=IERR )

      allocate ( DStkOsn(NP), stat=IERR )

      ! Im(bin): A look-up table for integrated momemtum
      if ( .not. allocated(Im) )  allocate ( Im(NP+1), stat=IERR )

      ! Stokes drift for the diagnostic tail. Calculate a normalized array
      ! DStkOsn(1:NP)
      ! Also calculate the look-up table Im(1:NP)
      if ( xsto_verbose .gt. 1 ) &
        WRITE (NDSV, 904), 'call diag_DE_init(', NP, ')'
      CALL diag_DE_init(NP)

      ! Extend with a zero to be used for linear interpolation
      Im(Np+1) = 0.

      ! If the tail is truncated at a specific frequency ftr,
      DO IK=1,OFCUT_COUNT%N_FIELD+1
        IF (IK == OFCUT_COUNT%N_FIELD+1) exit
        IF (OFCUT(IK)%FIELD == 'XSP') exit
        END DO
      IF (IK <= OFCUT_COUNT%N_FIELD) ftr = OFCUT(IK)%FREQ
      if ( xsto_verbose .gt. 0 ) &
          WRITE (NDSV, *), ' XSTOKES_INIT: CUT-OFF AT',ftr,'Hz'

      ! The truncation frequency ftr corresponds to a bin number ntr, where
      ! ftr/fp=DFH**ntr, or ntr = log( ftr/fp ) / log(DFH).
      ! Relative to the transition frequency fd = SIG(IKT) / TPI we have
      ! ftr/fd = (ftr/fp) / (fd/fp). The tail truncation bin exceeds the
      ! transition bin at fd by ntre bins, where ftr/fd = DFH**ntre, or:
      ntre = log( ftr * TPI / SIG(IKT) ) / log(DFH)
      
      tRk = 2.
      do ntt=1,NP
        tRk = tRk*XKH ! = 2 * XKH**ntt
        SBDiaZ(:,ntt) = DStkOsn(ntt) * exp( -tRk * ZK_S(:) )
        end do

      if ( xsto_verbose .gt. 2 ) WRITE (NDSV, *), &
              'NP =',NP,'2Rk(NP) =', tRk, 'ZK_S(:) =', ZK_S

      if ( xsto_verbose .gt. 2 ) WRITE (NDSV, *), &
              '   SBDiaZ(1:XSND,int(NP/2)) =', SBDiaZ(1:XSND, int(NP/2))

      deallocate ( DStkOsn )

  904 FORMAT ('  ', A,I5,A)
  906 FORMAT ('  ', 6(A,G9.2))
  916 FORMAT ('  ', A, A)

      END SUBROUTINE XSTOKES_INIT


!/ ------------------------------------------------------------------- /
! Step b) CALC_XSTOKES (). An interface to DSTOKES(): At each WW3 output time
!         step, calculation of a Stokes drift profile is provided in arrays
!                 U_S(1:XSND), V_S(1:XSND)
!         The Stokes profile is a sum of a prognostic part and a tail part
!         StkDiag(1:XSND), where the depths are given in the array Z_S(1:XSND)
!/ ------------------------------------------------------------------- /

      SUBROUTINE CALC_XSTOKES (A)
!/
!/                  +-------------------------------------+
!/                  | FCOO Stokes Drift for WAVEWATCH III |
!/                  |           Carsten Hansen            |
!/                  |                        FORTRAN 90   |
!/                  | Last update :         22-Dec-2017   |
!/                  +-------------------------------------+
!/
!/
!/    10-Oct-2011: Interface routine for Stokes drift profile calculation
!/                 To be called from W3OUTG() *after* calculation of both
!/                 integral parameters and swell partitions (W3CPRT)
!/                 The code structure is modelled after w3iosfmd.ftn
!/    22-Dec-2017 : Adoption to version WW3 v5.16


!/    Remarks: This subroutine must be called after T02 has been calculated
!/             This subroutine can only be called under switch !/XSTO.

! UXSP: Full Stokes profile variables + M_X, M_Y, K_S, but not ZK_S
      USE W3ADATMD, ONLY: T02, UXSP
      USE W3GDATMD, ONLY: NSEA, MAPSF, MAPSTA ! module scope:,NSEAL,NK,NTH,SIG
!/
      IMPLICIT NONE
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      REAL, INTENT(IN)        :: A(NTH,NK,0:NSEAL)
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      INTEGER                 :: ISEA, JSEA, IX, IY
      INTEGER, SAVE           :: OSTEP = 0

!     Generate data arrays for Stokes drift calculation
!     including look-up tables for extended tail
!
      IF ( .NOT. ALLOCATED(DWN) ) CALL XSTOKES_INIT()
      IF ( xsto_verbose .GT. 0 ) THEN
           WRITE (NDSV, 912), OSTEP, 'Calculate Stokes drift ..'
           OSTEP = OSTEP + 1
        END IF

!
!
! -------------------------------------------------------------------- /
! 1.  Loop over sea points
!
      DO JSEA=1, NSEAL
!
! -------------------------------------------------------------------- /
! 2.  Check need for processing
!
!/DIST        ISEA       = IAPROC + (JSEA-1)*NAPROC
!/SHRD        ISEA       = JSEA
        IX     = MAPSF(ISEA,1)
        IY     = MAPSF(ISEA,2)
!
        IF ( MAPSTA(IY,IX) .LE. 0 ) CYCLE
!
! -------------------------------------------------------------------- /
! 3.  Perform Stokes drift calculation
        CALL DSTOKES ( A(:,:,JSEA), JSEA, T02(JSEA) )
!
! -------------------------------------------------------------------- /
! 4.  Save in output array
!
        ! Storage for the vertical transform as it is
        UXSP(JSEA,1) = K_S
        UXSP(JSEA,2) = M_X
        UXSP(JSEA,3) = M_Y
        UXSP(JSEA,4:3+XSND) = U_S(1:XSND)
        UXSP(JSEA,4+XSND:3+2*XSND) = V_S(1:XSND)
!
! -------------------------------------------------------------------- /
! 5.  End of loop over sea points
!
         END DO

  912 FORMAT (2X,I3,1X,A)

      END SUBROUTINE CALC_XSTOKES

!/
!/ ------------------------------------------------------------------- /
!/

      SUBROUTINE DSTOKES(A, JSEA, T02)

      USE W3ADATMD, ONLY: U10
      USE W3GDATMD, ONLY: MAPSF ! Present module scope: , NSEAL, NK, NTH, SIG

      USE W3SERVMD, ONLY : EXTCDE
!/S
      IMPLICIT NONE
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/

      REAL, INTENT(IN)            :: A(NTH,NK)
      INTEGER, INTENT(IN)         :: JSEA
      REAL, INTENT(IN)            :: T02
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      REAL                        :: Ts, DEPTH, KDPT
      ! 1st circular moment fit
      real                        :: m1t
      ! Tail mean direction and spectral level parameter
      real                        :: thetat, Dsn

      INTEGER               :: numDepths, IZ, nt, ntt, ntr

      ! Factors for the diagnostic (spectral tail) calculation
      REAL                  :: Rk, fOfp_ini, ntf

      ! Factors for the prognostic calculation
      REAL                  :: A2S0, AX, AY, EDWTZ, DDWTZ

! cha 20110627: Tail transition indices
      REAL                  :: FACDIA

      INTEGER               :: ISEA, ITH, IK, NIK
      REAL                  :: CTH, STH
      REAL                  :: bandDia

      ! Status integer
      INTEGER               :: II

! Integral pseudo-momentum parameters
      REAL                  :: A2M, Mdiag, MprogX, MprogY, &
                               MtransX, MtransY

! Stokes drift wave number scale and parameters for 'inlined version of WAVNU1'
      real                  :: SIX, R1
      INTEGER               :: I1

!/DIST        ISEA       = IAPROC + (JSEA-1)*NAPROC
!/SHRD        ISEA       = JSEA

      ! Ts is an integral wave period chosen as Ts==T02
      Ts = T02

      CTH=0.
      STH=0.
      MprogX = 0.
      MprogY = 0.
      MtransX = 0.
      MtransY = 0.
      Mdiag = 0.
      U_S = 0.
      V_S = 0.
      StkDiag = 0.


      if ( xsto_verbose .gt. 1 .and. JSEA .eq. 1 ) &
          WRITE (NDSV, 907), '  Transition range IKTT =', IKTT, 'to IKT =', IKT

      DEPTH  = MAX ( DMIN, DW(ISEA) )

      ! Inlined version of WAVNU1.
      SIX    = TPI/Ts * SQRT(DEPTH)
      I1     = INT(SIX/DSIE)
      IF (I1 .LE. N1MAX) THEN
          R1 = SIX/DSIE - REAL(I1)
          K_S = ( (1. - R1)*EWN1(I1) + R1*EWN1(I1 + 1) ) / DEPTH
        ELSE
          K_S = (TPI/Ts)**2 / GRAV
        END IF

      ! From here, we will use the dimensionless water depth
      KDPT = K_S * DEPTH

      ! numDepths: Number of depths of the discrete profile above the sea floor
      numDepths = XSND ! XSND: Configured value

      do IZ = XSND,1,-1
        if ( ZK_S(IZ) > KDPT ) cycle
        numDepths = IZ
        exit
        end do

      if ( xsto_verbose .gt. 2 ) &
        WRITE (NDSV, 905), 'numDepths =', numDepths, 'XFR =', XFR, 'IKT =', IKT

      if ( IKT < IKTT ) then

        if ( xsto_verbose .gt. 0  .and. JSEA .eq. 1 ) &
          WRITE (NDSV, 912), 'Truncate at NK-2. No diagnostic spectral extension'

      else

        if ( xsto_verbose .gt. 1  .and. JSEA .eq. 1 ) &
             WRITE (NDSV, 912), '    .. for the diagnostic part'

        ! At the prognostic range cut-off frequency, derive the mean direction
        ! thetat, the 1st circular moment m1t, and the spectral level Dsn
        call prog_edge_DE( A, thetat, m1t, Dsn, JSEA)

        CTH=cos(thetat)
        STH=sin(thetat)

        ! Initialize the module parameter fOfp, if needed
        if ( fOfp(JSEA) .eq. 0.0 ) then
          ! Initial guess of equivalent peak wave period fp = 1.2* 1/Tz
          fOfp_ini = max( 1.2 * Ts * SIG(IKT) / TPI, fOfp_min )
          fOfp(JSEA) = fOfp_ini
          if ( xsto_verbose .gt. 2 ) &
               WRITE (NDSV, 900), '-> initial estimate, fd/fp =', fOfp_ini
        else
          fOfp_ini = fOfp(JSEA)
          if ( xsto_verbose .gt. 2 ) WRITE (NDSV, 900), &
               '. Use Last estimate as initial for fd/fp =', fOfp_ini
        end if

        IF ( m1t .ne. 0 ) THEN
          ! Calculate the equivalent value of fd/fp in stokes drift tail
          ! ( using Ewans' formulas )
          call equivalent_tail(m1t, fOfp(JSEA), stat=II)

          if ( II > 0 ) then
            ! New guess of equivalent peak wave period fd/fp

            fOfp(JSEA) = max( 1.2 * Ts * SIG(IKT) / TPI, fOfp_min )
            if ( fOfp(JSEA) /= fOfp_ini ) then
               fOfp_ini = fOfp(JSEA)
               call equivalent_tail(m1t, fOfp(JSEA), stat=II)
            end if
            if ( II > 0 ) then
               fOfp(JSEA) = fOfp_ini + 0.125 * ( 10.0 - fOfp_ini )
               if ( xsto_verbose .gt. 0 ) then
                  WRITE (NDSV, 900),  &
                       'Issue in w3xstomd, equivalent_tail() for Ts = ', Ts
                  WRITE (NDSV, 908), 'status = ', II, &
                       '  -> Use an enhanced estimate, fd/fp =', fOfp(JSEA)
                  WRITE (NDSV, 907), ' ISEA = ', ISEA, &
                       'at I =', MAPSF(ISEA,1), ', J =',MAPSF(ISEA,2)
               end if
               call equivalent_tail(m1t, fOfp(JSEA), stat=II)
            end if
          end if
          if ( II > 0 ) then
            fOfp(JSEA) = fOfp_ini
            if ( xsto_verbose .gt. 0 ) then
               WRITE (NDSV, 908), &
                    'Still a Stokes issue, status = ', II, &
                    '. Use a parametric fd/fp =',  fOfp(JSEA)
            end if
          end if
        END IF

        fOfp(JSEA) = min( max ( fOfp(JSEA), fOfp_min ), DFH**NP)

        ! Index nt in SBDiaZ(:,nt) corresponds to fd/fp rounded to nearest
        ! integer: fd/fp = DFH**ntf; nt=nint( ntf )
        ! The part of the pre-calculated tail that covers the present tail
        ! is the range ntt = nt,NP
        ntf = log( fOfp(JSEA) ) / log(DFH)
        ntf = max( min(ntf,real(NP)), 1. )
        nt = nint( ntf )

        ! The high-frequency tail truncation bin ntr exceeds the
        ! transition bin ntf at SIG(IKT) by ntre bins
        ntr = nint( ntf + ntre )
        ! There is a forced truncation at the highest pre-calculated tail
        ! bin NP
        ntr = min(ntr,NP)

        ! Now, let ntf be the fractional part of nt
        ntf = ntf - nt

        ! The integrated pseudo-momentum of the diagnostic spectral tail is
        ! Mdiag = Dsn * sigP^{-2} Im(nt), where nt = log(ft/fP)/log(DFH)
        ! and sigP = SIG(IKT) / fOfP.
        ! Linear interpolation to nt+ntf between bins nt and nt+1. Note
        ! that if nt == NP, then ntf == 0., and note that Im(NP+1) == 0.
        Mdiag = Dsn * ( fOfP(JSEA)/SIG(IKT) )**2              &
                * ( Im(nt) * ( 1. - ntf ) + ntf * Im(nt+1) - Im(ntr+1) )

        ! Calculate a vertical profile for the Stokes Drift. The surface Stokes
        ! drift for every spectral bin is multiplied with a depth factor
        ! EXP( -2 K Z), assuming deep water dispersion relation at the high
        ! frequencies.

        ! We apply a look-up array at bin nt (see SUBROUTINE diag_DE_init()):
        !  SBDiaZ(iz,nt) = DStkOsn(nt) *  exp ( -2*Rk(nt) * ZK_S(iz) )
        ! where  fOfp(JSEA)**2 is in the interval [Rk(nt), Rk(nt+1)[
        ! The look-up array is initialized in the procedure XSTOKES_INIT()

        ! The normalized ( tail Stokes drift profile ) / Dsn is

        ! -for the fractional interval nt to nt+ntf:
        StkDiag(:) = SBDiaZ(:,nt) * (1. - ntf)

        ! -for the rest of the precalculated tail
        do ntt = nt+1, ntr
          StkDiag(:) = StkDiag(:) + SBDiaZ(:,ntt)
        end do

        if ( xsto_verbose .gt. 1 ) then
          WRITE (NDSV, 905), 'ISEA =', ISEA, ' Dsn/U10 =', Dsn/U10(JSEA), &
               ' U10 =', U10(JSEA), ' Ts =', Ts
          WRITE (NDSV, 905), &
               ' ft/fP =', fOfp(JSEA), ' StkDiag0 =', StkDiag(1)*Dsn, &
               ' Mdiag = ', Mdiag
        end if

        ! if ( ntr == NP ) then

          !
          ! Not implemented for now: Remaining 'tail of the tail', see end of
          ! SUBROUTINE diag_DE_init.
          !
          ! Simplified model. The surface magnitude StT0*Dsn should be small.
          ! Parameters estimated in diag_DE_init(): The normalized
          ! ( tail-of-the-tail Stokes drift ) / Dsn is
          ! StTail(ZK) = StT0 * exp ( -StTE * ZK ). StT0 and StTE are
          ! estimated by a fit at two points, ZK=(0.0,0.05) .

          ! Rk = -StTE * ( SIG(IKT) /TPI * Ts / fOfP(JSEA) )**2

          ! StkDiag(:) = StkDiag(:) + StT0 * exp ( ZK_S(:)*Rk )


          ! if ( xsto_verbose .gt. 2 ) &
          !    WRITE (NDSV, 906), 'Rk =', Rk, 'nt =', nt

        !   end if

        ! Multiply with the normalization factor (spectral level * U10)
        StkDiag(:) = StkDiag(:) * Dsn

        ! The drift values be zero below the sea floor
        StkDiag(numDepths+1:XSND) = 0.

      end if ! ( IKT < IKTT )

      ! Prognostic spectrum range IK=1, IKTT-1

      if ( xsto_verbose .gt. 1 ) then
        WRITE (NDSV, 912), '    .. for the prognostic part'
      end if

      ! Stokes exponential shape (profile in deep water) at ISEA for IK=1:
      ! EZTK(:) = EXP( -2. * WN * Z_S(:) )
      EZTK(:) = 1

      MprogX = 0.
      MprogY = 0.

      ! In XSTOKES_INIT:
      DWN(1) = WN(1,ISEA)
      DWN(2:NK) = WN(2:NK,ISEA) - WN(1:NK-1,ISEA)

      TZ_S(:) = -2.0 * ZK_S(:)/K_S

      DO IK=1, IKTT-1

        ! Conversion factor for Action spectrum to Stokes at the surface, A2S0
        ! SIG: angular frequency
        ! CG: Group velocity
        ! DDEN(IK): Spectrum 2D bin size DTH * DSII(IK)
        ! WN(IK,ISEA): Wave number of the spectrul bin

        ! Action-to-momentum factor, times angular frequency.
        ! M = A k, also in shallow water.
        A2M = WN(IK,ISEA) * DDEN(IK) / CG(IK,ISEA)
        ! Action-to-Stokes factor at surface
        A2S0 = 2.0 * A2M * SIG(IK)
        ! Action-to-pseudo-momentum factor
        A2M = A2M / SIG(IK)

        ! Stokes profile exponential shape at ISEA for IK:
        ! EZTK(:) = EXP( - 2. * WN * Z_S(:) )
        ! Remember, the values of Z_S depend on the actual value of K_S
        ! EZTK(1) == 1. at the surface, always

        ! In order to calculate the exponential of a small argument (< order 1),
        ! it may be faster to increment from IK-1: Use DWN(1:NK)

        EZTK(:) = EZTK(:) * EXP( DWN(IK) * TZ_S(:) )

        ! Action spectrum at frequency bin IK projected on x and y
        AX = 0.
        AY = 0.
        DO ITH=1, NTH
          AX = AX + A(ITH,IK) * ECOS(ITH)
          AY = AY + A(ITH,IK) * ESIN(ITH)
          END DO

        ! Stokes vertical profile for a finite water depth

        ! Action-to-Stokes-profile factor A2S
        if (fkdm(IK,JSEA) .le. 0.) then
          ! Deep water
          A2S(:) = A2S0 * EZTK(:)
        else
          ! Finite water depth
          A2S(:) = A2S0 * ( fkd(IK,JSEA) * EZTK(:) + fkdm(IK,JSEA) / EZTK(:) )
          end if

        ! Stokes drift projected on grid-Eastern and -Northern components
        U_S(:) = U_S(:) + AX * A2S(:)
        V_S(:) = V_S(:) + AY * A2S(:)

        ! Integral pseudo-momentum per unit surface area, divided by rho_w*GRAV
        MprogX = MprogX + A2M * AX
        MprogY = MprogY + A2M * AY

        END DO

      ! Smoothen the transition from the prognostic to the diagnostic range

      NIK = IKT - IKTT + 1
      ! Existance of at least one transitional bin means there is a tail
      ! Note, the highest bin has width 0.5
      if (xsto_verbose .gt. 1 .and. NIK > 0) &
        WRITE (NDSV, 907), '    .. for the transitional tail',IKTT, 'to', IKT

      ! Stokes exponential shape at ISEA for IK=IKTT-1:
      ! EZTK(:) == EXP( WN(IKTT-1,ISEA) * TZ_S(:) )

      DO IK=IKTT, IKT

        ! ( We silently ignore a possible case that the bin of the peak > IKTT
        ! This has little influence when IKTT is large enough that the Stokes
        ! drift becomes small anyway.)

        ! Action-to-momentum factor, times angular frequency.
        ! M = A k, also in shallow water.
        A2M = WN(IK,ISEA) * DDEN(IK) / CG(IK,ISEA)
        ! Take only half of the highest bin
        IF ( IK == IKT ) A2M = A2M * ( sqrt(XFR) - 1 )/( XFR - 1 )

        ! Action-to-Stokes factor at surface
        A2S0 = 2.0 * A2M * SIG(IK)
        ! Action-to-momentum factor
        A2M = A2M / SIG(IK)

        ! Action in spectral band projected on x and y
        AX = 0.
        AY = 0.

        do ITH=1, NTH
          AX = AX + A(ITH,IK) * ECOS(ITH)
          AY = AY + A(ITH,IK) * ESIN(ITH)
          end do

        ! Surface diagnostic tail Stokes drift transformed to wave action
        bandDia = SBDiaZ( 1, nt - (IKT-IK) ) * Dsn / A2S0

        ! Apply a nearly linear interpolation between prognostic and
        ! diagnostic limits to damp influence of spurious peaks near IKT.
        ! Assuming surface Stokes drift in the band is nearly a constant as
        ! function of the frequency

        FACDIA = (float(IK - IKTT) + 0.5)/NIK
        AX = AX * (1.-FACDIA) + bandDia * CTH * FACDIA
        AY = AY * (1.-FACDIA) + bandDia * STH * FACDIA

        ! Stokes profile exponential shape:
        ! EZTK(:) = EXP( - 2. * WN * Z_S(:) )

        EZTK(:) = EZTK(:) * EXP( DWN(IK) * TZ_S(:) )

        ! Action-to-Stokes profile factor
        A2S(:) = A2S0 * EZTK(:)

        ! Stokes drift projected on x and y
        U_S(:) = U_S(:) + AX * A2S(:)
        V_S(:) = V_S(:) + AY * A2S(:)

        ! Integrated pseudo-momentum
        MtransX = MtransX + A2M * AX
        MtransY = MtransY + A2M * AY

        END DO !IK=IKTT, IKT

      if ( IKT >= IKTT ) then
        ! Add the contributions from the tail, projected on x and y
        U_S(:) = U_S(:) + StkDiag(:) * CTH
        V_S(:) = V_S(:) + StkDiag(:) * STH
        MprogX = MprogX + MtransX + Mdiag * CTH
        MprogY = MprogY + MtransY + Mdiag * STH
        end if

      ! Let the drift be zero below the sea floor
      U_S(numDepths+1:XSND) = 0.
      V_S(numDepths+1:XSND) = 0.

      ! The integral pseudo-momentum per unit surface area, divided by density
      M_X = MprogX * GRAV
      M_Y = MprogY * GRAV

      ! Output if high level of verboseness

      if ( xsto_verbose .le. 1 ) return

      WRITE (NDSV, 912), '    .. done'

      ! Compare M_X, M_Y with the depth-integrated Stokes drift.
      ! Depth-integration is approximated as a sum over Z_S(1:numDepths).
      !
      MW_U = SUM ( U_S(1:numDepths) * DZK_S(1:numDepths)/K_S )
      MW_V = SUM ( V_S(1:numDepths) * DZK_S(1:numDepths)/K_S )

      ! Depth of lower edge of the layer at numDepths
      if ( ZK_S(XSND) > KDPT ) then
         MW_U = MW_U - SUM ( U_S(1:numDepths) * ( DZK_S(numDepths)  &
                             - (0.5*(ZK_S(IZ-1) + ZK_S(IZ)) - KDPT) )/K_S )
         MW_V = MW_V - SUM ( V_S(1:numDepths) * ( DZK_S(numDepths)  &
                             - (0.5*(ZK_S(IZ-1) + ZK_S(IZ)) - KDPT) )/K_S )
      end if
      ! Linear interpolation in the uppermost layer
      MW_U = MW_U - 0.25 * ( U_S(1) - U_S(2) ) * DZK_S(1)/K_S
      MW_V = MW_V - 0.25 * ( V_S(1) - V_S(2) ) * DZK_S(1)/K_S

      Mdiag = Mdiag  * GRAV

      WRITE (NDSV, 914), ' MW_U, MW_V  = ', MW_U,  MW_V
      WRITE (NDSV, 914), ' M_X, M_Y    = ', M_X,  M_Y
      if ( xsto_verbose .gt. 2 ) then
        WRITE (NDSV, 914), ' Mt_X, Mt_Y  = ', MtransX * GRAV, MtransY * GRAV
        WRITE (NDSV, 914), ' Md_X, Md_Y  = ', Mdiag * CTH, Mdiag * STH
        WRITE (NDSV, 914), 'MDi = ', &
             SUM ( StkDiag(1:numDepths) * DZK_S(1:numDepths)/K_S ) &
             - 0.25 * ( StkDiag(1) - StkDiag(2) ) * DZK_S(1)/K_S
      end if

! Formats
!
  900 FORMAT ('  ',A,G9.2)
  902 FORMAT ('  ',A,I5)
  905 FORMAT ('  ',A,I6,6(A,G9.2))
  906 FORMAT ('  ',6(A,G9.2))
  907 FORMAT ('  ',3(A,I6))
  908 FORMAT ('  ',A,I2,A,G9.2)
  909 FORMAT ('  ',2(A,G9.2))
  910 FORMAT ('  ',A,100G9.2)
  912 FORMAT ('  ',A)
  914 FORMAT ('  ',A,4(F8.4,', ',F8.4))
  915 FORMAT ('  ',A,9F8.4)

      END SUBROUTINE DSTOKES


      SUBROUTINE diag_DE_init(Np)

      !  Stokes drift for the diagnostic tail of Donelan_Ewans spectrum.
      !  Set parameters in Ewans' formulas
      !  Pre-calculate for XSTOKES_INIT and CALC_XSTOKES:
      !   - A normalized array DStkOsn(1:NK+1)
      !   - Table Im(1:Np) of normalized integrated momemtum
      !   - Not implemented for now: StT0, StTE: Parameters in a simplified
      !     'tail of the tail'
      !
      !  The surface Stokes drift for every spectral bin is multiplied with
      !  the depth factor EXP( -2 K Z), assuming deep water dispersion relation
      !  at the high frequencies.

      !  Calculation of the tail directional spreading:
      !
      !  Given a spectrum of shape
      !  S(omega) = H(omega,theta) * alpha * U * g * omega^{-4}
      !
      !  Let fh = f/fP denote the ratio of spectral bin frequency to the peak
      !
      !  At f/fP = 1., the contribution for the logarithmic bin of width log(df)
      !  to the surface Stokes drift is alpha * U times the factor
      !    SOsn = 2 * ( first circular moment ) * d f / f
      !  The first circular moment is defined as
      !    m1 = int_{-pi}^pi cos(theta) H(omega,theta) d theta
      !  Ewans (1997) provides an expression given as a function
      !  m1E(f/fP), based on at fit to observations (the 'Maui'
      !  experiment).
      !
      !  The binned contribution to the stokes drift is influenced by the first
      !  circular moment m1. A freq^{-4} spectral tail is assumed in the form
      !     d Stokes(f) = 2 alpha U m1 d f / f
      !
      !  With Ewans' expression for the directional spread:
      !     sigma = sa - sb * (fP/f)**2
      !     theta_m1 = ta * exp( tb * fP/f )
      !     m1E = cos(theta_m1) * exp( -(sigma**2)/2 )
      !
      !  In the vicinity of fh=f/fP ~ fh0 ~ 2.5, this may be approximated as
      !     m1t(fh) = m1E(fh=1) * exp( aa sinh(phih * (fh - 1.)) )
      !  where
      !     phih = (1/(aa m1) * {d m1 / d fh}
      !  m1t(fh) converges to zero at high frequences.
      !
      !  Choices of these parameters were compared graphically in a Python
      !  program and we end up with a good overall fit choosing
      !
      !  phih=-0.187
      !  aa = 1.25
      !

!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      IMPLICIT NONE

      integer, intent(in)        :: Np

      ! local variables
      real                       :: aa,phih,logdf
      real                       :: fht, fh
      real                       :: dfhi
      real                       :: fhPm2, idf2, df2, ImS

      integer                    :: iz, N, nt, ntt, Npcut

      ! The part of the pre-calculated tail that covers the present tail
      ! is the set of bins ntt >= nt

      ! Set parameters in Ewans' formulas
      sa = 32.13/RADE
      sb = 15.393/RADE
      ta = exp(5.453)/RADE / 2.
      tb = -2.750
      tc = 0.0845

      ! fOfpCut is an order of magnitude cut-off at the upper limit of
      ! validity for the directional distribution formula. The associated bin
      ! number is Npcut = Np + int(log(fOfpCut)/log(DFH))
      fOfpCut = 10.0

      ! Smallest fOfp valid for our approximations to Ewans' formulas
      fOfp_min = sqrt(sa/sb)

      ! A practical asymptotic value for small fOfp in m1_Ew98():
      m_deriv_min = m1deriv_Ew98( fOfp_min )

      ! First circular moment at fOfp_min
      m1_max = m1_Ew98( fOfp_min )

      logdf = log(DFH) ! Log of the increment frequency factor
                       ! Be aware: DFH may *differ* from the prognostic bin
                       ! increment factor XFR

      ! The bin number associated with fOfpCut is
      Npcut = Np + int( log(fOfpCut)/logdf )

      ! Inverted integration frequency increment
      dfhi = 1./DFH

      ! Suggested approximation, parameter values
      aa = 1.25
      phih = -0.187

      fh = 1.
      do nt = 1,Np
        DStkOsn(nt) = exp( aa * sinh(phih * (fh - 1.)) )
        fh = fh * DFH
        end do

      ! A discrete array representing d Stokes(f) / (alpha U) then becomes
      ! (with d f / f = logdf)

      DStkOsn = m1_Ew98(1.) * DStkOsn * 2. * logdf

      ! Lookup table Im(1:Np) (See '4. Integrated pseudo-momentun')

      fht = DFH**Np ! Value of fh just beyond the prognostic tail

      fh = fht
      fhPm2 = 1./fht**2
      idf2 = 1./DFH**2
      ImS = 0.
      do ntt = Np + 1, Npcut
        fhPm2 = fhPm2 * idf2 != 1./(fh*DFH)**2 = fh ^ -2
        fh = fh * DFH
        ImS = ImS + exp( aa * sinh(phih * (fh - 1.)) ) * fhPm2
        end do

      Im(Np) = ImS

      ! Step downwards the spectral frequencies of possible values of ft/fP
      fh = fht
      fhPm2 = 1./fht**2
      df2 = DFH**2
      do nt = Np-1,1,-1
        Im(nt) = Im(nt+1) + exp( aa * sinh(phih * (fh - 1.)) ) * fhPm2
        fhPm2 = fhPm2 * df2 != 1./(fh/DFH)**2 = fh ^ -2
        fh = fh * dfhi
        end do

      Im(Np+1) = 0. ! When used in extended linear interpolation
      Im(:) = Im(:) * ( m1_Ew98(1.) * logdf )

      if ( xsto_verbose .gt. 2 ) WRITE (NDSV, *), 'Im(:) =', Im(:)

      ! Not implemented for now:
      ! Supplemental tail beyond nt = Np

      ! A two-parameter, simplified  model is applied
      ! StTail(ZK) = StT0 * exp ( -StTE * ZK ).
      ! StT0 and StTE are estimated by a fit at two points, ZK=(0.0,0.05) .
      ! Start with:

      ! StT0 = 0.
      ! StT1 = 0.
      ! fht = DFH**Np ! Value of fh just beyond the prognostic tail
      ! k2T = 2. * XKH**Np

      ! Fit at two points, ZK=(0.0,0.05) .
      ! fh = fht ! Value of fh just beyond the prognostic tail
      ! k_c = k2T
      ! do ntt = Np + 1, Npcut
      !    StT0 = StT0 + exp( aa * sinh(phih * (fh - 1.)) )
      !    fh = fh * DFH
      !    end do
      ! fh = fht
      ! k_c = k2T
      ! do ntt = Np + 1, Npcut
      !    StT1 = StT1 + exp( -k_c * 0.05 + aa * sinh(phih * (fh - 1.)) )
      !    fh = fh * DFH
      !    k_c = k_c * XKH
      !    end do

      ! StTE = -log(StT1/StT0) / 0.05
      ! StT0 = StT0 * SOsn
      ! if ( xsto_verbose .gt. 2 ) WRITE (NDSV, *), &
      !         '   StT0, StTE =', StT0, StTE

      if ( xsto_verbose .gt. 2 ) &
        WRITE (NDSV, 906), 'Ewans parameters: sa =', sa, &
               'sb =', sb, 'ta =', ta, 'tb =', tb, &
               'fOfp_min =', fOfp_min, 'm_deriv_min =', m_deriv_min

  904 FORMAT ('  ', A,I5,A)

  906 FORMAT ('  ', 6(A,G9.2))

      END SUBROUTINE diag_DE_init



!/
!/ ------------------------------------------------------------------- /
!/

      SUBROUTINE prog_edge_DE(A, theta, m1, alphaU, JSEA)

! Donelan-Ewans spectral tail
! At the prognostic edge, estimate:
!        theta:   The mean direction
!        m1:      The 1st circular moment m1
!        alpha*U: The spectral level
!

!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      IMPLICIT NONE
      REAL, INTENT(IN)        :: A(:,:)   ! Wave action
      REAL, INTENT(OUT)       :: theta, m1, alphaU
      INTEGER, INTENT(IN)     :: JSEA

      real, allocatable, save :: DTHsig5_CgG(:,:)
      real, allocatable       :: DTHsig5_G(:)

!     Module arrays. For band summation
      REAL, allocatable, save :: ABst(:), ABsX(:), ABsY(:)

      REAL                    :: a1, b1

      REAL                    :: SUM,SS,SUMX,SUMY

      INTEGER                 :: KSEA, ISEA, ITH, NS, JK, IK, IERR

! Spectral level of the tail, assuming S(sig) = alphaU * GRAV * sig^-4
! alphaU = block_mean( \sum A(IK) * FACTOR), where
! FACTOR(IK,JSEA) = sig(IK)/Cg(IK,JSEA) * dth * sig(IK)**4/GRAV ):

!     ABs, ABsX, ABsY : Arrays for band summation
      IF ( .not. allocated(ABst) ) THEN
        allocate ( ABst(IKT-IKTT+1), stat=IERR )
        allocate ( ABsX(IKT-IKTT+1), stat=IERR )
        allocate ( ABsY(IKT-IKTT+1), stat=IERR )
        END IF

!   Factors for calculating the spectral level of the tail
      IF ( .not. allocated(DTHsig5_CgG) ) THEN
        allocate ( DTHsig5_CgG(NK,NSEAL), stat=IERR )
        allocate ( DTHsig5_G(NK), stat=IERR )

        DO JK=1,NK
          DTHsig5_G(JK) = DTH * SIG(JK)**5/GRAV
          END DO

        DO KSEA=1,NSEAL
!/DIST          ISEA         = IAPROC + (KSEA-1)*NAPROC
!/SHRD          ISEA         = KSEA
          DO JK=1,NK
            DTHsig5_CgG(JK,KSEA) = DTHsig5_G(JK) / CG(JK,ISEA)
            END DO

          END DO

          deallocate ( DTHsig5_G )
        END IF

! As w3iogomd 2.a: Initialize wave action in band
!
      ABst    = 0.
      ABsX    = 0.
      ABsY    = 0.

      NS=IKT-IKTT+1

      DO JK=1,NS
!
! As w3iogomd 2.b : Integrate wave action in band
!
        IK = JK+IKTT-1
        DO ITH=1, NTH
          ABst(JK)  = ABst(JK) + A(ITH,IK)
          ABsX(JK)  = ABsX(JK) + A(ITH,IK)*ECOS(ITH)
          ABsY(JK)  = ABsY(JK) + A(ITH,IK)*ESIN(ITH)

          END DO

        ! Spectral level of the tail, assuming S(sig) = alphaU * GRAV * sig^-4
        ! alphaU = block_mean( ABst(JK) ):

        ABst(JK) =  ABst(JK) * DTHsig5_CgG(IK,JSEA)

        END DO

      SUM=0.
      DO JK=1,NS
        SUM = SUM + ABst(JK)
        END DO
      alphaU = SUM / NS

      SS=0.
      DO JK=1,NS
        IK = JK+IKTT-1
        SS = SS + ABst(JK)*ABst(JK)
        ABsX(JK) = ABsX(JK) * DTHsig5_CgG(IK,JSEA)
        ABsY(JK) = ABsY(JK) * DTHsig5_CgG(IK,JSEA)
        END DO

      SUMX=0.
      SUMY=0.
      DO JK=1,IKT-IKTT+1
            SUMX = SUMX + ABsX(JK)
            SUMY = SUMY + ABsY(JK)
      END DO

      theta = ATAN2( SUMY, SUMX )
      ! Spectral circular moment
      a1 =  SUMX/SUM
      b1 =  SUMY/SUM

      m1 = sqrt( a1**2 + b1**2 )

! cha 20110523 notes:
!    This conversion to energy is similar to
!    w3iogomd.ftn and the 'Test output' in w3updtmd.ftn.
!    In w3iogomd it is:  ET = sum( A * DDEN(IK) / CG(IK,ISEA) )
!    In 'Test output': ETOT = sum( A * DSIP(IK) * SIG(IK) / CG(IK,ISEA) * DTH )
!
!    The parameters are set running ww3_grid.ftn. Here,
!    DSIP(IK) = SIGMA * SXFR(IK), where SXFR = 0.5 * (XFR-1./XFR) (~ 0.1)
!    DDEN(IK) = DTH * DSIP(IK) * SIG(IK)
!
!    Wave-number and frequency energy spectrum are related as
!    (User manual for WW3, MMAB_276.pdf, Eq. 2.4):
!    F(k,th) dth dk = S(\sigma,th) dth d\sigma
!    Thus, wave-number action spectrum, A(k) = F(k)/\sigma, is:
!    A(k,th) dth dk = S(\sigma,th) / \sigma dth d\sigma
!
!    Komen et al., 1994 (the WAM Book) has a different definition
!    of spectral density in the wavenumber domain (Eq. 1.137):
!    F(k,th) k dth dk = S(\sigma,th) dth d\sigma
!
  906 FORMAT ('  ',6(A,G9.2))

      END SUBROUTINE prog_edge_DE

!/
!/ ------------------------------------------------------------------- /
!/

      SUBROUTINE equivalent_tail(m1,fOfpE,fOfp0,fOfp1,xacc,stat)
      ! Given a first circular moment m1, determine an equivalent value of
      ! the spectral peak, f/fpE, that reproduces the Maui spectral shape
      ! (see function m1_Ew98()).

      IMPLICIT NONE

      real, intent(in)           :: m1
      real, intent(inout)        :: fOfpE
      integer, intent(inout), optional  :: stat
      real, intent(in), optional :: fOfp0, fOfp1, xacc

      real                       ::  fOfp0_, fOfp1_, xacc_
      integer                    ::  status_

      ! Default values
      fOfp0_=1.0
      fOfp1_=10.5751
      xacc_=0.01
      ! Substitute with optionals
      if ( present(fOfp0)) fOfp0_=fOfp0
      if ( present(fOfp1)) fOfp1_=fOfp1
      if ( present(xacc)) xacc_=xacc

      ! Determine the value of the equivalent peak (fp) from a root fOfpE of
      ! m1Ed_Ew98(fOfp) = ( m1_Ew98( fOfp ) - m1 ). First set a global
      ! representation of m1 as a limited value m1E:

      if ( m1 > m1_max ) then
        m1E = m1_max
      else
        m1E = m1
        end if

      ! Determine the root fOfpE
      fOfpE = rtnewt(m1Ed_Ew98, fOfpE, 0.0, fOfp1_, xacc_, status_)

      ! Validate the result
      if ( (fOfp0_-fOfpE)*(fOfpE-fOfp1_).lt.0.) then
        if (xsto_verbose .gt. 0) &
          WRITE (NDSV, 908), 'WARNING: fOfpE = rtnewt() =', fOfpE, &
            '. Result beyond valid range [',fOfp0_,',',fOfp1_,'] . m1=', m1
        status_ = 3
        end if

      if (present(stat)) stat = status_

  908 FORMAT ('  ',8(A,G9.2))

      end SUBROUTINE equivalent_tail

!/ ------------------------------------------------------------------- /
!/
! Numerical recipes Par. 9.4: Newton-Raphson Method Using Derivative
!
      REAL FUNCTION rtnewt(funcd,rtnewtv,x1,x2,xacc,status)

      IMPLICIT NONE

      INTEGER                 :: JMAX
      REAL, INTENT(IN)        :: rtnewtv,x1,x2,xacc
      INTEGER, INTENT(OUT)    :: status
      EXTERNAL funcd
      PARAMETER (JMAX=20) ! Set to maximum number of iterations.
      ! Using the Newton-Raphson method, find the root of a function known
      ! to lie in the interval [x1, x2]. The root rtnewt will be refined
      ! until its accuracy is known within +/-xacc. funcd is a user-supplied
      ! subroutine that returns both the function value and the first
      ! derivative of the function at the point x.
      ! rtnewt=.5*(x1+x2) Initial guess.
      INTEGER                 :: j
      REAL                    :: df,dx,f
      status = 0

      if (xsto_verbose .gt. 2) &
        WRITE (NDSV, 906), '  m1E = ', m1E, 'fOfpf =', rtnewtv

      rtnewt = rtnewtv !Initial guess.

      do j = 1, JMAX
        call funcd(rtnewt,f,df)
        dx=f/df
        rtnewt=rtnewt-dx

        if((x1-rtnewt)*(rtnewt-x2).lt.0.) then
          if (xsto_verbose .gt. 1) &
            WRITE (NDSV, 914), '  WARNING in w3dstkmd.ftn: rtnewt =', rtnewt, &
                               'jumped out of brackets'
          if (xsto_verbose .gt. 2) then
            WRITE (NDSV, 906), '  [',x1,',',x2,'] . f=', f, 'df=',df
            WRITE (NDSV, 906), '  j=', j, 'rtnewtv=', rtnewtv, 'm1E=', m1E
            end if
          status=2
          rtnewt = rtnewtv
          return
          end if

        if ( abs(dx) .lt. xacc) return ! Convergence.
        end do

      status=1
      rtnewt = rtnewtv
        if (xsto_verbose .gt. 1) &
          WRITE (NDSV, 912), '  WARNING in w3dstkmd.ftn: rtnewt exceeded', &
                             ' maximum iterations'


  906 FORMAT ('  ',6(A,G9.2))
  912 FORMAT ('  ',6A)
  914 FORMAT ('  ',A,G9.2,A)

      END FUNCTION rtnewt

!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE m1Ed_Ew98(fOfp, f, df)

      IMPLICIT NONE
      REAL, INTENT(IN)        :: fOfp
      REAL, INTENT(OUT)       :: f, df

      f = m1_Ew98(fOfp) - m1E
      df = m1deriv_Ew98(fOfp)

      END SUBROUTINE m1Ed_Ew98


!/ ------------------------------------------------------------------- /
!/
      real function m1_Ew98(fOfp)

        real, intent(in)        :: fOfp
        real                    :: m1, fpOf, sigma, theta_m1, fpD

        if (fOfp .lt. fOfp_min) then
            fpOf = 1./fOfp_min
            fpD = fOfp - fOfp_min
        else
            fpOf=1./fOfp
            fpD = 0.0
        end if

        sigma = sa - sb * fpOf**2

        theta_m1 = ta * exp( tb * fpOf )

        m1_Ew98 = cos(theta_m1) * exp( -(sigma**2)/2 )

        ! Define a practical asymptotic value for small fOfp:
        if ( fpD .lt. 0.0 ) then
            m1_Ew98 = m1_Ew98 + fpD * m_deriv_min
        end if

      end function m1_Ew98


      real function m1deriv_Ew98(fOfp)

      real, intent(in)        :: fOfp
      real                    :: fpOf, sigma, theta_m1

      if (fOfp .lt. fOfp_min) then
        m1deriv_Ew98 = m_deriv_min
        return
        end if

      fpOf = 1./fOfp
      sigma = sa - sb * fpOf**2

      theta_m1 = ta * exp( tb * fpOf )

      m1deriv_Ew98 = ( sin(theta_m1) * theta_m1 * tb &
                        - cos(theta_m1) * sigma * 2. * fpOf * sb ) &
                      * exp( -(sigma**2)/2 ) * fpOf**2


      end function m1deriv_Ew98


!/
!/ End of W3XSTOMD ----------------------------------------------------- /
!/
      END MODULE W3XSTOMD


