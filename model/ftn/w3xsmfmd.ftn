#include "w3macros.h"
!/ ------------------------------------------------------------------- /
      MODULE W3XSMFMD
!/
!/                  +---------------------------------------------+
!/                  | Mattsson-Hansen fit to Stokes drift profile |
!/                  |          Carsten Hansen                     |
!/                  | Joint GeoMETOC Support Center Denmark       |
!/                  |                          FORTRAN 90         |
!/                  | Last update :           09-OCT-2019         |
!/                  +---------------------------------------------+
!      TODO:
!       X) USERO should be exchanged with an array completely similar to US3D
!       X) Test if AM_tune adds value in practice. Thus subroutine IP_calc may
!          be a function call IPp = IP_calc( KsD, AM, PM)
!       X) MKignore might follow the prognostic fcut
!       X) Test if it has practical significance to swap if 1. - IPp/IPd < 0
!       X) Test if PM limiter is relevant: PMAX = 1
!       X) Consider a look-up table and function calls IPd=IPds(KsD,K_S)
!          and IPp=IPps(KsD,K_S)
!       X) In Mfit_init, Pds = exp ( - AMds * ZK_S ** PMds )
!          Then in each Stokes_Mfit(): initial guess Pd = Pds
!
!/
!/    02-May-2011 : Origination. Development program w3stokes.ftn converted
!/                  from tested Python code
!/    27-Jun-2011 : First module version w3dstkmd.ftn. Output tested with
!/                  a stand-alone program w3stokes.ftn.Implementation plan.
!/    18-Aug-2011 : Calculate fit to Mattsson parametric profile (ver.0.12)
!/    10-Oct-2011 : Interface subroutine w3dstk() to ww3_shel (version 0.22)
!/    21-Oct-2011 : Detailed description of implementation into WW3 v.3.14
!/                  First compilation of ww3_shel in parallel mode
!/                  Test-scripts run_ww3test.sh,
!/                     $PERL5LIB/bin/ww3job_preproc (version 0.32)
!/    08-Nov-2011 : Full functioning module. Checked against patches from
!/                  the WW3 errata page, applied: DEPTH=max(DW,DMIN).
!/                  Un-physical spatial discontinuities identified: May
!/                  need to match the Stokes profiles to integral wave
!/                  pseudo-momentum/depth-integrated Stokes drift (ver. 0.32).
!/    23-Nov-2011 : Ajust the deep profile to match the depth-integrated
!/                  Stokes drift. Function AJUST_FIT() (version 0.33).
!/    07-Dec-2011 : Refined ajustment of Mattsson-Hansen profiles to integral
!/                  pseudo-momentum (version 0.41).
!/    20-Feb-2012 : The integrated normalized pseudo momentum of the JM-profiles
!/                  is now (ver. 0.48) calculated from the surface to the
!/                  actual depth, and based on a mathematical expression for
!/                  the integral (not a numerical integral).
!/    02-Aug-2012 : Fitting of deep parameter PMd skipped (ver. 0.52)
!/
!/    06-Aug-2012 : (Ver. 0.55). Introduced a new procedure in profile fitting,
!/                  subroutine fit_parts(), which fully replaces the former
!/                  two-layers fit procedure.
!/                  fit_parts() performs, in a few iterative steps, a
!/                  parametric fit alternating with ajustment to the
!/                  integrated pseudo-momentum.
!/
!/    22-Dec-2017 : Adoption to WW3 version 5.16
!/                  + Call XSTOKES() from W3OUTG(), outside the loop over JSEA
!/
!/    19-Aug-2019 : Adoption to WW3 version 7.XX
!/                  + Mattsson-Hansen fitting is separated to module 'W3XSMFMD'
!/                  + Namelist group &XSTO
!/                  + Clearifying the in-code documentation
!/                  + Dimensionless parameters in calculations, e.g. M -> Kz M
!/                  + Replace Gradshteyn and Ryzhik with Numerical Recipes
!/                    in function gi()
!/                  + Quality count output field
!/                  +
!/
!/    11-Sep-2020 : Apply a lower limiter to abs(M)
!/                  Disabled: AM_tune
!/                  Disabled: swap if 1. - IPp/IPd < 0                    
!/                          
!/    30-Sep-2020 : Lookup table for the reverse of IP_calc when PM==PMds
!/                          
!/
!/
!  1. Purpose, and output data
!
!  A parametric representation of the Stokes drift profile vector U_S(Z) is
!  provided as a sum of two expressions (suggested by J. Mattsson and C.Hansen),
!        U_S(Z) = Up exp( -AM (Z Kz)^PM ) + Ud exp( -AMd (Z Kz)^PMd ) ,
!  where Up + Ud = U0 is the Stokes drift vector at the surface (Z=0) and
!  Z is pointing downwards.
!  A wave number Kz is related to the zero-upcrossing frequency by the
!  linear-wave dispersion relation, (2pi/Tz)^2 = g Kz tanh( Kz D). The
!  local depth D should also be provided in the output field for the bathymetry.
! 
!  The vertical integral of U_S(Z) equals the integral wave (pseudo) momentum
!  vector M. Further details on the Mfit parameters AM, PM, AMd, PMd are
!  found in Sect, 3, 'More on Mfit and suggestions for postprocessing'
!
!  U_S(Z) is determined as a best fit to the total model profile U_mod(Z)
!  constructed as a sum of a prognostic and a diagonostic (tail) contribution.
!  These profiles have been derived from the model spectra + spectral tail
!  using the module XSTOMD and subroutine CALL_XSTOKES(). NDEPTH discrete depths
!  have been given in an array Z_S(1:NDEPTH).
!
!  Also calculated are a scatter index of the profile fit, and a measure of
!  the convergence of the iteration procedure.
!
!  All calculations are performed in parallel and the results are gathered
!  to the process that writes the output using the user-slot variable 'USERO'.
! 
!  For this purpose, the length NOEXTR of the array USERO(JSEA,1:NOEXTR) is
!  extended to the required number of fitting parameters (6) plus one.
!
!  From the array UXSP (see w3xstomd.ftn) at least the following 5 values are
!  stored to out_grd.ww3 to be used in conversion to NetCDF (ww3_ounf) .
!
!    UXSP(JSEA,1)      = Kz        ! g Kz tanh( Kz D) = (2pi/T02)^2 [ 1/m ]
!
!    UXSP(JSEA,2)      = M_X       ! (M_X, M_Y) is the integral pseudo-momentum
!    UXSP(JSEA,3)      = M_Y       ! per unit surface area, divided by density.
!                                  ! [ m^2/s ]        
!    UXSP(JSEA,4)      = U0_X      ! Surface Stokes drift [ m/s ]
!    UXSP(JSEA,4+XSND) = U0_Y      !
!
!  In the array USERO we store other six fitting parameters
!
!    USERO(JSEA,1)   = Ud_X/M2K  ! Normalized surface drift of 'deep' partition
!    USERO(JSEA,2)   = Ud_Y/M2K  ! Primary partition drift is Up = U0 - Ud
!                                ! M2K = 2*Kz*sqrt(M_X^2+M_Y^2)
!    USERO(JSEA,3)   = AM        ! Fit parameter, primary partition
!    USERO(JSEA,4)   = PM        ! Fit parameter, primary partition
!
!    USERO(JSEA,5)   = AMd       ! Fit parameter, deep partition
!                                ! PMd is a global constant (PMd = 0.4)
!
!    USERO(JSEA,6)   = ITSIC     ! Quality count, see Stokes_Mfit()
!    !    I   : Number of iterations in fit_parts
!    !    T   : Number of iterations in AM_Tune
!    !    SI  : Scatter index  std(|U_S - U_mod| * dz)/|M|
!    !    C   : Convergence of iteration
!        
!    ! USERO(JSEA,7) is free to use for other purpose        
!
!  2. Usage
!
!  a) In ww3_shel.inp/ww3_shel.nml, you may modify four namelist variables:
!     $ NDP: Number of depths (->NDEPTH)
!     $ DSC: Depth scale specifying the largest depth Z(NDP)
!     $ TYP: Tail type (C*4); 'DoEw': Donelan-Ewans,
!     $      or 'None': Truncated spectrum
!     &XSTO NDP = 32, DSC = 3.0, TYP = 'DoEw' /
!
!  b) In w3initmd.ftn: Call XSTOKES_INIT() (module W3XSTOMD):
!     Allocation of StkProg(1:NDEPTH,I), StkDiag(1:NDEPTH,I), Z_Stk(1:NDEPTH)
!
!  c) In w3iogomd.ftn: Call the subroutine XSTOKES() (module W3XSTOMD): At each
!     WW3 output time step, calculation of the Stokes drift profile
!
!  d) Call the subroutine Stokes_Mfit () (present module W3XSMFMD):
!     Approximation of the profile with a parametric expression
!        U_S(Z) = Up exp( -AM (Z Kz)^PM ) + Ud exp( -AMd (Z Kz)^PMd ), 
!     where Kz is a characteristic wavenumber corresponding to T02, and the sum
!     of vectors Up + Ud is the Stokes drift at the surface.
!     Further details on the Mfit parameters Up, Ud, AM, PM, AMd, PMd are found
!     in Sect. 3.
!
!  3. More on Stokes_Mfit and suggestions for postprocessing
!
!  In the fitting procedure it is assured that the vertical integral of the
!  parametric drift profile equals the pseudo-momentum (or total Stokes
!  transport vector). Two dimensionless profile shape parameters are calculated,
!     IPp = int_0_D Kz exp( -AM (Z Kz)^PM ) d Z
!     IPd = int_0_D Kz exp( -AMd (Z Kz)^PMd ) d Z
!  where D is the water depth, and Kz a scaling wavenumber related to the
!  zero-crossing period T02 by the dispersion relation for low amplitude waves,
!  (2*pi/Tz)**2 = GRAV * Kz * tanh( D * Kz). (GRAV = 9.81).
!  A subroutine IP_calc is applied to calculate both IP and the differential
!  d(IP*Kz)/dAM.
!
!  Inclusion of the pseudo-momentum vector in the output allows for a possible
!  post-processing with temporal-spatial smoothing of the Mfit parameters
!  AM, PM, AMd, PMd. After smooting, the surface drift should be partioned
!  into a sum of a 'primary' partition and a 'deep' partition, U0 = Up + Ud,
!  following the operations below (Eqs. 1-7). After smoothing it must be
!  assured that the 'deep' profile decays slower than the 'primary' profile,
!  so that the difference of integrated profile shapes IPd - IPp is
!  significantly positive. This can be achieved by ajusting AM towards
!  a value of IPd - IPp which differ only slightly from an original, smoothed
!  value.
!        
!  Output data to use for reconstruction of the Stokes profile are:
!  Seafloor depth, Kz, M = (MX,MY), U0 = U_S(0) = (U0X,U0Y), Ud = (UdX,UdY),
!  AM, PM, AMd, together with a fixed parameters PMd (PMd = 0.4).
!
!  The pseudo-momentum vector, normalized by its depth scale, is
!        
!  (1)     MK = (MX,MY) * Kz
!        
!  The 2-dimensional surface Stokes drift vector
!        
!  (2)     U0 = (U0X, U0Y)
!
!  Factorize the normalized pseudo-momentum vector MK in an 'primary part' and
!  a 'deep part' as
!          MK = Up * IPp + Ud * IPd
!  where the surface Stokes drift is
!          U0 = Up + Ud
!
!  Here, IPp and IPd are dimensionless integrated profiles calculated by the
!  numerical function IP_calc():
!
!  (3)     IPp = IP_calc(Kz*D, AM, PM)
!  (4)     IPd = IP_calc(Kz*D, AMd, PMd)
!
!  Substitution yields a vector expression in the 'primary part' of
!  the surface drift Up, MK = (U0-Up)* IPd + Up * IPp, or
!        
!  (5)     Up = ( U0 * IPd - MK ) / (IPd - IPp)
!        
!  The 'deep part' of the surface drift is the remainder
!
!  (6)     Ud = U0 - Up
!
!  In case IPd ≃ IPp we have MK ≃ U0 * IPp and the values of Up, Ud become
!  ambigous. In any case, a new estimate of the parameter pair (AM, PM) will
!  be calculated by a best-fit method. Let proj_p(Ud) and proj_p(U_mod(z)) be
!  projections on the direction of Up. A 1-dimensional residual profile
!
!  (7)     Ur(Z) = proj_p( U_mod(Z) ) - proj_p(Ud) * exp ( -AMd (Z Kz)^PMd )
!        
!  will be fitted by an shape Up exp( -AM (Z Kz)^PM ). Here the surface 
!  value Ur(Z=0) is the known value of Up. Thus we can  fit the values of
!  log( log( Ur(Z)/Up ) ) (taking the log twice) with a linear expression
!  log(-AM) + PM log(Z Kz). Thereby the values of AM, PM, have been altered.
!
!  An iterative procedure is constructed as follows:
!
!  Calculate the new value of IPp using equation (3), and repeat calculation
!  corresponding to equations (5,6,7), but with the 'primary' and 'deep' parts
!  reverted. Thereby a new value of AMd is obtained by fitting a shape
!  Ud exp( -AMd (Z Kz)^PMd ).
!  Then calculate the new value of IPd using equation (4), and repeat so on.
!  Convergence at iteration step it is measured as
!  C =  | 1 - ( Up * IPp(it-1) + Ud * IPd(it-1) ) | / | MK |.
!
!  4. Implementation in WW3:
!
!  Code lines are added to WW3 under the two compile switches '!/XSTO' and
!  '!/MFIT'. First, follow the implementations as described in w3xstomd.ftn.
!
!  a) w3odatmd.ftn
!
!     Real arrays UXSP(JSEA,1:4), UXSP(JSEA,4+XSND) and USERO(JSEA,1:6) (a
!     "user_slot") contain the 11 Stokes fitting parameters for the sea point
!     JSEA. UXSP and USERO are structures for later communication to the job
!     that performs field output and belong to the module w3adatmd.ftn.
!
!     In w3odatmd.ftn, set the integer NOEXTR to 1 + the number of parameters
!     (6) used in USERO. Remove the 'parameter' type from it's
!     module declaration
!     ! change this line      INTEGER, PARAMETER      :: NOEXTR=  2
!            INTEGER                 :: NOEXTR=  2
!     In subroutine W3NOUT(), set NOEXTR = NOEXSTK and specify the Mfit
!     parameter names
!     !/MFIT      INTEGER, PRIVATE        :: NOEXSTK = 7
!     (...)
!     !/MFIT      NOEXTR = 0
!           DO I=1, MIN ( 20 , NOEXTR )
!             WRITE (STRING,'(A14,I2.2,A4)') 'User defined #', I, '    '
!             IDOUT(10, I) = STRING
!             END DO
!     !/MFIT      NOEXTR = NOEXSTK
!           NOGE(10) = NOEXTR
!     !/MFIT
!     !/MFIT      IDOUT(10, 1)  = 'Deep Stokes drift E.'
!     !/MFIT      IDOUT(10, 2)  = 'Deep Stokes drift N.'
!     !/MFIT      IDOUT(10, 3)  = 'Mfit parameter AM   '
!     !/MFIT      IDOUT(10, 4)  = 'Mfit parameter PM   '
!     !/MFIT      IDOUT(10, 5)  = 'Mfit parameter AMd  '
!     !/MFIT      IDOUT(10, 6)  = 'Quality count ITSIC '
!     !/MFIT      IDOUT(10, 7)  = 'User defined #1     '
!     (...)
!
!  b) w3iogomd.ftn
!
!     b1) SUBROUTINE W3READFLGRD, and also in W3FLGRDFLAG:
!     !/MFIT      USE W3ODATMD, ONLY: NOEXTR
!        (...)
!     ! Group 10
!     !
!                CASE('U1')
!                  FLG2D(10,1)=.TRUE.
!     !/MFIT            FLG2D(10,min(7,NOEXTR))=.TRUE.
!                CASE('U2')
!                  FLG2D(10,2)=.TRUE.
!     !/MFIT           CASE('MFIT')
!     !/MFIT             FLG2D(10,1:NOEXTR-1)=.TRUE.
!        
!     b2) In subroutine W3FLGRDUPDT
!     !/XSTO      ! Set NZO for use in W3DIMA, W3DIMX
!     !/XSTO      NZO = 0
!     !/XSTO      IF ( FLGRD(6,13) ) NZO = XSND
!     !/MFIT      ! For FLGRD(10,1), if FLGRD( 6, 13) is False, only the
!     !/MFIT      ! surface and integral variables are in UXSP(1:NSEA,1:5)
!     !/MFIT      IF ( FLGRD(10,1) .AND. .NOT. FLGRD(6,13) ) NZO = 1
!        
!     b3) In subroutine W3OUTG:
!     Declare use of CALC_MFIT()
!     !/MFIT      USE W3XSMFMD, ONLY: CALC_MFIT
!     (...)
!       (...)
!       !  Add here USERO(JSEA,1) ...
!       !
!       !/XSTO! UXSP(JSEA,1:3+2*XSND) is set by CALC_XSTOKES(A). Thereafter,
!       !/MFIT! USERO(JSEA,1:6) is determined by CALC_MFIT(A)
!       !/MFIT! The combined CALC_XSTOKES(A); CALC_MFIT() are called
!       !/MFIT! outside and after the present loop
!
!     b4) Later in  W3OUTG() just following CALL CALC_XSTOKES():
!     !/XSTO ! Stokes drift with extended tail
!     !/XSTO       IF ( FLOLOC(6,13)        &
!     !/MFIT            .OR.  FLOLOC(10,1)  &
!     !/XSTO                         ) THEN
!     !/XSTO           CALL CALC_XSTOKES(A)
!     !/XSTO         END IF
!     !/MFIT       IF ( FLOLOC(10,1) ) CALL CALC_MFIT()
!     !/XSTO!
!        
!  c) In ww3_ounf.ftn:
!     Define the relevant NetCDF variable names etc.
!
!  d) Modify the makefile scripts (make_makefile.sh, w3_new) as
!     described in the WW3 manual chpt. 5.5
!
!     d1) make_makefile.sh:
!       for type in ...  xsto xsmf; do
!       (...)        
!       case $type in ...
!         (...)        
!     #sort:xsto:
!         xsto ) TY='upto1'
!                ID='Extended tail Stokes drift'
!                TS='XSTO'
!                OK='XSTO' ;;
!     #sort:xsmf:
!         xsmf ) TY='upto1'
!                ID='Stokes drift Mfit'
!                TS='MFIT'
!                OK='MFIT' ;;
!
!       (...)
!       case $prog in
!         (...)
!         ww3_shel) (...)
!                  IO="$IO w3xstomd w3xsmfmd"
!         (...)
!         ww3_multi|ww3_multi_esmf)
!                   (...)
!                   IO="$IO w3xstomd w3xsmfmd"
!       (...)        
!       case $mod in
!          (...)
!          'W3XSTOMD'     ) modtest=w3xstomd.o ;;
!          'W3XSMFMD'     ) modtest=w3xsmfmd.o ;;
!
!     d2) w3_new:
!
!       for key in $keys
!       do
!         case $key in
!           (...)
!           'xsto' ) cd $main_dir/ftn ; touch w3xstomd.ftn
!                                       touch w3initmd.ftn
!                                       touch w3odatmd.ftn
!                                       touch w3gdatmd.ftn
!                                       touch w3iogomd.ftn
!                                       touch w3iogrmd.ftn
!                                       touch ww3_grid.ftn ;;
!           'mfit' ) cd $main_dir/ftn ; touch w3xstomd.ftn
!                                       touch w3xsmfmd.ftn
!                                       touch w3odatmd.ftn
!                                       touch w3gdatmd.ftn
!                                       touch w3iogomd.ftn
!                                       touch w3iogrmd.ftn
!                                       touch ww3_ounf.ftn ;;
!
!  5. Variables and types :
!
!      Name      Type  Scope    Description
!     ----------------------------------------------------------------
!                C*10  Private
!
!     ----------------------------------------------------------------
!
!  6. Subroutines and functions :
!
!      Name      Type  Scope    Description
!     ----------------------------------------------------------------
!
!     ----------------------------------------------------------------
!
!  7. Subroutines and functions used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!
!     ----------------------------------------------------------------
!
!  8. Remarks :
!
!
!  9. Switches :
!
!       !/SHRD  Switch for shared / distributed memory architecture.
!       !/DIST  Id.
!
!       !/ST2   Source term set 2 (Tolman and Chalikov)
!               ST2 is required for consistent similarity.
!
!/NL1

!  10. Source code :
!
      USE W3SERVMD, ONLY: EXTCDE
      USE W3ADATMD, ONLY: USERO
      USE W3ODATMD, ONLY: NDSO, NDSE, NDST, IAPROC, NAPROC, NAPOUT
      USE W3GDATMD, ONLY: XSND, XSDS, NSEAL, NK, NTH, SIG, DMIN
      ! Stokes drift profile data      
      USE W3ADATMD, ONLY: DW, UXSP, ZK_S
      ! XSVB: Verboseness level [0..4] of XSTO output to NDST or NDSO 
      USE W3ODATMD, ONLY: XSVB, NZO

      PRIVATE
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/

      ! Common Stokes drift depth distribution parameters to be set
      ! in Mfit_init()      
      real                        :: M_X, M_Y, K_S
      real, pointer               :: U_S(:), V_S(:)
      
      real                        :: AMs, PMs, AMds, PMds, AMAX, Ul !, PMd0
      real                        :: KsD, PMIN, PMAX, AMIN

      ! Look-up parameters to determine profile coefficients AM, PM

      real, allocatable           :: DZK_S(:)
      integer                     :: NA = 0, Nq = 0
      real                        :: delAMlu, dqlu
      
      real, allocatable           :: AMdlu(:,:)
      real, allocatable           :: dIPq(:), IPmP(:)
      integer                     :: iIP, iIPmin, iIPmax, iKDmax
      real                        :: KsDmin, KsDmax, dlKSD

      ! Verboseness of test output
      integer                     :: xsmf_verbose
      ! Test output file id.:
      integer                     :: NDSV

      PUBLIC :: CALC_MFIT
!/
      
      CONTAINS

      SUBROUTINE CALC_MFIT ()      
!/
!/                  +-------------------------------------+
!/                  | FCOO Stokes profile parametric fit  |
!/                  |           Carsten Hansen            |
!/                  |                        FORTRAN 90   |
!/                  | Last update :         03-Oct-2019   |
!/                  +-------------------------------------+
!/
!/      
!/    Remarks: This subroutine can be called after CALC_XSTOKES
!/             Call CALC_MFIT only under switch /MFIT
!/
      USE W3GDATMD, ONLY: MAPSF, MAPSTA ! module scope:,NSEAL
!/
      IMPLICIT NONE

!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      INTEGER                 :: ISEA, JSEA, IX, IY

! Initialization
! Generate common look-up table to determine profile coefficients
! AM, PM that reproduce a given normalized profile IP0

      if ( NA .EQ. 0 ) call Mfit_init()
     
      IF ( xsmf_verbose .GT. 0 ) WRITE (NDSV, 912), 'Stokes profile fit ..'
!
! -------------------------------------------------------------------- /
! 1.  Loop over sea points
!     
      DO JSEA=1, NSEAL
!
! -------------------------------------------------------------------- /
! 2.  Proces only for water points
!
!/DIST        ISEA       = IAPROC + (JSEA-1)*NAPROC
!/SHRD        ISEA       = JSEA
        IX     = MAPSF(ISEA,1)
        IY     = MAPSF(ISEA,2)
!
        IF ( MAPSTA(IY,IX) .GT. 0 ) &
          call Stokes_Mfit(JSEA)
          ! If under MPI only UXSP(JSEA,1:5) is communicated to XUXSP for output
          if ( NZO < XSND ) &
               UXSP(JSEA,4+NZO:3+2*NZO) = UXSP(JSEA,4+XSND:3+XSND+NZO)
         END DO
      
  912 FORMAT ('  ',A)

      END SUBROUTINE CALC_MFIT    
      
      
      SUBROUTINE Stokes_Mfit(JSEA)

      IMPLICIT NONE
      INTEGER, INTENT(IN)         :: JSEA
      
! Parametric profile fitting
      integer                     :: ISEA, lenSt, IZ
      real                        :: M2K, UsD, VsD, AM, PM, AMd, PMd
      real                        :: ITSIC
      real                        :: rel_ms, UN, fac

!/ ------------------------------------------------------------------- /

!  Calculate fit to Mattsson-Hansen parametric profile
!--------------------
!
!     Mfit profile fit. Find the surface vectors Up, Ud and
!     the parameters AM, PM, AMd, PMd so that with a minimum e(:),
!     (U_S(i),V_S(i)) = e(i) + Up*exp(-AM*ZK(i)**PM) + Ud*exp(-AMd*ZK(i)**PMd)
!     where
!     ZK(i) = Z(i) * Kz, Kz  = ( TPI / Tz)**2 / GRAV
!     J. Mattsson first suggestion for the parameters:
!     AM=2.5, PM=0.45, Ud=0

      if ( xsmf_verbose > 1 .and. JSEA == 1 ) &
           WRITE (NDSV, *), JSEA, '  Evaluate integral parameters'

      K_S = UXSP(JSEA,1)
      M_X = UXSP(JSEA,2)
      M_Y = UXSP(JSEA,3)
      U_S => UXSP(JSEA,4:3+XSND)
      V_S => UXSP(JSEA,4+XSND:3+XSND*2)
      
      ! Normalizing factor M2K. The drift (U0X,U0Y)/M2K is of order unity:
      ! M2K = sqrt(M_X**2+ M_Y**2) * K_S * 2

      ! CHA 20200911 tests1 + tests8
      ! (Apply a low limiter of 0.01 m/s to M2K)
      ! First, M2K**2 is
      M2K = (M_X**2+ M_Y**2) * (K_S * 2)**2
      fac = sqrt(0.0001/M2K + 1)
      M2K = sqrt(M2K) * fac
      M_X = M_X * fac
      M_Y = M_Y * fac
      
      ! Feed with (max) number of iterations
      ITSIC = 3.
      
      if ( xsmf_verbose > 1 .and. JSEA == 1 ) &
           WRITE (NDSV, *), JSEA, '  Fit the Mfit profile'
      
      call fit_parts(JSEA, AM, PM, AMd, PMd, UsD, VsD, ITSIC)

      if ( AM > AMAX .and. xsmf_verbose > 0 ) &
        WRITE (NDSV, *), JSEA, &
          '  WARNING: AM large in Stokes_Mfit. ', &
          'AM, PM, AMd, UsD, VsD =', AM, PM, AMd, UsD, VsD      

      if ( xsmf_verbose > 1 .and. JSEA == 1 ) &
           WRITE (NDSV, *), JSEA, '  Test data'

      ! CHA 20200907 tests11
      ! (Apply a low limiter of 0.01 m/s to M2K)
      ! First, M2K**2 is
      ! M2K = (M_X**2+ M_Y**2) * (K_S * 2)**2
      ! fac = sqrt(0.0001/M2K + 1)
      ! M2K = sqrt(M2K) * fac
      ! M_X = M_X * fac
      ! M_Y = M_Y * fac
      
      ! CHA 20200907 tests1
      ! Apply a limiter (2Ul) to the normalized dimensionless Stokes drift
      UN = sqrt(U_S(1)**2 + V_S(1)**2)/M2K

      if ( UN > Ul ) then
        fac = UN / ( Ul * ( 1. + tanh(UN/Ul-1.) ) )
        ! fac -> 1 as UN/Ul -> 1
        ! UN/fac -> 2Ul as UN/Ul -> inf
        
        ! If M2K is not small, let fac -> 1 and write a WARNING
        
        if ( xsmf_verbose > 0 .and. M2K > 0.03 ) &
          WRITE (NDSV, *), JSEA, &
            '  WARNING: Stokes drift is strong in Stokes_Mfit. ', &
            'UN, M2K, AM, PM, AMd, UsD, VsD, ITSIC =', &
            UN, M2K, AM, PM, AMd, UsD, VsD, ITSIC
        
        fac = (fac + M2K/0.03)*tanh(0.03/M2K)
        ! This means that UN/fac -> 2Ul as UN/Ul -> inf only for M2K<<0.03
        
        M_X = M_X * fac
        M_Y = M_Y * fac
        M2K = M2K * fac
        
        end if
      
      UXSP(JSEA,2)   = M_X * fac
      UXSP(JSEA,3)   = M_Y * fac

      USERO(JSEA,1)  = UsD / M2K   ! Normalized surface drift of 'deep' part.
      USERO(JSEA,2)  = VsD / M2K   ! Primary part drift is UsP=U_S-UsD.

      USERO(JSEA,3)  = AM          ! Mfit parameter, primary part
      USERO(JSEA,4)  = PM          ! Mfit parameter, primary part

      USERO(JSEA,5)  = AMd        ! Deep part Mfit parameter. PMd is fixed 0.4

      USERO(JSEA,6) = ITSIC       ! Quality integer
      USERO(JSEA,7) = PMd       ! Quality integer
      ! I  : Number of iterations in fit_parts
      ! T  : Number of iterations in AM_Tune
      ! SI : Scatter index % std(|U_S - U_mod| * dz)/|M|
      ! C  : Convergence of iteration
      !
      ! ITSIC = min( ( min(niter,3)*10+min(ntune,9) ) * 1000. &
      !              + min( 990., int(max(1., 100*si))*10. ), 32000. ) &
      !              + min( 9., 10.*cit )
      ! Reconstruction:
      !
      ! ITSI  = int(0.1*ITSIC)
      ! C     = ITSIC - ITSI*10
      ! IT    = int(0.001*ITSIC)
      ! SI    = ITSI - IT*100
      ! I     = int(0.0001*ITSIC)
      ! T     = IT - I*10

      if ( xsmf_verbose > 1  .and. JSEA == NSEAL )  &
         WRITE (NDSV, *), JSEA, '  Mfit done. ITSIC =', ITSIC

      END SUBROUTINE Stokes_Mfit

      
      subroutine Mfit_init()

      IMPLICIT NONE
      integer                     :: iq, Iz, iret, iA, li
      real                        :: qq, PM, AM, IP, IPd, xca_lim, XKZ
      logical                     :: OPENED

      ! real, allocatable           :: IPl(:)
      real                        :: IPm, AMl
      integer                     :: numi, iKD
      
      ! Set verboseness and file id. of output messages
      NDSV = NDST
      if ( XSVB .gt. 0 ) then
        INQUIRE (NDSV,OPENED=OPENED)
        IF ( .NOT. OPENED ) THEN
          XSVB = 0
          if ( IAPROC == NAPOUT) then
            NDSV = NDSO
            XSVB = 1
            end if
          end if
        end if
      xsmf_verbose = XSVB            

!/T      xsmf_verbose = xsmf_verbose+1
      
      ! ST4R:
      AMds = 0.44; PMds = 1.4; ! PMd0 = 0.8
      AMs = 2.5; PMs = 0.57
      
        ! profile AMd, PMd. The values derive from tests with overall best 
        ! fit of two profiles in version 0.40 . Note, we have experienced that
        ! most values of AMd that differ from AMds are actually derived from a
        ! primary fit to a layer separated from the surface by a thin 
        ! inversion layer. The transfer to secondary profile is done in
        ! AJUST_CONST_SFC()
      PMIN = 0.2 ! Overall minimum value of PM in JM_FIT
      PMAX = 2.0 ! Overall maximum value of PMd in JM_FIT
      AMIN = 0.1  ! Overall minimum value of AM, AMd  in JM_FIT      
      AMAX = 7.0  ! Maximum value value of AM
      Ul = 5.5     ! Upper threshold of normalized dimensionless Stokes drift

      ! Generate common look-up table for AM, given integrated momentum
      ! normalized by surface speed

      delAMlu = 0.2
      NA = int((AMAX - AMIN)/delAMlu+1.5)
      
      dqlu = 0.2
      Nq = int((1./PMIN - 1./PMAX)/dqlu+1.5)
      
      KsDmin = 0.1
      KsDmax = 3.0
      iKDmax = 5
      DO iKD = 1,iKDmax
         KsD = KsDmin
         call IP_calc(IPm, AMIN, PMds)
         call IP_calc(IP, AMAX, PMds)
         if (IP**(-PMds)-IPm**(-PMds) > 1.0) exit
         KsDmin=2.*KsDmin
         END DO
      if ( iKD > 1 ) then
         write (ndse,*) 'Config error in w3xsmfmd (probably weak',        &
                        'convergence in GCF()). Set KsDmin to at least', KsDmin
         call extcde(1)
      end if         
      
      dlKSD = log(KsDmax/KsDmin)/(iKDmax-1) ! dlKSD = 0.85
      
      if ( .not. allocated(AMdlu) ) allocate( AMdlu(NA,iKDmax), stat=iret )
      ! if ( .not. allocated(IPl) ) allocate( IPl(NA), stat=iret )
      if ( .not. allocated(IPmP) ) allocate( IPmP(iKDmax), stat=iret )
      if ( .not. allocated(dIPq) ) allocate( dIPq(iKDmax), stat=iret )
      AMdlu=0.

      iIPmin = 1
      iIPmax = NA
      do iKD = 1,iKDmax  
         KsD = KsDmin*exp((iKD-1)*dlKSD)
         numi=0
         li=1
         call IP_calc(IPm, AMIN, PMds)
         call IP_calc(IP, AMAX, PMds)
         IPmP(iKD) = IPm**(-PMds)
         dIPq(iKD) = (IP**(-PMds)-IPmP(iKD))/(NA-1)
         do iA = 0,NA*6
           AM = AMIN+iA*dIPq(iKD)
           call IP_calc(IPd, AM, PMds)
           iIP = int ( (IPd**(-PMds) - IPmP(iKD))/dIPq(iKD) + 1.5)
           if (  iIP .ne. li ) then
              AMdlu(li,iKD) = (AMdlu(li,iKD)+AM)/(numi+1)
              if (iIP > NA ) exit
              li = iIP 
              numi = 1
              AMdlu(iIP,iKD) = AMl
           end if
           ! write (ndsv,*) iA, AM, IPd, iIP
           AMl=AM
           if ( numi == 0 .and. AMdlu(iIP,iKD) > 0. ) cycle
           AMdlu(iIP,iKD) = AMdlu(iIP,iKD) + AM
           numi=numi+1           
           end do
         if ( iIP == li ) then
           write (ndse,*) 'Code error in w3xsmfmd: iA=',iA,6*NA
           call extcde(1)
           end if
         ! Fill zeros
         do iIP = 2,NA-1
           if (AMdlu(iIP,iKD) == 0.) then
             numi=0
             if (AMdlu(iIP+1,iKD) > 0.) then
               AMdlu(iIP,iKD) = AMdlu(iIP+1,iKD)
               numi = 1
               end if
             if (AMdlu(iIP-1,iKD) > 0.) &
               AMdlu(iIP,iKD) = (AMdlu(iIP,iKD) + AMdlu(iIP-1,iKD)) / (numi+1)
             end if
           end do
         if (AMdlu(1,iKD) == 0.) AMdlu(1,iKD) = AMdlu(2,iKD)
         if (AMdlu(NA,iKD) == 0.) AMdlu(NA,iKD) = AMdlu(NA-1,iKD)
         end do

      ! To look-up, given IPd:
      ! real                :: IPm, dIPq, IPmP
      ! integer             :: numi, iKD
      ! iKD = min( max( 1+int(log(KsD/KsDmin)/dlKSD), 1), iKDmax)
      ! iIP = min( max( int ( (IPd**(-PMds) - IPmP(iKD))/dIPq(iKD) + 1.5), &
      !                  iIPmin), iIPmax)
      ! AM = AMdlu(iIP,iKD)
      
      write (ndsv,*) 'AMdlu='
      
      do iA=1,NA
         write (ndsv,*) AMdlu(iA,:)
         end do
      
      ! call extcde(1)
      
      if ( .not. allocated(DZK_S) ) allocate( DZK_S(XSND), stat=iret )

      ! DZK_S = K_S * approximate thicknesses (m) of each layer
      ! In w3xstomd, the dimensionless profile depths have been defined as
      ! ZK_S(IZ)  = XKZ**(IZ-1) - 1., where
      XKZ = (1. + XSDS)**(1./(XSND-1.))       

      ! The uppermost layer at the surface has approximately half thickness.
      DZK_S(1) = (XKZ - 1.) * 0.5
      DZK_S(2:XSND) = (ZK_S(2:XSND) + 1.) * (XKZ - 1./XKZ) * 0.5
      ! DZK_S(IZ) = (XKZ**IZ - XKZ**(IZ-2)) * (XKZ - 1./XKZ) * 0.5
      

      end subroutine Mfit_init

      
      subroutine fit_parts(JSEA, AM, PM, AMd, PMd, UdX, UdY, ITSIC)
        
      implicit none

!     Mattsson-Hansen profile fit. Find the surface vectors Up, Ud and
!     the parameters AM, PM, AMd, PMd so that with a minimum rms |e(:)|,
!     (U_S(i),V_S(i)) = e(i) + Up*exp(-AM*ZK(i)**PM) + Ud*exp(-AMd*ZK(i)**PMd)
!     where
!     ZK(i) = Z(i) * Kz, Kz  = ( TPI / Tz)**2 / GRAV


      integer, intent(in)      :: JSEA
      real, intent(out)        :: AM, PM, AMd, PMd, UdX, UdY
      real, intent(inout)      :: ITSIC
      
      complex                  :: MK, Ud, U0, Up, unit, Ups, tmc
      real                     :: IPp, IPd, tmp, Udl, Upr, Mpr, MKignore, IP2_min
      real, allocatable, save  :: Pd(:), Pp(:), Umr(:), log_KZ(:)
      integer                  :: lenSt, ncycl, iter, numPos, ii, im, nneg,  &
                                  itune, ntune, ISEA, IZ, iKD
      complex                  :: Upi(5),Udi(5)
      real                     :: IPpi(5),AMi(5),PMi(5), AMdi(5),IPdi(5)
      real                     :: qci(5), msi(5)
      logical                  :: wi(5), warning_issued
      real                     :: fi, fiU, Umr_min, Umd_min, dIP, dIP_min, amfc
      real                     :: si, cit, sm, qcr, qcd
      real                     :: IPm, IP
      integer                  :: NA, niter
      
      ntune = 0

      niter = min(int( ITSIC ),4)
      
      ! Criteria, hardcoded for iterative convergence
      ! Upcrit = 0.1*abs(U0) + 0.03 ! > 3 cm/s
      ! IPcrit = 0.05 * IPp
      ! PMcrit = 0.1 * PMs
      ! AMcrit = 0.05 * AMs

      niter = min( max(niter,2), 4 )
      

      dIP_min = 0.1
      ! IPdlim = 0.5

      ! When to skip fitting AM, PM more precisely
      MKignore = 0.1 ! 10 cm/s TODO: MKignore might follow the prognostic fcut

!/      Initially, assume standard parameters of the profiles
      AMd = AMds; PMd = PMds; AM = AMs; PM = PMs
      
      ! Convert input vectors to complex numbers, and normalize M
      MK = cmplx( M_X, M_Y ) * K_S
      U0 = cmplx( U_S(1), V_S(1) )

!/DIST      ISEA       = IAPROC + (JSEA-1)*NAPROC
!/SHRD      ISEA       = JSEA
      KsD  = K_S * MAX ( DMIN, DW(ISEA) )

      ! lenSt: Number of depths of the discrete profile above the sea bed
      lenSt = XSND ! Configured value if all above the sea bed     
      do IZ = XSND,1,-1
        if ( ZK_S(IZ) > KsD ) cycle
        lenSt = IZ
        exit
        end do

!/    Factorize the normalized M*K in an 'primary part' and a 'deep part' as
!/    MK = Ud * IPd + Up * IPp, where
!/    U0 = Ud + Up, and where IPd, IPp are normalized profile shapes
      ! TODO: Consider a look-up table and function calls IPd=IPds(KsD)
      !       and IPp=IPps(KsD)
      call IP_calc(IPd, AMd, PMd)
      call IP_calc(IPp, AM, PM)

      ! Set a low limiter to IPd:
      IP2_min = 2.*abs(MK)/(abs(U0)+0.00001) - IPp
      if ( IPd <  IP2_min ) then      
        ! To look-up, given IPd:
        IPd = IP2_min
        iKD =  min( max( 1+int(log(KsD/KsDmin)/dlKSD), 1), iKDmax)
        ! KsDmin = 0.03;dlKSD = 0.3;KsDmax=5.0
        ! iKDmax = 1.+int(log(KsDmax/KsDmin)/dlKSD)
        ! At iKD we would have KsD = KsDmin*exp((iKD-1)*dlKSD)
        iIP = min( max( int ( (IPd**(-PMds) - IPmP(iKD))/dIPq(iKD) + 1.5), &
                        iIPmin), iIPmax)
        AMd = AMdlu(iIP,iKD)
        ! At the actual KsD,
        call IP_calc(IPd, AMd, PMd)          
        end if
      
      ! Avoid uncertainty due to division by a near-zero-value
      if ( abs(U0) < 0.001 .and. abs(MK) >= 0.005 ) U0 = -0.001/abs(MK) * MK
      
!/    Substitution yields a vector expression in one unknown part Up,
!/    MK = (U0-Up)* IPd + Up * IPp,  or
      Up = ( U0 * IPd - MK ) / (IPd - IPp)
!/      The 'deep part' of the surface drift is the remainder
      Ud = U0 - Up

      ! Handling of small drift
      if ( abs(U0) < 0.005 .and. abs(MK) < 0.005 ) then
        ! Neglect the details when very weak Stokes drift
        ITSIC = 9999.
        return
        end if
      
      if ( .not. allocated(Umr) )  allocate( Umr(XSND), stat=ii )
      if ( .not. allocated(Pd) )   allocate( Pd(XSND), stat=ii )
      if ( .not. allocated(Pp) )   allocate( Pp(XSND), stat=ii )
      if ( .not. allocated(log_KZ) ) then
         allocate( log_KZ(XSND), stat=ii )
         log_KZ(2:XSND) = log(ZK_S(2:XSND))
         ! Dummy value at surface
         log_KZ(1) = 0.
      end if
      
      ! Smallest drift values allowed in the improved estimates
      ! of (AM, PM, AMd) in the iteration steps below

      Umr_min = abs(Up) * exp( - AMs * ZK_S(lenSt)**(PMs*2) )
      Umd_min = abs(Ud) * exp( - AMd * ZK_S(lenSt)**(PMds*2) )

      iter = 1
      
!  Register the primary profile parameters
      
      AMi(iter) = AM
      PMi(iter)  = PM
      AMdi(iter) = AMd
      Upi(iter)  = Up
      Udi(iter)  = Ud
      IPpi(iter) = IPp
      IPdi(iter) = IPd
      qci(iter) = 0.
      wi(iter) = .false.

      ! Parametric profiles
      Pp = exp ( - AM * ZK_S ** PM )
      Pd = exp ( - AMd * ZK_S ** PMd )

      ! Mean square deviation from predicted profile
      msi(iter) = calc_msd( Up, Ud, Pp, Pd, lenSt)
        
!/ Iterations 2 to niter:
   ! niter+1 is an extra cycle to take if Ud==0
      amfc = 2.0
      do iter=2,niter+1

        warning_issued = .false.

!/
!/  step 1: Apply the model profile Um(z ) to yield improved estimates
!/          of (AM, PM) determined as the best fit to the residual
!/          Umr(z) =  proj(Um(z)) - proj(Ud)*Pd(z),
!/          where proj is the projection on the direction of Up given from
!/          the previous iteration, and Pd(z) = exp ( - AMd * zK ** PMd ) is
!/          given from the parametric deep parameters of the previous iteration.
!/          Note that Pd(z=0) = 1 and Umr(z=0) = Up

        ! Limiter to Ud
        ! TODO: test if this could be applied to every Ud, even the resulting
        if ( 2.*abs(Ud) > abs(Up) ) then !.and. ( iter < niter .or. abs(U0) < 0.03 )
           unit = U0/abs(U0)
           tmp = real(Ud) * real(unit) + aimag(Ud) * aimag(unit)
           !
           if ( tmp < 0. ) then
              ! Shift Ud in the direction of U0 so that it's projection
              ! on U0 becomes 0.0
              Ud = Ud - (tmp/abs(U0))*U0
              Up = U0 - Ud
           else if ( abs(Ud) > abs(Up) ) then
              ! Shift Ud in the direction of -U0 so that it's projection
              ! on U0 becomes 0.5*U0
              Ud = Ud - (tmp/abs(U0) - 0.5)*U0
              ! Alternatively reduce |Ud| to 0.5*|U0| and add the reduction to Up
              ! Ud = Ud * 0.5*abs(U0)/abs(Ud)
              Up = U0 - Ud
              ! In debug phase, assert that |Up| == |Ud|
              if ( abs( abs(Up) - abs(Ud) ) > 0.0001 ) then
                write (ndsv,*) 'Debug error, ||Up|-|Ud||>eps, Up,Ud=', Up,Ud
                call extcde(1)
                end if
           end if
        end if
        ! Projection Ud * unit of vector Ud on direction of Up
        unit = Up/abs(Up)
        tmp = real(Ud) * real(unit) + aimag(Ud) * aimag(unit)
        
        Umr = U_S * real(unit) + V_S * aimag(unit) - tmp * Pd

!/      Determine the upper range of depths where Umr has positive values.
!/      There must be no more than 0.2 * lenSt negative or near zero values counted from above
        nneg = int(0.2 * lenSt)
        do ii = 1,lenSt
          if  (Umr(ii) < Umr_min ) then
            nneg = nneg - 1
            if ( nneg == 0 ) then
              exit
              end if
            else
            numPos = ii
            end if
          end do
        if ( numPos < lenSt .and. xsmf_verbose > 2 ) &
             write (NDSV,*) 'ISEA=', ISEA, '  numPos =', numPos

        if ( xsmf_verbose > 0 .and. numPos < max(3,int(0.1 * lenSt)+1) &
             .and. abs(U0) > 0.1) &
            write (NDSV,*) ' ISEA=', ISEA, '  numPos=',numPos, &
                ' < max 3,', int(0.1 * lenSt)+1, ' iter:',iter-1
                
        if (numPos < 4 ) THEN
          if (numPos > 1 ) THEN
            PM=PMs
            qcr = Umr_min
            call JM_FIT(numPos,log_KZ,Umr,AM,PM,qcr,PM)
            qcr = ( qcr + (lenSt - numPos) ) / lenSt
          else
            ! Keep AM,PM (?)
            ! AM=AMs;PM=PMs
            ! AM=0.5*AMAX
            end if
        else 
!/      Determine AM, PM as the best fit of the profile, given the surface
!/      drift Up. Although Umr(1) is always positive, any of Umr(2:numPos)
!/      might be negative. JM_FIT will first exchange negative or
!/      near zero values with the previous (input) profile. The number of these
!/      is returned in the argument qcr. The input value of qcr is the minimum
!/      threshold value
          qcr = Umr_min
          call JM_FIT(numPos,log_KZ,Umr,AM,PM,qcr)

          ! Limiters to PM
          if (2.*PM > PMAX+PMs .or. 2.*PM < PMs+PMIN ) then
            if (2.*PM > PMAX+PMs) then
               tmp = PMAX-PMs
               PM = PMAX - tmp/(2.*(PM-PMs)/tmp + 1.)
               ! Consider set a low limiter to IPp like for IPd below?
            else
               tmp = PMs-PMIN
               PM = PMIN + tmp/(2.*(PMs-PM)/tmp + 1.)
            end if
            tmp = Umr_min
            ! Best fit value of AM given the new PM
            call JM_FIT(numPos,log_KZ,Umr,AM,PM,tmp,PM)
            if (PM > 2.*PMs .or. 3.*PM < PMs ) warning_issued = .true.
          end if

          ! Fraction of depths that do not go into the fitting:
          qcr = ( qcr + (lenSt - numPos) ) / lenSt          
          end if

        ! Limiters to AM
        !if ( iter >= niter)
        amfc=1.0
        if ( AM < AMIN .or. 2. * AM > AMAX+AMs ) then
          if ( AM < AMIN ) then ! .and. ncycl < niter-1 ) then
            AM = AMIN
          else
            tmp = AMAX-AMs
            AM = AMAX - tmp/(2.*(AM-AMs)/tmp + 1.)
            ! Consider set a low limiter to IPp like for IPd below?
            end if
          tmp = Umr_min
          ! Best fit value of PM given the new AM
          call JM_FIT(numPos,log_KZ,Umr,AM,PM,tmp,PM,AM)
          end if
        
!/  step 2: Update the profile parts, given the old IPd and new IPp

        if (xsmf_verbose > 2 ) &
                write (NDSV,*) ' ISEA=', ISEA, '  IP_calc( ', AM, PM,')'
        call IP_calc( IPp, AM, PM)

        dIP = IPd/IPp - 1. 
!       Update the deep- and primary-profile parts of the surface drift
        if ( abs(dIP) > dIP_min ) then
           ! MK = (U0-Ud)* IPp + Ud * IPd,  or
           ! Ud = ( MK - U0 * IPp ) / (IPd - IPp)
           Ud = ( MK/IPp - U0 ) / dIP
           Up = U0 - Ud
          else
            ! Then either MK = (U0-Ud)* IPp + Ud * IPd = U0*IPp + eps
            !      or     MK = Ud * IPd + eps
            ! We choose MK = U0*IPp + eps and approximate eps=0.
            Up = U0
            Ud = 0.

            ! No further updates obtainable.
            ! Might fine-tune AM, PM ?

            !  if ( xsmf_verbose > 1 ) write (NDSV,*), &
            !   '   No correction to Up, Ud as IPp, IPd  =', IPp, IPd 
          end if

        ! Limiter to Ud
        ! TODO: test if this could be applied to every Ud, even the resulting
        if ( 2.*abs(Ud) > abs(Up) ) then !.and. ( iter < niter .or. abs(U0) < 0.03 )
           unit = U0/abs(U0)
           tmp = real(Ud) * real(unit) + aimag(Ud) * aimag(unit)
           !
           if ( tmp < 0. ) then
              ! Shift Ud in the direction of U0 so that it's projection
              ! on U0 becomes 0.0
              Ud = Ud - (tmp/abs(U0))*U0
              Up = U0 - Ud
           else if ( abs(Ud) > abs(Up) ) then
              ! Shift Ud in the direction of -U0 so that it's projection
              ! on U0 becomes 0.5*U0
              Ud = Ud - (tmp/abs(U0) - 0.5)*U0
              ! Alternatively reduce |Ud| to 0.5*|U0| and add the reduction to Up
              ! Ud = Ud * 0.5*abs(U0)/abs(Ud)
              Up = U0 - Ud
              ! In debug phase, assert that |Up| == |Ud|
              if ( abs( abs(Up) - abs(Ud) ) > 0.0001 ) then
                write (ndsv,*) 'Debug error, ||Up|-|Ud||>eps, Up,Ud=', Up,Ud
                call extcde(1)
                end if
           end if
        end if        

        if ( iter < niter .and. abs(Ud) > 0. ) then
        ! ( if ( iter==niter .and. abs(Ud)==0 ) extra cycle to estimate  AM, PM
            
!/  step 3: Determine AMd as the best fit of the secondary, 'deep',
!/          profile given the surface drift partition Ud

        if (xsmf_verbose > 2 ) write (NDSV,*), '  Fit AMd'

        ! Find  Umr(z)= proj_d(Um) - proj_d(Up)*Pp
        ! projected on the direction of Ud
        
        Udl = abs(Ud)
        unit = Ud /  Udl
        tmp = real(Up) * real(unit) + aimag(Up) * aimag(unit)
        
        Pp = exp ( - AM * ZK_S ** PM )
        
        Umr = U_S * real(unit) + V_S * aimag(unit) - tmp * Pp
        qcd = Umd_min        
        call JM_FIT(lenSt,log_KZ,Umr,AMd,PMd,qcd,PMds)
        !call JM_FIT(lenSt,log_KZ,Umr,AMd,PMd,qcd)
        
        ! Limiters
        if ( .not. ( AMd > 0.5 * AMIN)  ) then !.and. ncycl < niter-1 ) then
           AMd = 0.5 * AMIN
           warning_issued = .true.
          end if
        ! Consider: Could we set a high limiter to IPd? - like the low limiter
          
        ! Reduce if sharp deep part profile
        ! ( The low limiter to IPd below does this)
        !  if ( .not. ( AMd < AMAX) ) then
        !   AMd = AMAX
        !   warning_issued = .true.
        !   end if

        call IP_calc( IPd, AMd, PMd)
        
        ! Set a low limiter to IPd:
        IP2_min = 2.*abs(MK)/abs(U0) - IPp
        if ( IPd < IP2_min ) then
        
          IPd = IP2_min
          
          ! Look-up AMd, given IPd:
          iKD = min( max( 1+int(log(KsD/KsDmin)/dlKSD), 1), iKDmax)
          iIP = min( max( int ( (IPd**(-PMds) - IPmP(iKD))/dIPq(iKD) + 1.5), &
                        iIPmin), iIPmax)
          AMd = AMdlu(iIP,iKD)
          call IP_calc( IPd, AMd, PMd)
          ! if ( IP2_min ) IPd = IP2_min
          end if
          
!/  step 4: Update the profile partitions based on the old IPp and a new IPd
        if (xsmf_verbose > 2 ) write (NDSV,*), '  IP_calc(KsD', AMd, PMd,')'
        
!       Update the primary- and deep-profile parts of the surface drift
        dIP = 1. - IPp/IPd
        if ( abs(dIP) > dIP_min ) then
           ! MK = (U0-Ud)* IPp + Ud * IPd,  or
           ! Up = ( U0 * IPd - MK ) / (IPd - IPp)
           Up = ( U0 - MK/IPd ) / dIP
           Ud = U0 - Up
        else
           Up = U0
           Ud = 0.
        end if
        
        end if !( iter < niter .and. abs(Ud) > 0. )
        
        ! ( if ( iter==niter .and. abs(Ud)==0 ): extra cycle to estimate  AM, PM
        
        if ( ( iter == niter .and. abs(Ud)>0 ) .or. iter == niter+1 ) then
          ! Look-up AMd, given IPd:
          iKD = min( max( 1+int(log(KsD/KsDmin)/dlKSD), 1), iKDmax)
          iIP = min( max( int ( (IPd**(-PMds) - IPmP(iKD))/dIPq(iKD) + 1.5), &
                        iIPmin), iIPmax )
          AMd = AMdlu(iIP,iKD)
        end if

        if ( abs(Ud) > 0. ) Pd = exp ( - AMd * ZK_S ** PMd )
        
        msi(iter) = calc_msd( Up, Ud, Pp, Pd, lenSt)
                   
!  Register the primary profile parameters
        AMi(iter) = AM
        PMi(iter)  = PM
        AMdi(iter) = AMd
        Upi(iter)  = Up
        Udi(iter)  = Ud
        IPpi(iter) = IPp
        IPdi(iter) = IPd
        qci(iter) = qcr
        wi(niter) = warning_issued
        ! We could test convergence. In that case, exit the loop
        ! if ( msi(iter) < msi_crit       .or.     &
        !     ( abs(Up - Upi(iter-1))/abs(U0) < Upcrit &
        !       .and. abs(AM - AMi(iter-1))   < AMcrit &
        !       .and. abs(AMd - AMdi(iter-1)) < AMcrit &
        !       .and. abs(PM - PMi(iter-1))   < PMcrit &
        !     ) ) exit
       
        ! if ( abs(Ud) == 0. .and. AM > AMIN ) exit

        if ( abs(Ud) == 0. ) cycle ! extra cycle if iter==niter
        if ( iter >= niter ) exit
        
!     Repeat steps 1-4 with the new values of AM, PM, AMd

        end do ! iter = 2,niter+1


        if ( iter < niter ) then
          niter=iter
          ! Look-up AMd, given IPd:
          iKD = min( max( 1+int(log(KsD/KsDmin)/dlKSD), 1), iKDmax)
          iIP = min( max( int ( (IPd**(-PMds) - IPmP(iKD))/dIPq(iKD) + 1.5), &
                        iIPmin), iIPmax)
          AMd = AMdlu(iIP,iKD)
          end if
      
      im = niter
      sm = msi(im)      
      do ii=2,niter-1
         if ( msi(ii) > sm ) cycle
         im = ii
         sm = msi(ii)
         end do

      ! if ( msi(1) < 0.9*sm ) then
      if ( msi(1) < sm - 0.01 ) then
        ! if (xsmf_verbose > 0 .and. msi(1) < (0.5+0.1*xsmf_verbose)*sm ) then
          write (NDSV,*) '  WARNING in w3xsmfmd, ISEA=', ISEA, &
                ': msi(',im,')/msi(1)=',sm,'/',msi(1), ', abs(U0) =',abs(U0)
        !   write (NDSV,*), JSEA, '  WARNING: msi(1)/msi(2,3,4)=',&
        !        msi(1)/msi(2), msi(1)/msi(3), msi(1)/msi(4)
        !  end if
        im = 1
        end if
      
      if ( im < niter .and. msi(im) < 0.9*msi(niter) ) then
        niter = im
        end if
!     Test use of first iteration step only
      !niter = 1
        
      AM  = AMi(niter)
      PM  = PMi(niter)
      AMd = AMdi(niter)
      Up  = Upi(niter)
      Ud  = Udi(niter)
      qcr = qci(niter)
      warning_issued = wi(niter)
      
      ! Reduce if sharp deep part profile
      if ( AMd >= AMAX ) warning_issued = .true.
          
      UdX = real(Ud)
      UdY = aimag(Ud)

      ! Convergence of iteration:
      cit = abs ( 1. - ( Up * IPpi(niter) + Ud * IPdi(niter) ) / abs ( MK) )
      
      ! Scatter index of the fit; si = mean(|(U_S - U_mod)^2|)/|2MK|
      si = sqrt( msi(niter) ) / abs(MK) * 0.5

      niter = max(niter - 2,1)* 10 + min(ntune,9)
      si = min(si, 0.49)
      if ( qcr > 0.5 ) si = si + 0.5
      ! 'IT': I=int(0.1*niter); T=niter-I*10; I=I-5
      ITSIC = niter * 1000. &
                   + min(990., int(max(0., 100*si))*10.) &
                   + min(9., 10.*cit)

      if ( xsmf_verbose == 0 .and. .not. warning_issued ) return

      ! Ignore deviations warnings in calm sea
      if ( abs(U0) + abs(MK) < 0.03 ) return
      !if ( abs(MK) < 0.005 .and. abs(U0) < 0.005 ) then
      
      if ( .not. ( AM > AMIN .and. 3.*PM >= PMs .and. AMd > 0.5*AMIN) ) then
        write (NDSV,*) '  WARNING in w3xsmfmd, ISEA=', ISEA, &
                ': very small AM, PM, or AMd'
        write (NDSV,*), 'AM, PM, AMd = ', AM,  PM, AMd
        warning_issued = .true.
        end if

      if ( .not. ( AM < AMAX .and. AMd < AMAX .and. PM <= 3.*PMs ) ) then
        write (NDSV,*) '  WARNING in w3xsmfmd, ISEA=', ISEA, &
                ' : very large AM, PM, or AMd'
        write (NDSV,*), 'AM, PM, AMd = ', AM,  PM, AMd
        warning_issued = .true.
        end if

      if ( .not. abs(Ud) < abs(U0) + abs(MK) ) then
        write (NDSV,*), JSEA, &
         '  WARNING in w3xsmfmd, ISEA=', ISEA, &
                ' : Strong secondary Stokes drift'
        write (NDSV,*), &
         '  abs(Ud) > max(2.*abs(U0),0.1), Ud = ', abs(Ud), ', U0 = ', abs(U0)
        warning_issued = .true.
        end if

      if ( xsmf_verbose > 1 .or. warning_issued ) then
!/DIST        ISEA       = IAPROC + (JSEA-1)*NAPROC
!/SHRD        ISEA       = JSEA
        write (NDSV,*), &
              ' ISEA=', ISEA, &
                ' KsD, niter, |U0|, |Ud|, IPd, IPp', \
          KsD, niter, abs(U0), abs(Ud), IPd, IPp
        end if
      ! Print log of the iterative convergence

      if ( xsmf_verbose > 2 &
           .or. ( xsmf_verbose  > 1 .and. warning_issued ) ) then
        write (NDSV,*), '  U0,     Ud,     AM,  PM,  IPp,  AMd,  IPd, si = '
        write (NDSV,*), U0, Ud, AM, PM, IPp, AMd, IPd, si

        write (NDSV,*), '  ntune = ', ntune
        write (NDSV,*), '    MK =  ', MK
        write (NDSV,*), '    Upi = ', Upi(1:niter)
        write (NDSV,*), '   IPpi = ', IPpi(1:niter)
        write (NDSV,*), '    AMi = ', AMi(1:niter)
        write (NDSV,*), '    PMi = ', PMi(1:niter)
        write (NDSV,*), '   AMdi = ', AMdi(1:niter)
        write (NDSV,*), '    si = ', sqrt( msi(1:niter) ) / abs(MK) * 0.5
        end if

      end subroutine fit_parts


      real function calc_msd( Up, Ud, Pp, Pd,  lenSt)

      ! Mean of squares of modulus deviation between a profile U_S, V_S
      ! and a parametric fit Up * Pp + Ud * Pd
      implicit none
      complex, intent(in)               :: Up, Ud
      real, dimension(:), intent(in)    :: Pp, Pd
      integer, intent(in)               :: lenSt
      real, allocatable, save           :: Um(:)
      real                              :: tmp
      integer                           :: ii
      
      if ( .not. allocated(Um) )  allocate( Um(XSND), stat=ii )

      
 
      Um(2:lenSt) = ( U_S(2:lenSt) - real(Up) * Pp(2:lenSt)     &
                       - real(Ud) * Pd(2:lenSt) )
      tmp = sum( Um(2:lenSt) * Um(2:lenSt) * DZK_S(2:lenSt) )
      Um(2:lenSt) = ( V_S(2:lenSt) - aimag(Up) * Pp(2:lenSt)    &
                       - aimag(Ud) * Pd(2:lenSt) )     
      
      calc_msd = ( tmp + sum( Um(2:lenSt) * Um(2:lenSt) * DZK_S(2:lenSt) ) ) &
                 / ZK_S(lenSt)
      
      end function calc_msd
      
        
      subroutine swap_r(xr,yr)
      implicit none
      real, intent(inout)         :: xr, yr
      real                        :: tmp

      tmp = xr; xr = yr; yr = tmp

      end subroutine swap_r
      
      subroutine swap_c(xc,yc)
      implicit none
      complex, intent(inout)      :: xc, yc
      complex                     :: tmp

      tmp = xc; xc = yc; yc = tmp

      end subroutine swap_c


      subroutine JM_FIT(numD,log_KZ,Um,AM,PM,Um_min,P0,A0)

      !  Determine AM, PM as a best fit of the profile Um. At the surface
      !  the best fit must equal Um(1)
      implicit none

      integer, intent(in)         :: numD
      real, intent(in)            :: log_KZ(:)
      real, intent(in)            :: Um(:)
      real, intent(inout)         :: AM, PM, Um_min
      real, intent(in), optional  :: P0
      real, intent(in), optional  :: A0

      real, allocatable, save     :: loglog_ref(:), log_Um(:)
      integer, allocatable, save  :: fqc(:)
      real                        :: log_Up, log_AM, log_Um_min, logAM0
      integer                     :: ii

      if ( .not. allocated(loglog_ref) ) allocate( loglog_ref(XSND), stat=ii )
      if ( .not. allocated(log_Um) )     allocate( log_Um(XSND), stat=ii )      
      if ( .not. allocated(fqc) )     allocate( fqc(XSND), stat=ii )

      ! Quality counter = 1 for the depths that are ignored in the fit
      fqc = 0
      
      ! Profile model:
      ! Um = Um(1) * exp (-AM * KZ**PM)

      ! Regression shape valid for KZ > 0:
      ! log_Um = -log( Um/Um(1) ) ~ AM * KZ**PM

      ! Reference shape:
      ! log_ref(2:numD) = AM * KZ(2:numD)**PM
      ! The log of log_Um is linear in log_KZ:
      logAM0 = log(AM)
      loglog_ref(2:XSND) = logAM0 + PM * log_KZ(2:XSND)
      
      log_Um_min = log(Um_min)

      where ( Um > Um_min )
        log_Um = -log( Um/Um(1) )
      elsewhere
        ! Avoid depths of near negative speed:      
        log_Um = log_Um_min
        ! Register the depths that are ignored
        fqc = 1
        end where
      
      ! Set dummy values at the surface and below the sea floor (numD+1:XSND)
      ! (not to be used in lin_reg)
      loglog_ref(1) = loglog_ref(2) - 1.
      log_Um(1) = exp(loglog_ref(1))
      log_Um(numD+1:XSND) = exp(loglog_ref(numD))
      
      ! First, avoid the smallest (possibly negative) values of log_Um: 
      where ( log_Um < log_Um(1) )
        log_Um = log_Um(1)
        fqc = 1
        end where

      ! Take the logarithm again to fit a linear profile
      log_Um(2:numD) = log( log_Um(2:numD) )
      ! Dummy values at the surface and below the sea floor
      log_Um(1) = loglog_ref(1)
      log_Um(numD+1:XSND) = loglog_ref(numD+1:XSND)
      
      ! Avoid depths where Um is not decreasing like 'in the vicinity of'
      ! the reference shape Um(1) * exp(-AM * KZ**PM)

      where ( log_Um < loglog_ref - 1. )
        log_Um = loglog_ref - 1.
        fqc = 1
        end where      
      ! where ( log_Um < 1/e*log_ref )
        
      where ( log_Um > loglog_ref + 1. )
        log_Um = loglog_ref + 1.
        fqc = 1
        end where
      ! where ( log_Um > e*log_ref )
        
      ! Linear regression fit
      if (xsmf_verbose > 2 ) write (NDSV,*), '  lin_reg () ... '
      if ( present(A0) ) then
         ! Best fit of PM, only, given AM=A0
         AM = A0
         log_AM=log(A0)
         call lin_reg1( log_Um(2:numD), log_KZ(2:numD), PM, log_AM)
      else if ( present(P0) ) then
         ! Best fit of log_AM, only, given PM=P0
         PM = P0
         call lin_reg0( log_Um(2:numD), log_KZ(2:numD), P0, log_AM)
      else
         ! New linear regression best fit PM, log_AM
         call lin_reg( log_Um(2:numD), log_KZ(2:numD), PM, log_AM)
       end if

      ! Number of depths that do not go into the fitting. Returned in Um_min
      Um_min = real(sum(fqc(2:numD)))
      
      if ( .not. present(A0) ) AM = exp(log_AM)

      end subroutine JM_FIT


      subroutine lin_reg0( yy, xx, a0, bb)
      ! Find the y-intercept (bb) of
      ! yf = a0 * xx + bb, where ||yy - yf|| is a minimum
      IMPLICIT NONE
      real, intent(in)            :: yy(:), xx(:)
      real, intent(in)            :: a0
      real, intent(out)           :: bb
     
      integer :: lenArr

      lenArr =  float(size(yy))

      bb = sum(yy) / lenArr - a0 * ( sum(xx) / lenArr )

      end subroutine lin_reg0


      subroutine lin_reg1( yy, xx, aa, b0)
      ! Find the slope (aa) of
      ! yf = aa * xx + b0, where ||yy - yf|| is a minimum
      IMPLICIT NONE
      real, intent(in)            :: yy(:), xx(:)
      real, intent(out)           :: aa
      real, intent(in)            :: b0
     
      integer :: lenArr

      lenArr =  float(size(yy))

      aa = ( sum(yy) - b0 * lenArr ) / sum(xx)

      end subroutine lin_reg1


      subroutine lin_reg( yy, xx, aa, bb )
      ! Find the slope (aa) and y-intercept (bb) of
      ! yf = aa * xx + bb, where ||yy - yf|| is a minimum

      IMPLICIT NONE
      real, intent(in)            :: yy(:), xx(:)
      real, intent(out)           :: aa, bb
      real :: sumx, sumy, xave, yave, ad, ax, amx, amn

      integer :: KD_num, ii, lenArr
      
      amx = PMAX
      amn = PMIN
      
      lenArr =  float(size(yy))

      sumx = sum(xx)
      sumy = sum(yy)
      xave = sumx / lenArr
      yave = sumy / lenArr

      ! Find the slope (aa)
      aa = (dot_product(xx,yy) - sumx*yave)
      ad = (dot_product(xx,xx) - sumx*xave)
      ax = amx * ad
      if ( ax > aa .and. amn * ad < aa ) then
        ! aa is between min and max
        aa = aa / ad
      else if ( ax > aa ) then
        aa = amn 
      else
        aa = amx
        end if
      
      ! y-intercept (bb)
      bb = yave - aa*xave

      end subroutine lin_reg      

      subroutine IP_calc( IP, AM, PM )
        !
        ! The integrated, normalized pseudo-momentum of the parameterized
        ! profile has the mathematical form, in the limit of infinitesimal depth
        ! increments,
        !   IP = \int_0^KsD exp(- AM * KZ^PM ) dKZ,
        ! where D is the local depth and Ks=KsD/D is an integral wave number.
        !
        ! This can be reformulated, substituting X = AM * KZ^PM,
        !   IP = q AM^{-q} \int_0^u X^{q-1} exp(-X) dX,
        ! where q = 1/PM and u = AM * KsD^PM
        ! The integral is an incomplete gamma function gammainc(q,u), and thus
        !   IP = AM^{-q} q gammainc(q,u)
        !
        IMPLICIT NONE
        REAL, intent(out)           :: IP
        REAL, intent(in)            :: AM, PM
        real                        :: q, u

        q = 1./PM
        u = AM * KsD**PM

        IP = q / AM**q * gammain(q,u)

      end subroutine IP_calc

! Function version:
!     function IP_calc( KsD, AM, PM )
!        
        ! The integrated, normalized pseudo-momentum of the parameterized
        ! profile has the mathematical form, in the limit of infinitesimal depth
        ! increments,
        !   IP = 1/KsD \int_0^KsD exp(- AM * KZ^PM ) dKZ,
        ! where D is the local depth and Ks = KsD/D is an integral wave number.
        !
        ! This can be reformulated, substituting X = AM * KZ^PM,
        !   IP = 1/KsD q AM^{-q} \int_0^u X^{q-1} exp(-X) dX,
        ! where q = 1/PM and u = AM * KsD^PM
        ! The integral is an incomplete gamma function gammainc(q,u), and thus
        !   IP = 1/KsD AM^{-q} q gammainc(q,u)
        !
        
!        IMPLICIT NONE
!        REAL                     :: IP_calc
!        REAL, intent(in)         :: KsD, AM, PM      
!        real                     :: q, u
!
!        q = 1./PM
!        u = AM * (KsD)**PM      
!
!        IP_calc = q / AM**q * gammain(q,u)

!      end function IP_calc      
           
      real function gammain( q, u )

        ! The incomplete gamma function P(q,u) multiplied by Gamma(q).
        !
        ! Weighted average of four approximate functions depending on the water
        ! depth, or more precisely, depending on the value of xc = u / (q + 1.)
        !
        ! Let xcm < xci < xct < xcd < xca with xcm >~ 0.4, xct ~ 4*xcm:
        !
        ! 1) 0.0 <= xc < xci : use a series representation, function gi()
        !                        (shallow and transitional water waves)
        ! 2) xcm <= xc < xcd   : Continued fraction factor, function GammaincG()
        !                        (transitional and deep water waves)
        ! 3) xct <= xc < xca   : Gamma(q) - u**(q-1) * exp(-u)
        !                        (deep water)
        ! 4) xca <= xc         : Gamma(q)
        !                        (most of the deep ocean)
        
        IMPLICIT NONE
        real, intent(in)             :: q, u
        real                         :: numit=0.
        real                         :: xc, xce, xcm, xca, xcd
        real                         :: GmA, gammainG, wP
        ! Number of powers in series, function gi():
        integer                      :: nmP

        xc = u/(q + 1.)

        ! Shallow and transitional water thresholds
        !
        ! A requirement in Numerical Recipes function gcf(a,x) is that
        ! xc > (q-1)/(q+1). Similarly we apply an asymptotic formula
        ! gammainc -> Gamma(q) - u**(q-1) * exp(-u) for xc > xcm =
        ! max(0.4, (q-0.8)/(q+1))+0.4
        ! We apply a power series gi(u) when xc <= xcd = 2.0 + xce, where        
        xce = max ( 0., (q - 0.8)/(q + 1.) - 0.4 )
        ! The two formulas are linearly ramped in the interval xcm < xc <= xcd
        
        ! Shallow water threshold
        xcm = 0.8 + xce

        if ( xc >= xcm ) then
           ! (transitional shallow and deep water waves)
           GmA = exp( GAMMLN(q) )
        end if
        
        ! very deep water threshold
        xca = 3.0 + xce
        
        if ( xc >= xca ) then
           ! asymptotic value for xc -> infinity (very deep water)
           gammain = GmA
           ! For very deep water waves we are finished
           return
        end if
        
        ! Intermediate water
        if ( xc > xcm ) then
           gammain = GmA - u**(q-1) * exp(-u) * (xca-xc)/(xca-xcm)
           ! W = (xca-xc)/(xca-xcm); W->0 as xc -> xca; W -> 1 as xc -> xcm

           ! Intermediate to deep water threshold
           xcd = 2.0 + xce
        
           ! For moderate deep water waves we are finished
           if ( xc > xcd ) return
        end if

        ! Shallow and intermediate water
        ! Power series in u, truncated after maximally nmP terms
        nmP = int(10. * (xc + 1.)*(u/100.**(1./q)+2.)) ! Suits u in [0.1;100]
        gammainG = giGR(q, u, nmP)
        
        if ( xc > xcm ) then
           ! (transitional from shallow to deep water waves)
           wP = (xcd-xc)/(xcd-xcm)
           ! wP -> 0 as xc -> xcd; wP -> 1 as xc -> xcm
           gammain = gammainG * wP + gammain * (1. - wP)
        else
           ! xc <= xcm: Asymptotic as xc -> 0
           ! (shallow water waves)
           gammain = gammainG
        end if

      end function gammain
      
      real FUNCTION giGR(q,u,nm)
        !
        ! The incomplete gamma function, power series representation for small
        ! values of u / (q + 1.), to power nm
        !
        ! G&R: Gradshteyn and Ryzhik: Table of integrals, series and products,
        ! Academic Press 1980
        !
        ! Apply G&R 8.354.1, with al=q-1, x=u:
        !           gi(al,x) = sum_{n=0}^nm (-1)**n * frac{x^(al+n)}{n!*(al+n)}
        !                    = x^al * sum_{n=0}^nm (-1)**n * frac{x^n}{n!*(al+n)}
        !
        ! G&R 8.356.1: gi(al + 1, x) = al * gi(al,x) - x**al * exp(-x)

        IMPLICIT NONE
        REAL, intent(in)         :: q, u
        integer, intent(in)      :: nm
        integer                  :: n
        real                     :: al, dn, tn, sm, xt, tni, eps=0.001

        if ( q < 1.001 ) then
           ! Max steps in GammaincG:
           n = 4. + 10. * (q + 1.) / u
           giGR=GammaincG(q,u,n)
           return
        end if
        
        al = q - 1.

        dn = al
        tn = 1.
        sm = 0.
        xt = -u
        tni=tn/dn
        do n = 1,nm
           sm = sm + tni
           ! Exit loop when converged
           if ( abs(tni) < eps*sm) exit
           tn = tn * xt/n
           dn = dn + 1.
           tni=tn/dn
        end do

        ! Check convergence
        if (abs(tni) > eps*sm) then
           WRITE (NDSV, *), 'WARNING in w3xsmfmd function giGR: ', \
           'max number of terms (', nm, ') too small for q=', q, 'u=', u
        
            do n = nm,2*nm
               sm = sm + tni
               ! Exit loop if converged
               if ( abs(tni) < eps*sm) then
                  WRITE (NDSV, *), ' - Sufficient number of terms: ', n
                  exit
               end if
               tn = tn * xt/n
               dn = dn + 1.
               tni=tn/dn
            end do            
        end if
        
        giGR = ( al * sm  - exp(-u) ) * u**al

      end FUNCTION giGR

      real FUNCTION gi(q,u,nm)
        !
        ! The incomplete gamma function, power series representation for small
        ! values of u / (q + 1.). Times Gamma(A).
        !
        ! Derived from Numerical Recipes subroutine gser(a,x)
        IMPLICIT NONE
        REAL, intent(in)         :: q, u
        real, intent(in)         :: nm
        integer                  :: n,inm
        real                     :: EPS=3.e-3, ap, sum, dl
        WRITE (NDSE, *), 'The function gi(q,u,nm) is erroneous. Use giGR'
        call EXTCDE(1)
        inm=int(nm)
        sum=1./q
        ap=q+1.
        dl=sum*u/ap
        
        do n = 1,inm
           sum=sum+dl
           ap=ap+1.
           dl=dl*u/ap
           end do
        
        ! Make the result continous in nm (although not differentiable!):
        ! frac=nm-inm; sum = sum*(1.-frac) + (sum+dl)*frac
        sum = sum + ( nm - real(inm) ) * dl 
        
        gi = sum * exp(-q) * u**q

        return

      END FUNCTION gi
      
      real FUNCTION GAMMLN(XX)
        ! A routine from Numerical Recipes

        IMPLICIT NONE
        REAL, intent(in)             :: XX
        REAL*8 X,TMP,SER

        REAL*8, dimension(6) :: COF = (/76.18009173, -86.50532033, 24.01409822,&
                                     -1.231739516, .120858003E-2,-.536382E-5 /)
        REAL*8               :: STP = 2.50662827465D0
        REAL*8               :: HALF = 0.5D0, ONE = 1.0D0, FPF = 5.5D0

        INTEGER              :: J

        X = XX - ONE
        TMP = X + FPF
        TMP = ( X + HALF ) * LOG(TMP) - TMP
        SER = ONE
        DO J = 1,6
           X = X + ONE
           SER = SER + COF(J)/X
        END DO
        GAMMLN = TMP + LOG( STP * SER )

      END FUNCTION GAMMLN

      real FUNCTION GammaincG(A,X,NUMIT)
        ! 
        ! GammaincG(A,X,GmA) = GmA*gammainc(A,X) = GmA*(1-GAMMCF(A,X))
        !                    = Gamma(A) - EXP(-X) * X**A * GCF(A,X,NUMIT)
        ! GmA == Gamma(A). The user must supply this value.
        ! GAMMCF: Continued fraction method for the complement of the
        ! incomplete gamma function. GAMMCF is the name adpted in Numerical
        ! Recipes routines

        IMPLICIT NONE
        real, intent(in)            :: A,X
        integer, intent(in)         :: NUMIT
        real                        :: Gf,GmA
        
        GmA = exp( GAMMLN(A) )
        Gf = EXP(-X + A * LOG(X))
        GammaincG = GmA - Gf * GCF(A,X,GmA/Gf,NUMIT) 
        RETURN

      END FUNCTION GammaincG

      real FUNCTION GCF(A,X,Gof,NUMIT)
        ! Continued fraction factor in complementary incomplete gamma function,
        !    GammaincG = Gamma(A) - EXP(-X) * X**A * GCF(A,X,NUMIT)
        ! Algorithm from Numerical Recipes
        IMPLICIT NONE
        real, intent(in)            :: A,X,Gof ! Gof = Gamma(A)/(EXP(-X)*X**A)
        integer, intent(in)         :: NUMIT
        real                        :: EPS = 0.00001
        real                        :: G,GOLD,A0,A1,B0,B1
        real                        :: AN,ANA,FAC,ANF
        real                        :: FPMIN
        integer                     :: N

        G=0.
        GOLD=G
        A0=1.
        A1=X
        B0=0.
        B1=1.
        FAC=1.
        FPMIN = X * 1.e-7
        
        DO N=1,NUMIT
           AN=FLOAT(N)
           ANA=AN-A
           A0=(A1+A0*ANA)*FAC
           B0=(B1+B0*ANA)*FAC
           ANF=AN*FAC
           A1=X*A0+ANF*A1
           B1=X*B0+ANF*B1
           IF ( ABS(A1) < FPMIN ) THEN
              write(ndse,*) 'ERROR in W3XSMF FUNCTION GCF: abs(A1) < ', FPMIN
              CALL EXTCDE(1)
              end if
           FAC=1./A1
           GOLD=G
           G=B1*FAC           
           ! Test convergence of Gi = GmA - Gf * G:
           ! Gi > 0 and abs((Gi - GiOLD)/GiOLD) < eps, equivalent to:
           if ( abs(G-GOLD) < EPS*(Gof - GOLD) ) exit
        END DO
        
        GCF=G
        
        IF ( N == NUMIT .and.  xsmf_verbose > 1 ) &
           write (NDSV, *), 'WARNING in w3xsmfmd function GCF: ', &
           'number of iterations (', NUMIT, ') too small for A=', A, 'X=', X


      END FUNCTION GCF

      END MODULE W3XSMFMD
