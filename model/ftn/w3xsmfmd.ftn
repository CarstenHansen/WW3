#include "w3macros.h"
!/ ------------------------------------------------------------------- /
      MODULE W3XSMFMD
!/
!/                  +---------------------------------------------+
!/                  | Mattsson-Hansen fit to Stokes drift profile |
!/                  |          Carsten Hansen                     |
!/                  | Joint GEOMETOC Support Centre Denmark       |
!/                  |                          FORTRAN 90         |
!/                  | Last update :           09-OCT-2019         |
!/                  +---------------------------------------------+
!      TODO:
!       X) USERO should be exchanged with an array completely similar to US3D
!       X) Test if PM limiter is relevant: PMAX = ??
!       X) Consider a look-up table and function calls IPd=IPds(KsD,K_S)
!          and IPp=IPps(KsD,K_S)
!       X) In MHfit_init, Pds = exp ( - AMds * ZK_S ** PMds )
!          Then in each Stokes_MHfit(): initial guess Pd = Pds
!
!/
!/    02-May-2011 : Origination. Development program w3stokes.ftn converted
!/                  from tested Python code
!/    27-Jun-2011 : First module version w3dstkmd.ftn. Output tested with
!/                  a stand-alone program w3stokes.ftn.Implementation plan.
!/    18-Aug-2011 : Calculate fit to Mattsson parametric profile (ver.0.12)
!/    10-Oct-2011 : Interface subroutine w3dstk() to ww3_shel (version 0.22)
!/    21-Oct-2011 : Detailed description of implementation into WW3 v.3.14
!/                  First compilation of ww3_shel in parallel mode
!/                  Test-scripts run_ww3test.sh,
!/                     $PERL5LIB/bin/ww3job_preproc (version 0.32)
!/    08-Nov-2011 : Full functioning module. Checked against patches from
!/                  the WW3 errata page, applied: DEPTH=max(DW,DMIN).
!/                  Un-physical spatial discontinuities identified: May
!/                  need to match the Stokes profiles to integral wave
!/                  pseudo-momentum/depth-integrated Stokes drift (ver. 0.32).
!/    23-Nov-2011 : Ajust the deep profile to match the depth-integrated
!/                  Stokes drift. Function AJUST_FIT() (version 0.33).
!/    07-Dec-2011 : Refined ajustment of Mattsson-Hansen profiles to integral
!/                  pseudo-momentum (version 0.41).
!/    20-Feb-2012 : The integrated normalized pseudo momentum of the JM-profiles
!/                  is now (ver. 0.48) calculated from the surface to the
!/                  actual depth, and based on a mathematical expression for
!/                  the integral (not a numerical integral).
!/    02-Aug-2012 : Fitting of deep parameter PMd skipped (ver. 0.52)
!/
!/    06-Aug-2012 : (Ver. 0.55). Introduced a new procedure in profile fitting,
!/                  subroutine MH_fit(), which fully replaces the former
!/                  two-layers fit procedure.
!/                  MH_fit() performs, in a few iterative steps, a
!/                  parametric fit alternating with ajustment to the
!/                  integrated pseudo-momentum.
!/
!/    22-Dec-2017 : Adoption to WW3 version 5.16
!/                  + Call XSTOKES() from W3OUTG(), outside the loop over JSEA
!/
!/    19-Aug-2019 : Adoption to WW3 version 7.XX
!/                  + Mattsson-Hansen fitting is separated to module 'W3XSMFMD'
!/                  + Namelist group &XSTO
!/                  + Clearifying the in-code documentation
!/                  + Dimensionless parameters in calculations, e.g. M -> Kz M
!/                  + Replace Gradshteyn and Ryzhik with Numerical Recipes
!/                    in function gi()
!/                  + Quality count output field
!/                  +
!/
!/    11-Sep-2020 : Apply a lower limiter to abs(M)
!/                  Disabled: AM_tune
!/                  Disabled: swap if 1. - IPp/IPd < 0                    
!/                          
!/    30-Sep-2020 : Lookup table for the reverse of IP_calc when PM==PMds
!/                          
!/    16-Oct-2020 : Limit Ud projected on the opposite direction of Up
!/
!/
!  1. Purpose, and output data
!
!  A parametric representation of the Stokes drift profile vector U_S(Z) is
!  provided as a sum of two expressions (suggested by J. Mattsson and C.Hansen),
!        U_S(Z) = Up exp( -AM (Z Kz)^PM ) + Ud exp( -AMd (Z Kz)^PMd ) ,
!  where Up + Ud = U0 is the Stokes drift vector at the surface (Z=0) and
!  Z is pointing downwards.
!  A wave number Kz is related to the zero-upcrossing frequency by the
!  linear-wave dispersion relation, (2pi/Tz)^2 = g Kz tanh( Kz D). The
!  local depth D should also be provided in the output field for the bathymetry.
! 
!  The vertical integral of U_S(Z) equals the integral wave (pseudo) momentum
!  vector M. Further details on the MHfit parameters AM, PM, AMd, PMd are
!  found in Sect, 3, 'More on MHfit and suggestions for postprocessing'
!
!  U_S(Z) is determined as a best fit to the total model profile U_mod(Z)
!  constructed as a sum of a prognostic and a diagonostic (tail) contribution.
!  These profiles have been derived from the model spectra + spectral tail
!  using the module XSTOMD and subroutine CALL_XSTOKES(). NDEPTH discrete depths
!  have been given in an array Z_S(1:NDEPTH).
!
!  Also calculated are a scatter index of the profile fit, and a measure of
!  the convergence of the iteration procedure.
!
!  All calculations are performed in parallel and the results are gathered
!  to the process that writes the output using the user-slot variable 'USERO'.
! 
!  For this purpose, the length NOEXTR of the array USERO(JSEA,1:NOEXTR) is
!  extended to the required number of fitting parameters (7) plus one.
!
!  From the array UXSP (see w3xstomd.ftn) at least the following 5 values are
!  stored to out_grd.ww3 to be used in conversion to NetCDF (ww3_ounf) .
!
!    UXSP(JSEA,1)      = Kz     ! g Kz tanh( Kz D) = (2pi/T02)^2 [ 1/m ]
!
!    UXSP(JSEA,2)      = M_X    ! (M_X, M_Y) is the integral pseudo-momentum
!    UXSP(JSEA,3)      = M_Y    ! per unit surface area, divided by density.
!                               ! [ m^2/s ]        
!    UXSP(JSEA,4)      = U0_X   ! Surface Stokes drift [ m/s ]
!    UXSP(JSEA,4+XSND) = U0_Y 
!
!  Via the array USERO we store other seven fitting parameters
!
!    USERO(JSEA,1)     = Ud_X   ! Surface drift of 'deep' partition
!    USERO(JSEA,2)     = Ud_Y   ! Primary partition drift is Up = U0 - Ud
!    USERO(JSEA,3)     = AM     ! Fit parameter, primary partition
!    USERO(JSEA,4)     = PM     ! Fit parameter, primary partition
!    USERO(JSEA,5)     = AMd    ! Fit parameter, deep partition
!    USERO(JSEA,7)     = PMd    ! Fit parameter, deep part. May be a constant
!
!    USERO(JSEA,6)     = ITSIC  ! Quality count, see Stokes_MHfit()
!    !    IT  : Number of iterations in MH_fit
!    !    SI  : Scatter index  std(|U_S - U_mod| * dz)/|M|
!    !    C   : Convergence of iteration
!        
!    ! USERO(JSEA,8) is free to use for other purpose        
!
!  2. Usage
!
!  a) In ww3_grid.inp/namelists.nml, you may modify four namelist variables:
!     $ NDP: Number of depths (->NDEPTH)
!     $ DSC: Depth scale specifying ZK, the largest depth Z(NDP) * Kz
!     $ TYP: Tail type (C*4);
!     $      TYP='DoEw': Donelan-Ewans extension to infinite freq.,
!     $      TYP='DE20': Donelan-Ewans truncated at 2.0 Hz,
!     $      TYP='None': Prognostic spectrum truncated with no extension
!     &XSTO NDP = 31, DSC = 3.0, TYP = 'DE20' /
!
!  b) In w3initmd.ftn: Call XSTOKES_INIT() (module W3XSTOMD):
!     Allocation of StkProg(1:NDEPTH,I), StkDiag(1:NDEPTH,I), Z_Stk(1:NDEPTH)
!
!  c) In w3iogomd.ftn: Call the subroutine XSTOKES() (module W3XSTOMD): At each
!     WW3 output time step, calculation of the Stokes drift profile
!
!  d) Call the subroutine Stokes_MHfit () (present module W3XSMFMD):
!     Approximation of the profile with a parametric expression
!        U_S(Z) = Up exp( -AM (Z Kz)^PM ) + Ud exp( -AMd (Z Kz)^PMd ), 
!     where Kz is a characteristic wavenumber corresponding to T02, and the sum
!     of vectors Up + Ud is the Stokes drift at the surface.
!     Further details on the MHfit parameters Up, Ud, AM, PM, AMd, PMd are found
!     in Sect. 3.
!
!  3. More on Stokes_MHfit and suggestions for postprocessing
!
!  In the fitting procedure it is assured that the vertical integral of the
!  parametric drift profile equals the pseudo-momentum (or total Stokes
!  transport vector). Two dimensionless profile shape parameters are calculated,
!     IPp = int_0_D Kz exp( -AM (Z Kz)^PM ) d Z
!     IPd = int_0_D Kz exp( -AMd (Z Kz)^PMd ) d Z
!  where D is the water depth, and Kz a scaling wavenumber related to the
!  zero-crossing period T02 by the dispersion relation for low amplitude waves,
!  (2*pi/Tz)**2 = GRAV * Kz * tanh( D * Kz). (GRAV = 9.81).
!  IP is calculated in a function IP_calc.
!
!  Inclusion of the pseudo-momentum vector in the output allows for a possible
!  post-processing with temporal-spatial smoothing of the MHfit parameters
!  AM, PM, AMd, PMd. After smooting, the surface drift should be partioned
!  into a sum of a 'primary' partition and a 'deep' partition, U0 = Up + Ud,
!  following the operations below (Eqs. 1-7). After smoothing it must be
!  assured that the 'deep' profile decays slower than the 'primary' profile,
!  so that the difference of integrated profile shapes IPd - IPp is
!  significantly positive. This can be achieved by ajusting AM towards
!  a value of IPd - IPp which differ only slightly from an original, smoothed
!  value.
!        
!  Output data to use for reconstruction of the Stokes profile are:
!  Seafloor depth, Kz, M = (MX,MY), U0 = U_S(0) = (U0X,U0Y), Ud = (UdX,UdY),
!  AM, PM, AMd, together with a fixed parameters PMd (PMd = 0.4).
!
!  The pseudo-momentum vector, normalized by its depth scale, is
!        
!  (1)     MK = (MX,MY) * Kz
!        
!  The 2-dimensional surface Stokes drift vector
!        
!  (2)     U0 = (U0X, U0Y)
!
!  Factorize the normalized pseudo-momentum vector MK in an 'primary part' and
!  a 'deep part' as
!          MK = Up * IPp + Ud * IPd
!  where the surface Stokes drift is
!          U0 = Up + Ud
!
!  Here, IPp and IPd are dimensionless integrated profiles calculated by a
!  numerical function IP_calc():
!
!  (3)     IPp = IP_calc(Kz*D, AM, PM)
!  (4)     IPd = IP_calc(Kz*D, AMd, PMd)
!
!  Substitution yields a vector expression in the 'primary part' of
!  the surface drift Up, MK = (U0-Up)* IPd + Up * IPp, or
!        
!  (5)     Up = ( U0 * IPd - MK ) / (IPd - IPp)
!        
!  The 'deep part' of the surface drift is the remainder
!
!  (6)     Ud = U0 - Up
!
!  In case IPd ≃ IPp we have MK ≃ U0 * IPp and the values of Up, Ud become
!  ambigous. In any case, a new estimate of the parameter pair (AM, PM) will
!  be calculated by a best-fit method. Let proj_p(Ud) and proj_p(U_mod(z)) be
!  projections on the direction of Up. A 1-dimensional residual profile
!
!  (7)     Ur(Z) = proj_p( U_mod(Z) ) - proj_p(Ud) * exp ( -AMd (Z Kz)^PMd )
!        
!  will be fitted by an shape Up exp( -AM (Z Kz)^PM ). Here the surface 
!  value Ur(Z=0) is the known value of Up. Thus we can  fit the values of
!  log( log( Ur(Z)/Up ) ) (taking the log twice) with a linear expression
!  log(-AM) + PM log(Z Kz). Thereby the values of AM, PM, have been altered.
!
!  An iterative procedure is constructed as follows:
!
!  Calculate the new value of IPp using equation (3), and repeat calculation
!  corresponding to equations (5,6,7), but with the 'primary' and 'deep' parts
!  reverted. Thereby a new value of AMd is obtained by fitting a shape
!  Ud exp( -AMd (Z Kz)^PMd ).
!  Then calculate the new value of IPd using equation (4), and repeat so on.
!  Convergence at iteration step it is measured as
!  C =  | 1 - ( Up * IPp(it-1) + Ud * IPd(it-1) ) | / | MK |.
!
!  4. Implementation in WW3:
!
!  Code lines are added to WW3 under the two compile switches '!/XSTO' and
!  '!/MFIT'. First, follow the implementations as described in w3xstomd.ftn.
!
!  a) w3odatmd.ftn
!
!     Real arrays UXSP(JSEA,1:4), UXSP(JSEA,4+XSND) and USERO(JSEA,1:6) (a
!     "user_slot") contain the 11 Stokes fitting parameters for the sea point
!     JSEA. UXSP and USERO are structures for later communication to the job
!     that performs field output and belong to the module w3adatmd.ftn.
!
!     In w3odatmd.ftn, set the integer NOEXTR to 1 + the number of parameters
!     (7) used in USERO. Remove the 'parameter' type from it's
!     module declaration
!     ! change this line      INTEGER, PARAMETER      :: NOEXTR=  2
!            INTEGER                 :: NOEXTR=  2
!     In subroutine W3NOUT(), set NOEXTR = NOEXSTK and specify the MHfit
!     parameter names
!     !/MFIT      INTEGER, PRIVATE        :: NOEXSTK = 8
!     (...)
!     !/MFIT      NOEXTR = 0
!           DO I=1, MIN ( 20 , NOEXTR )
!             WRITE (STRING,'(A14,I2.2,A4)') 'User defined #', I, '    '
!             IDOUT(10, I) = STRING
!             END DO
!     !/MFIT      NOEXTR = NOEXSTK
!           NOGE(10) = NOEXTR
!     !/MFIT
!     !/MFIT      IDOUT(10, 1)  = 'Deep Stokes drift E.'
!     !/MFIT      IDOUT(10, 2)  = 'Deep Stokes drift N.'
!     !/MFIT      IDOUT(10, 3)  = 'MHfit parameter AM  '
!     !/MFIT      IDOUT(10, 4)  = 'MHfit parameter PM  '
!     !/MFIT      IDOUT(10, 5)  = 'MHfit parameter AMd '
!     !/MFIT      IDOUT(10, 6)  = 'Quality count ITSIC '
!     !/MFIT      IDOUT(10, 7)  = 'MHfit parameter PMd '
!     !/MFIT      IDOUT(10, 8)  = 'User defined #1     '
!     (...)
!
!  b) w3iogomd.ftn
!
!     b1) SUBROUTINE W3READFLGRD, and also in W3FLGRDFLAG:
!     !/MFIT      USE W3ODATMD, ONLY: NOEXTR
!        (...)
!     ! Group 10
!     !
!                CASE('U1')
!                  FLG2D(10,1)=.TRUE.
!     !/MFIT            FLG2D(10,min(7,NOEXTR))=.TRUE.
!                CASE('U2')
!                  FLG2D(10,2)=.TRUE.
!     !/MFIT           CASE('MFIT')
!     !/MFIT             FLG2D(10,1:NOEXTR-1)=.TRUE.
!        
!     b2) In subroutine W3FLGRDUPDT
!     !/XSTO      ! Set NZO for use in W3DIMA, W3DIMX
!     !/XSTO      NZO = 0
!     !/XSTO      IF ( FLGRD(6,13) ) NZO = XSND
!     !/MFIT      ! For FLGRD(10,1), if FLGRD( 6, 13) is False, only the
!     !/MFIT      ! surface and integral variables are in UXSP(1:NSEA,1:5)
!     !/MFIT      IF ( FLGRD(10,1) .AND. .NOT. FLGRD(6,13) ) NZO = 1
!        
!     b3) In subroutine W3OUTG:
!     Declare use of CALC_MFIT()
!     !/MFIT      USE W3XSMFMD, ONLY: CALC_MFIT
!     (...)
!       (...)
!       !  Add here USERO(JSEA,1) ...
!       !
!       !/XSTO! UXSP(JSEA,1:3+2*XSND) is set by CALC_XSTOKES(A). Thereafter,
!       !/MFIT! USERO(JSEA,1:6) is determined by CALC_MFIT(A)
!       !/MFIT! The combined CALC_XSTOKES(A); CALC_MFIT() are called
!       !/MFIT! outside and after the present loop
!
!     b4) Later in  W3OUTG() just following CALL CALC_XSTOKES():
!     !/XSTO ! Stokes drift with extended tail
!     !/XSTO       IF ( FLOLOC(6,13)        &
!     !/MFIT            .OR.  FLOLOC(10,1)  &
!     !/XSTO                         ) THEN
!     !/XSTO           CALL CALC_XSTOKES(A)
!     !/XSTO         END IF
!     !/MFIT       IF ( FLOLOC(10,1) ) CALL CALC_MFIT()
!     !/XSTO!
!        
!  c) In ww3_ounf.ftn:
!     Define the relevant NetCDF variable names etc.
!
!  d) Modify the makefile scripts (make_makefile.sh, w3_new) as
!     described in the WW3 manual chpt. 5.5
!
!     d1) make_makefile.sh:
!       for type in ...  xsto xsmf; do
!       (...)        
!       case $type in ...
!         (...)        
!     #sort:xsto:
!         xsto ) TY='upto1'
!                ID='Extended tail Stokes drift'
!                TS='XSTO'
!                OK='XSTO' ;;
!     #sort:xsmf:
!         xsmf ) TY='upto1'
!                ID='Stokes drift MHfit'
!                TS='MFIT'
!                OK='MFIT' ;;
!
!       (...)
!       case $prog in
!         (...)
!         ww3_shel) (...)
!                  IO="$IO w3xstomd w3xsmfmd"
!         (...)
!         ww3_multi|ww3_multi_esmf)
!                   (...)
!                   IO="$IO w3xstomd w3xsmfmd"
!       (...)        
!       case $mod in
!          (...)
!          'W3XSTOMD'     ) modtest=w3xstomd.o ;;
!          'W3XSMFMD'     ) modtest=w3xsmfmd.o ;;
!
!     d2) w3_new:
!
!       for key in $keys
!       do
!         case $key in
!           (...)
!           'xsto' ) cd $main_dir/ftn ; touch w3xstomd.ftn
!                                       touch w3initmd.ftn
!                                       touch w3odatmd.ftn
!                                       touch w3gdatmd.ftn
!                                       touch w3iogomd.ftn
!                                       touch w3iogrmd.ftn
!                                       touch ww3_grid.ftn ;;
!           'mfit' ) cd $main_dir/ftn ; touch w3xstomd.ftn
!                                       touch w3xsmfmd.ftn
!                                       touch w3odatmd.ftn
!                                       touch w3gdatmd.ftn
!                                       touch w3iogomd.ftn
!                                       touch w3iogrmd.ftn
!                                       touch ww3_ounf.ftn ;;
!
!  5. Variables and types :
!
!      Name      Type  Scope    Description
!     ----------------------------------------------------------------
!                C*10  Private
!
!     ----------------------------------------------------------------
!
!  6. Subroutines and functions :
!
!      Name      Type  Scope    Description
!     ----------------------------------------------------------------
!
!     ----------------------------------------------------------------
!
!  7. Subroutines and functions used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!
!     ----------------------------------------------------------------
!
!  8. Remarks :
!
!
!  9. Switches :
!
!       !/SHRD  Switch for shared / distributed memory architecture.
!       !/DIST  Id.
!
!       !/ST2   Source term set 2 (Tolman and Chalikov)
!               ST2 is required for consistent similarity.
!
!/NL1

!  10. Source code :
!
      USE W3SERVMD, ONLY: EXTCDE
      USE W3ADATMD, ONLY: USERO
      USE W3ODATMD, ONLY: NDSO, NDSE, NDST, IAPROC, NAPROC, NAPOUT
      USE W3GDATMD, ONLY: XSND, XSDS, NSEAL, NK, NTH, SIG, DMIN
      ! Stokes drift profile data      
      USE W3ADATMD, ONLY: DW, UXSP, ZK_S
      ! XSVB: Verboseness level [0..4] of XSTO output to NDST or NDSO 
      USE W3ODATMD, ONLY: XSVB, NZO

      PRIVATE
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/

      ! Common Stokes drift depth distribution parameters to be set
      ! in MHfit_init()      
      real                        :: M_X, M_Y, K_S
      real, pointer               :: U_S(:), V_S(:)
      
      real                        :: KsD, AMs, PMs, AMds, PMds, AMIN, AMAX
      real                        :: PMIN, PMINd, PMAX, PMAXd, AMINd, AMAXd

      ! Look-up parameters to determine profile coefficients AM, PM

      real, allocatable           :: DZK_S(:), log_KZ(:)
      integer                     :: XSNDeep, XSNUpper, Zdi, NA = 0
      real                        :: delAMlu
      
      real, allocatable           :: AMdlu(:,:)
      real, allocatable           :: dIPq(:), IPmP(:)
      integer                     :: iIP, iIPmax, iKDmax
      real                        :: KsDmin, KsDmax, dlKSD

      ! Verboseness of test output
      integer                     :: xsmf_verbose
      ! Test output file id.:
      integer                     :: NDSV

      PUBLIC :: CALC_MFIT
!/
      
      CONTAINS

      SUBROUTINE CALC_MFIT ()      
!/
!/                  +-------------------------------------+
!/                  | FCOO Stokes profile parametric fit  |
!/                  |           Carsten Hansen            |
!/                  |                        FORTRAN 90   |
!/                  | Last update :         03-Oct-2019   |
!/                  +-------------------------------------+
!/
!/      
!/    Remarks: This subroutine can be called after CALC_XSTOKES
!/             Call CALC_MFIT only under switch /MFIT
!/
      USE W3GDATMD, ONLY: MAPSF, MAPSTA ! module scope:,NSEAL
!/
      IMPLICIT NONE

!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      INTEGER                 :: ISEA, JSEA, IX, IY

! Initialization
! Generate common look-up table to determine profile coefficients
! AM, PM that reproduce a given normalized profile IP0

      IF ( NA .EQ. 0 ) THEN         
        call MHfit_init()
        IF ( xsmf_verbose .GT. 0 ) &
          WRITE (NDSV, *) '    Stokes profile fit initialized for',NSEAL,'points'
        END IF
     
      IF ( xsmf_verbose .GT. 0 ) WRITE (NDSV, 912), 'Stokes profile fit ..'
!
! -------------------------------------------------------------------- /
! 1.  Loop over sea points
!     
      DO JSEA=1, NSEAL
!
! -------------------------------------------------------------------- /
! 2.  Process only for water points
!
!/DIST        ISEA       = IAPROC + (JSEA-1)*NAPROC
!/SHRD        ISEA       = JSEA
        IX     = MAPSF(ISEA,1)
        IY     = MAPSF(ISEA,2)
!
        WRITE (NDSV, *) JSEA,ISEA
        IF ( MAPSTA(IY,IX) .GT. 0 ) &
          call Stokes_MHfit(JSEA)
          ! If under MPI only UXSP(JSEA,1:5) is communicated to XUXSP for output
          if ( NZO < XSND ) &
               UXSP(JSEA,4+NZO:3+2*NZO) = UXSP(JSEA,4+XSND:3+XSND+NZO)
         END DO
      
      IF ( xsmf_verbose .GT. 0 ) WRITE (NDSV, 912), 'Stokes fits done'
      
  912 FORMAT ('  ',A)

      END SUBROUTINE CALC_MFIT    
      
      
      SUBROUTINE Stokes_MHfit(JSEA)

      IMPLICIT NONE
      INTEGER, INTENT(IN)         :: JSEA
      
! Parametric profile fitting
      integer                     :: ISEA, lenSt, IZ
      real                        :: UsD, VsD, AM, PM, AMd, PMd
      real                        :: ITSIC
      real                        :: rel_ms, UN, fac

!/ ------------------------------------------------------------------- /

!  Calculate fit to Mattsson-Hansen parametric profile
!--------------------
!
!     MHfit profile fit. Find the surface vectors Up, Ud and
!     the parameters AM, PM, AMd, PMd so that with a minimum e(:),
!     (U_S(i),V_S(i)) = e(i) + Up*exp(-AM*ZK(i)**PM) + Ud*exp(-AMd*ZK(i)**PMd)
!     where
!     ZK(i) = Z(i) * Kz, Kz  = ( TPI / Tz)**2 / GRAV
!     J. Mattsson first suggestion for the parameters:
!     AM=2.5, PM=0.45, Ud=0

      if ( xsmf_verbose > 1 .and. JSEA == 1 ) &
           WRITE (NDSV, *), JSEA, '  Fit the MHfit profile'
      

      K_S = UXSP(JSEA,1)
      M_X = UXSP(JSEA,2)
      M_Y = UXSP(JSEA,3)
      U_S => UXSP(JSEA,4:3+XSND)
      V_S => UXSP(JSEA,4+XSND:3+XSND*2)
      
      ! Feed with number of fitting cycles in MH_fit
      ! A minimum of 1 cycle + a half cycle is required:
      ! Cycle 1: fit AM,PM -> update Ud,Up -> fit AMd,PMd -> update Up,Ud 
      ! Half cycle: fit AM,PM -> update Ud,Up

      ITSIC = 1.
      
      call MH_fit(JSEA, AM, PM, AMd, PMd, UsD, VsD, ITSIC)

      UXSP(JSEA,2)   = M_X
      UXSP(JSEA,3)   = M_Y

      USERO(JSEA,1)  = UsD     ! Surface drift of 'deep' part.
      USERO(JSEA,2)  = VsD     ! Primary part drift is UsP=U_S-UsD.

      USERO(JSEA,3)  = AM      ! MHfit parameter, primary part
      USERO(JSEA,4)  = PM      ! MHfit parameter, primary part

      USERO(JSEA,5)  = AMd     ! Deep part MHfit parameter.

      USERO(JSEA,6) = ITSIC    ! Quality integer
      USERO(JSEA,7) = PMd      ! Deep part MHfit parameter. May be constant PMds
      ! IT : Number of cycles in MH_fit
      ! SI : Scatter index % std(|U_S - U_mod| * dz)/|M|
      ! C  : Convergence of iteration
      !
      ! ITSIC = min( niter * 1000. &
      !              + min( 990., int(max(1., 100*si))*10. ), 32000. ) &
      !              + min( 9., 10.*cit )
      ! Reconstruction:
      !
      ! ITSI  = int(0.1*ITSIC)
      ! C     = ITSIC - ITSI*10
      ! IT    = int(0.001*ITSIC)
      ! SI    = ITSI - IT*100

      if ( xsmf_verbose > 1  .and. JSEA == NSEAL )  &
         WRITE (NDSV, *), JSEA, '  MHfit done. ITSIC =', ITSIC

      END SUBROUTINE Stokes_MHfit

      
      subroutine MHfit_init()

      IMPLICIT NONE
      integer                     :: iZ, iret
      real                        :: qq, PM, AM, IP, IPd, XKZ
      logical                     :: OPENED

      real                        :: IPm, AMl
      integer                     :: numi, iA, li, iKD, unfilled_zeros
      
      ! Set verboseness and file id. of output messages
      NDSV = NDST
      if ( XSVB .gt. 0 ) then
        INQUIRE (NDSV,OPENED=OPENED)
        IF ( .NOT. OPENED ) THEN
          XSVB = 0
          if ( IAPROC == NAPOUT) then
            NDSV = NDSO
            XSVB = 1
            end if
          end if
        end if
      xsmf_verbose = XSVB            

!/T      xsmf_verbose = xsmf_verbose+1
      
      ! Initializing values ( based on tests 2020 with ST4-Romero)
      AMds = 0.6; PMds = 1.5
      AMs = 2.5; PMs = 0.57

      ! Overall min/max values in MH_fit
      PMIN = 0.1  ! PM
      PMAX = 2.0  ! PM
      AMIN = 0.2  ! AM
      AMAX = 8.0  ! AM        
      PMINd = 0.5  ! PMd
      PMAXd = 2.4  ! PMd
      AMINd = 0.4  ! AMd        
      AMAXd = 3.0  ! AMd        

      ! Generate common look-up table for AM, given integrated momentum
      ! normalized by surface speed

      delAMlu = 0.1
      NA = int(AMAX/delAMlu+1.5)
      
      KsDmin = 0.1
      KsDmax = 3.0
      iKDmax = 5
      DO iKD = 1,iKDmax
         KsD = KsDmin
         IPm = IP_calc(KsD, AMINd, PMds)
         IP = IP_calc(KsD, AMAXd, PMds)
         if (IP**(-PMds)-IPm**(-PMds) > 1.0) exit
         KsDmin=2.*KsDmin
         END DO
      if ( iKD > 1 ) then
         write (ndse,*) 'Config error in w3xsmfmd (probably weak',        &
                        'convergence in GCF()). Set KsDmin to at least', KsDmin
         call extcde(1)
      end if         
      
      dlKSD = log(KsDmax/KsDmin)/(iKDmax-1) ! dlKSD = 0.85
      
      if ( .not. allocated(AMdlu) ) allocate( AMdlu(NA,iKDmax), stat=iret )
      if ( .not. allocated(IPmP) ) allocate( IPmP(iKDmax), stat=iret )
      if ( .not. allocated(dIPq) ) allocate( dIPq(iKDmax), stat=iret )
      AMdlu=0.

      iIPmax = NA
      do iKD = 1,iKDmax  
         KsD = KsDmin*exp((iKD-1)*dlKSD)
         numi=0
         li=1
         IPm = IP_calc(KsD, AMINd, PMds)
         IP = IP_calc(KsD, AMAXd, PMds)
         IPmP(iKD) = IPm**(-PMds)
         dIPq(iKD) = (IP**(-PMds)-IPmP(iKD))/(NA-1)
         do iA = 0,NA*10
           AM = AMINd+iA*dIPq(iKD)
           IPd = IP_calc(KsD, AM, PMds)
           iIP = int ( (IPd**(-PMds) - IPmP(iKD))/dIPq(iKD) + 1.5)
           if (  iIP .ne. li ) then
              AMdlu(li,iKD) = (AMdlu(li,iKD)+AM)/(numi+1)
              if (iIP > NA ) exit
              li = iIP 
              numi = 1
              AMdlu(iIP,iKD) = AMl
           end if
           AMl=AM
           if ( numi == 0 .and. AMdlu(iIP,iKD) > 0. ) cycle
           AMdlu(iIP,iKD) = AMdlu(iIP,iKD) + AM
           numi=numi+1           
           end do
         if ( iIP == li ) then
           write (ndse,*) 'Code error in w3xsmfmd: iA=',iA,6*NA
           call extcde(1)
           end if
         ! Fill zeros
         unfilled_zeros=1
         do while (unfilled_zeros > 0)
           unfilled_zeros = 0
           do iIP = 2,NA-1
             if (AMdlu(iIP,iKD) == 0.) then
               numi=0
               if (AMdlu(iIP+1,iKD) > 0.) then
                 AMdlu(iIP,iKD) = AMdlu(iIP+1,iKD)
                 numi = 1
                 end if
               if (AMdlu(iIP-1,iKD) > 0.) then
                 numi = numi + 1
                 AMdlu(iIP,iKD) = (AMdlu(iIP,iKD) + AMdlu(iIP-1,iKD)) / numi
                 end if
               if (numi == 0 ) unfilled_zeros =  unfilled_zeros + 1
               if ( unfilled_zeros >= 3 ) then
                 write (ndse,*) &
                   'Too many holes in lookup table in w3xsmfmd, iIP=', iIP, &
                   'This is a programmers error'
                 call extcde(1)            
                 end if
               end if
             end do ! while (unfilled_zeros > 0)
           if (AMdlu(1,iKD) == 0.) AMdlu(1,iKD) = AMdlu(2,iKD)
           if (AMdlu(NA,iKD) == 0.) AMdlu(NA,iKD) = AMdlu(NA-1,iKD)
           end do
         end do ! iKD = 1,iKDmax
      
      ! To look-up, given IPd, use function AMd_lookup(KsD, IPd)
         
      if ( .not. allocated(DZK_S) ) allocate( DZK_S(XSND), stat=iret )

      ! DZK_S = K_S * approximate thicknesses (m) of each layer
      ! In w3xstomd, the dimensionless profile depths have been defined as
      ! ZK_S(IZ)  = XKZ**(IZ-1) - 1., where
      XKZ = (1. + XSDS)**(1./(XSND-1.))

      ! The uppermost layer at the surface has approximately half thickness.
      DZK_S(1) = (XKZ - 1.) * 0.5
      DZK_S(2:XSND) = (ZK_S(2:XSND) + 1.) * (XKZ - 1./XKZ) * 0.5     

      ! Max depth for fitting the 'upper' partition is XSDS = 1.5
      XSNUpper = min(XSND, int(log(2.5)/log(XKZ)) + 1)
      
      ! Min depth for fitting the 'deep' partition is XSDS = 3.0
      ! Extend the profile to fit if it is shorter than this
      XSNDeep = max(XSND, int(0.5*(XSND+log(4.)/log(XKZ))) + 1)
      if ( .not. allocated(log_KZ) ) allocate( log_KZ(XSNDeep), stat=iret )
      log_KZ(2:XSND) = log(ZK_S(2:XSND))
      do IZ = XSND+1, XSNDeep
        log_KZ(IZ) = log(XKZ**(IZ-1) - 1.)
        end do
      ! Dummy value at surface
      log_KZ(1) = 0.

      ! Max depth index for initial deep fit is for KZ = 1.0
      !Zdi = int(log(2.0)/log(XKZ)) + 1
      ! Max depth index for initial deep fit is for KZ = 1.5
      Zdi = int(log(2.5)/log(XKZ)) + 1
      ! Max depth index for initial deep fit is 
      ! Zdi = XSND - 3

      end subroutine MHfit_init
      

      real function AMd_lookup(KsD, IPd)
        implicit none
        real, intent(in) :: KsD,IPd
        integer          :: iKD, iIP
        ! Look-up AMd, given IPd and KsD, and presuming PMd==PMds
        iKD = min( max( 1+int(log(KsD/KsDmin)/dlKSD), 1), iKDmax)
        iIP = min( max( int ( (IPd**(-PMds) - IPmP(iKD))/dIPq(iKD) + 1.5), &
                        1), iIPmax)
        AMd_lookup = AMdlu(iIP,iKD)
        
      end function AMd_lookup
      
      
      subroutine MH_fit(JSEA, AM, PM, AMd, PMd, UdX, UdY, ITSIC)
        
      implicit none

!     Mattsson-Hansen profile fit. Find the surface vectors Up, Ud and
!     the parameters AM, PM, AMd, PMd so that with a minimum rms error |e(:)|,
!     (U_S(i),V_S(i)) = e(i) + Up*exp(-AM*ZK(i)**PM) + Ud*exp(-AMd*ZK(i)**PMd)
!     where
!     ZK(i) = Z(i) * Kz, Kz  = ( TPI / Tz)**2 / GRAV


      integer, intent(in)      :: JSEA
      real, intent(out)        :: AM, PM, AMd, PMd, UdX, UdY
      real, intent(inout)      :: ITSIC
      
      complex                  :: MK, Ud, U0, Up, unit, Us, Ut
        
      real                     :: IPp, IPd, tmp, Udl, Upr, Mpr, IP2_min, mlU
      real, allocatable, save  :: Pd(:), Pp(:), Umr(:)
      integer                  :: lenSt, iter, numPos, ii, im, nneg
      integer                  :: ISEA, IZ, iKD, Zt
      complex                  :: Upi(5),Udi(5)
      real                     :: IPpi(5),AMi(5),PMi(5),AMdi(5),PMdi(5),IPdi(5)
      real                     :: qci(5), msi(5)
      logical                  :: wi(5), warning_issued, capped
      real                     :: fi, fiU, Umr_min, Umd_min, dIP, dIP_min
      real                     :: si, cit, sm, qcr, qcd, rms_U
      real                     :: IPm, IP
      integer                  :: NA, niter
      character(len=5)         :: fit_kind
      
      niter = min(max(int( ITSIC+0.1 ), 1 ),3)

      dIP_min = 0.01

!/    Initially, assume standard parameters of the profiles
      AMd = AMds; PMd = PMds; AM = AMs; PM = PMs
      
      ! Convert input vectors to complex numbers, and normalize M
      MK = cmplx( M_X, M_Y ) * K_S
      U0 = cmplx( U_S(1), V_S(1) )

!/DIST      ISEA       = IAPROC + (JSEA-1)*NAPROC
!/SHRD      ISEA       = JSEA
      KsD  = K_S * MAX ( DMIN, DW(ISEA) )

      ! lenSt: Number of depths of the discrete profile above the sea bed
      lenSt = XSND ! Configured value if all above the sea bed     
      do IZ = XSND,1,-1
        if ( ZK_S(IZ) > KsD ) cycle
        lenSt = IZ
        exit
        end do
      
      !   Avoid uncertainty due to division by a near-zero-value of U0
      if ( abs(U0) < 0.0001 ) U0 = -0.0001/(abs(MK)+0.0001) * MK
      
      ! Longest vector deviation from surface value and its depth index
      Zt = lenSt
      call S_span(Us,Zt)
      if ( Zt > Zdi .or. lenSt - Zt <= 3 ) Zt = lenSt
      
      ! If there is a turning depth, estimate the deep fit parameters
      ! Given PMd = PMds, estimate Ud and AMd
      if ( Zt /= lenSt ) then

        ! Deep profile direction:
        Ut = cmplx(U_S(Zt+1), V_S(Zt+1))
        ! Projection on the direction of Ut
        unit = Ut / abs(Ut)
        Umr(Zt:lenSt) = U_S(Zt:lenSt) * real(unit) + V_S(Zt:lenSt) * aimag(unit)
        Umr(Zt:lenSt) = Umr(Zt:lenSt)/abs(Ut)
        Umr_min = 0.01
        do ii = Zt,lenSt
          if  (Umr(ii) < Umr_min ) exit
          end do
        if (ii == lenSt) then
          numPos = ii
        else
          numPos = ii - 1
          end if
        
        call lin_reg(-log(Umr(Zt:numPos)),ZK_S(Zt:numPos)**PMd,AMd,mlU,AMINd,AMAXd)
        Ud = Ut * exp(-mlU)
        
!/      The 'upper part' of the surface drift is the remainder
        Up = U0 - Ud
        
      end if
      
      IPd = IP_calc(KsD, AMd, PMd)

      if ( Zt == lenSt ) then
!/      Factorize the normalized M*K in an 'primary part' and a 'deep part' as
!/      MK = Ud * IPd + Up * IPp, where
!/      U0 = Ud + Up, and where IPd, IPp are normalized profile shapes
        ! TODO: Consider a look-up table and function calls IPd=IPds(KsD)
        !       and IPp=IPps(KsD)
        IPp = IP_calc(KsD, AM, PM)

!/      Substitution yields a vector expression in one unknown part Up,
!/      MK = (U0-Up)* IPd + Up * IPp,  or
        Up = ( U0 * IPd - MK ) / (IPd - IPp)
!/        The 'deep part' of the surface drift is the remainder
        Ud = U0 - Up
        end if
      
      ! Handling of small drift
      if ( abs(U0) < 0.003 .and. abs(MK) < 0.003 ) then
        ! Neglect the details when very weak Stokes drift
        ITSIC = 9999.
        return
        end if
      
      if ( .not. allocated(Umr) )  allocate( Umr(XSND), stat=ii )
      if ( .not. allocated(Pd) )   allocate( Pd(XSND), stat=ii )
      if ( .not. allocated(Pp) )   allocate( Pp(XSND), stat=ii )
      
      ! Smallest drift values allowed in the improved estimates
      ! of (AM, PM, AMd) in the iteration steps below

      Umr_min = abs(Up) * exp( - AMs * ZK_S(lenSt)**(PMs*2) )
      Umd_min = abs(Ud) * exp( - AMd * ZK_S(lenSt)**(PMds*2) )

      ! The two parametric profile components
      Pp = exp ( - AM * ZK_S ** PM )
      Pd = exp ( - AMd * ZK_S ** PMd )

      warning_issued = .false.
      
!/ Cycles:

      ! A minimum of 1 fitting cycle + a half cycle is required:
      ! Cycle 1: fit AM,PM -> update Ud,Up -> fit AMd,PMd -> update Up,Ud 
      ! Half cycle: fit AM,PM -> update Ud,Up

      ! niter+2 is an extra cycle to take if Ud is nearly zero
      
      do iter=1,niter+2

!  Register the primary profile parameters
      
        AMi(iter)  = AM
        PMi(iter)  = PM
        AMdi(iter) = AMd
        PMdi(iter) = PMd
        Upi(iter)  = Up
        Udi(iter)  = Ud
        IPpi(iter) = IPp
        IPdi(iter) = IPd
        qci(iter)  = 0.
        wi(iter)   = warning_issued

        ! Mean square deviation from predicted profile
        msi(iter) = calc_msd( Up, Ud, Pp, Pd, lenSt)                 

        warning_issued = .false.

!/
!/  step 1: Apply the model profile Um(z ) to yield improved estimates
!/          of (AM, PM) determined as the best fit to the residual
!/          Umr(z) =  proj(Um(z)) - proj(Ud)*Pd(z),
!/          where proj is the projection on the direction of Up given from
!/          the previous iteration, and Pd(z) = exp ( - AMd * zK ** PMd ) is
!/          given from the parametric deep parameters of the previous iteration.
!/          Note that Pd(z=0) = 1 and Umr(z=0) = Up

        ! Projection Ud * unit of vector Ud on direction of Up
        unit = Up/abs(Up)
        Umr = U_S * real(unit) + V_S * aimag(unit)
        
        if (abs(Ud)>0.) then
          tmp = real(Ud) * real(unit) + aimag(Ud) * aimag(unit)
          Umr = Umr - tmp * Pd
          end if
          
        qcr = Umr_min
        fit_kind='upper'
        call fit_proj(AM,PM,log_KZ,Umr,lenSt,qcr,'upper')
        
        if (PM > 2.*PMs .or. 3.*PM < PMs+PMIN ) warning_issued = .true.
        
!/  step 2: Update the profile parts, given the old IPd and new IPp

        if (xsmf_verbose > 2 ) &
                write (NDSV,*) ' ISEA=', ISEA, '  IP_calc( ', AM, PM,')'
        IPp = IP_calc( KsD, AM, PM)

!       Match to MK the surface vectors for deep- and primary-profile parts
        dIP = IPd/IPp - 1. 
        if ( abs(dIP) > dIP_min ) then
          ! Finalize the iteration loop if iter >= niter + 1 half step
          if ( iter > niter .and. .not. capped ) exit
        
          ! MK = (U0-Ud)* IPp + Ud * IPd, which means that
          Ud = ( MK/IPp - U0 ) / dIP
          Up = U0 - Ud
          ! Limiter to the magnitude of Ud. Require |Up| >= 2 * |Ud|
          ! This is with the purpose of preserving positive values to
          ! some depth of the 1-d profile Umr below
          ! call Ud_cap(Ud,Up,U0)
        
        else
          ! Either MK = (U0-Ud)* IPp + Ud * IPd = U0*IPp + eps
          !      or     MK = Ud * IPd + eps
          ! We choose MK = U0*IPp + eps and approximate eps=0.
          Up = U0
          Ud = 0.
          if ( iter > niter+1) exit
          capped = .False.
          cycle ! Repeat steps 1, 2 (even for iter=niter+2)
          end if
          
!/  step 3: Determine AMd as the best fit of the secondary, 'deep',
!/          profile given the surface drift partition Ud

        if (xsmf_verbose > 2 ) write (NDSV,*), '  Fit AMd'
            
        ! Find  Umr(z)= proj_d(Um) - proj_d(Up)*Pp
        ! projected on the direction of Ud
        
        Udl = abs(Ud)
        unit = Ud /  Udl
        tmp = real(Up) * real(unit) + aimag(Up) * aimag(unit)
        
        Pp = exp ( - AM * ZK_S ** PM )
        
        Umr = U_S * real(unit) + V_S * aimag(unit) - tmp * Pp
        qcd = Umd_min
        ! 
        AMd = AMds ! For a ref. profile within fit_proj
        PMd = PMds ! - do. -
        fit_kind='deep '
        if (.true.) then
          ! free PMd
          call fit_proj(AMd,PMd,log_KZ,Umr,lenSt,qcd,fit_kind)
          if (.not. (PMd>PM .and. PMd<PMAXd .and. AMd>AMINd .and. AMd<AM)) then
            AMd = AMds
            if (PMd < PM) then
               PMd = PM
               if (PMd > PMds) PMd = PMds
            else if (PMd > PMAXd) then
               PMd = PMAXd
            end if
            qcd = Umd_min
            call fit_proj(AMd,PMd,log_KZ,Umr,lenSt,qcd,fit_kind,PMds)
            end if
        else
          ! bound PMd=PMds
          call fit_proj(AMd,PMd,log_KZ,Umr,lenSt,qcd,fit_kind,PMds)
          end if
          
        if ( iter > niter ) then ! if capped
           Pd = exp ( - AMd * ZK_S ** PMd )
           exit
        end if
        
        ! Apply a low limiter to AMd
        AMd = max(AMd, AMINd)
        
        IPd = IP_calc( KsD, AMd, PMd)
        
        ! Apply a low limiter to IPd
        IP2_min = 2.*abs(MK)/abs(U0) - IPp
        if ( IPd < IP2_min ) then
          ! Look-up AMd, given IPd= IP2_min:
          AMd = AMd_lookup(KsD, IP2_min)
          ! Get a precise value of IPd for the new AMd
          PMd = PMds
          IPd = IP_calc( KsD, AMd, PMd)
          if ( iter == niter .and. xsmf_verbose  > 0 )  write (ndsv,*) &
            'ISEA=', ISEA, Amd, ' == AMd = AMd_lookup(',KsD,', ',IP2_min,')'
          
          end if
          
!/  step 4: Update the profile partitions based on the old IPp and a new IPd
        if (xsmf_verbose > 2 ) write (NDSV,*), '  IP_calc(KsD', AMd, PMd,')'
        
!       Match to MK the surface vectors for the profile partitions
        dIP = 1. - IPp/IPd
        if ( abs(dIP) > dIP_min ) then
          ! MK = (U0-Ud)* IPp + Ud * IPd,  or
          Up = ( U0 - MK/IPd ) / dIP
          Ud = U0 - Up
          Pd = exp ( - AMd * ZK_S ** PMd )
          ! Limiter to the magnitude of Ud. Require |Up| >= 2 * |Ud|
          ! This is with the purpose of preserving positive values to
          ! some depth of the 1-d profile Umr in the refinement

          if (iter <= niter ) call Ud_cap(Ud,Up,U0,Us,capped=capped)
        else
          Up = U0
          Ud = 0.
          Pd = 0.
          end if
        
!     Repeat steps 1-2 with the new AMd to get a precise fit of AM, PM
        
        end do ! iter = 1,niter+2
      
      if ( AMd <= AMINd ) warning_issued = .true.
        
!  Scatter index of the final fit
      sm  = calc_msd( Up, Ud, Pp, Pd, lenSt)

      niter = iter - 1
      
      if ( xsmf_verbose > 2 &
           .or. ( xsmf_verbose  > 1 .and. warning_issued ) ) then
        write (NDSV,*), '  U0,     Ud,     AM,  PM,  IPp,  AMd,  IPd, si = '
        write (NDSV,*), U0, Ud, AM, PM, IPp, AMd, IPd, si

        write (NDSV,*), '    MK =  ', MK
        write (NDSV,*), '    Upi = ', Upi(1:niter) , Up
        write (NDSV,*), '   IPpi = ', IPpi(1:niter), IPp
        write (NDSV,*), '    AMi = ', AMi(1:niter) , AM
        write (NDSV,*), '    PMi = ', PMi(1:niter) , PM
        write (NDSV,*), '   AMdi = ', AMdi(1:niter), AM
        write (NDSV,*), '    si = ', sqrt( msi(1:niter) ) / (abs(MK)+0.001) * 0.5
        end if
        
      if ( niter > 0 ) then
       
        im = niter+1
        do ii=1,niter
          if ( msi(ii) > sm - 0.01 ) cycle ! Ignore insignificant difference
          write (NDSV,*) '  WARNING in w3xsmfmd, ISEA=', ISEA, &
                ': msi(',im,')/msi(',ii,')=',sm,'/',msi(ii)
          if (ii==1 ) cycle
          im = ii
          sm = msi(ii)
          end do
        
        if ( im <= niter ) then
          AM  = AMi(im)
          PM  = PMi(im)
          AMd = AMdi(im)
          PMd = PMdi(im)
          Up  = Upi(im)
          Ud  = Udi(im)
          qcr = qci(im)
          IPp = IPpi(im)
          IPd = IPdi(im)
          warning_issued = wi(im)
        
          niter = im          
          end if          
        end if
      
      if ( AMd >= AMAX ) warning_issued = .true.
          
      UdX = real(Ud)
      UdY = aimag(Ud)
      
      ! sqrt(|U_S^2|)
      rms_U = sqrt( sum(U_S(1:lenSt)**2 + V_S(1:lenSt)**2+1.e-6)/max(1,lenSt) )
      
      ! Check of the match to MK of the surface vectors:
      cit = abs ( MK - ( Up * IPp + Ud * IPd ) ) / ( abs(MK) + 0.01 )
      
      ! Scatter index of the fit; si = sqrt(|(U_S - U_fit)^2|)/sqrt(|U_S|^2)
      si = sqrt( sm ) / rms_U

      niter = max(niter,1)
      si = min(si, 0.99)
      qcr =  min(qcr, 0.9)
      
      ITSIC = niter * 1000. &
                   + int(qcr*100.) &
                   + int(100.*si)

      if ( xsmf_verbose == 0 .and. .not. warning_issued ) return

      ! Ignore deviations warnings in calm sea
      if ( abs(U0) + abs(MK) < 0.02 ) return
      
      if ( .not. ( AM > AMIN .and. 3.*PM >= PMs+PMIN .and. AMd >= AMINd ) ) then
        write (NDSV,*) '  WARNING in w3xsmfmd: Very small AM, PM, or AMd'
        warning_issued = .true.
        end if

      if ( .not. ( AM < AMAX .and. AMd < AMAX .and. PM <= 2.*PMs ) ) then
        write (NDSV,*) '  WARNING in w3xsmfmd: Very large AM, PM, or AMd'
        warning_issued = .true.
        end if

      if ( .not. abs(Ud) < abs(U0) + abs(MK) ) then
        write (NDSV,*), '  WARNING in w3xsmfmd:', &
                ' Strong secondary Stokes drift |Ud| > |U0| + |MK|'
        warning_issued = .true.
        end if

      if ( xsmf_verbose > 1 .or. warning_issued ) then
!/DIST        ISEA       = IAPROC + (JSEA-1)*NAPROC
!/SHRD        ISEA       = JSEA
        write (NDSV,*) '  ISEA=', ISEA, ', niter=',niter
        write (NDSV,*) '    KsD, AM, PM, AMd = ', KsD, AM, PM, AMd
        write (NDSV,*) '    |U0|,   |Ud|,   |MK|,   IPd,   IPp ='
        write (NDSV,*) abs(U0), abs(Ud), abs(MK), IPd, IPp
        end if

      end subroutine MH_fit


      subroutine fit_expr(numD,log_KZ,Um,AM,PM,Um_min,fit_kind,P0,A0)

      !  Determine AM, PM as a best fit of an expression
      !  Ufit = Um(1) exp(-AM * KZ**PM) to a profile Um(KZ).
      implicit none

      integer, intent(in)         :: numD
      real, intent(in)            :: log_KZ(:)
      real, intent(in)            :: Um(:)
      real, intent(inout)         :: AM, PM, Um_min
      character(len=5), intent(in):: fit_kind
      real, intent(in), optional  :: P0
      real, intent(in), optional  :: A0

      real, allocatable, save     :: loglog_ref(:), log_Um(:)
      integer, allocatable, save  :: fqc(:)
      real                        :: log_Up, log_AM, log_Um_min, logAM0, amx, amn
      integer                     :: ii

      integer                     :: XSNDe, numDe

      if ( .not. allocated(loglog_ref) ) allocate( loglog_ref(XSNDeep), stat=ii )
      if ( .not. allocated(log_Um) )     allocate( log_Um(XSNDeep), stat=ii )
      if ( .not. allocated(fqc) )     allocate( fqc(XSNDeep), stat=ii )

      numDe = numD
      XSNDe = XSND
      if ( index(fit_kind,'deep') > 0 ) then
        ! Extend the profile to fit if it is shorter than XKZ**(log(3.)/log(XKZ))
        XSNDe = XSNDeep
        if (numD == XSND) numDe = XSNDe
      else if ( index(fit_kind,'upper') > 0 ) then
        ! Limit the profile to fit if it is deeper than XKZ**(log(1.5)/log(XKZ))
        XSNDe = min(XSNUpper,XSND)
        numDe = min(XSNUpper,numDe)
      end if
      
      ! Quality counter = 1 for the depths that are ignored in the fit
      fqc = 0
      
      ! Profile model:
      ! Ufit = Um(1) * exp (-AM * KZ**PM)

      ! Regression shape valid for KZ > 0:
      ! log_Um = -log( Um/Um(1) ) ~ AM * KZ**PM

      ! Reference shape:
      ! log_ref(2:numD) = AM * KZ(2:numD)**PM
      ! The log of log_Um is linear in log_KZ:
      if ( present(A0) ) AM = A0 ! Best fit of PM, only, given AM=A0
      if ( present(P0) ) PM = P0 ! Best fit of log_AM, only, given PM=P0
      
      logAM0 = log(AM)
      loglog_ref(2:XSNDe) = logAM0 + PM * log_KZ(2:XSNDe)
      
      log_Um_min = log(Um_min)

      where ( Um > Um_min )
        log_Um = -log( Um/Um(1) )
      elsewhere
        ! Avoid depths of near negative speed:      
        log_Um = log_Um_min
        ! Register the depths that are ignored
        fqc = 1
        end where
      
      ! Set dummy values at the surface and below the sea floor (numD+1:XSND)
      ! (not to be used in lin_reg)
      loglog_ref(1) = loglog_ref(2) - 1.
      log_Um(1) = exp(loglog_ref(1))
      log_Um(numDe+1:XSNDe) = exp(loglog_ref(numDe))
      
      ! First, avoid the smallest (possibly negative) values of log_Um: 
      where ( log_Um < log_Um(1) )
        log_Um = log_Um(1)
        fqc = 1
        end where

      ! Take the logarithm again to attain a linear form
      log_Um(2:numD) = log( log_Um(2:numD) )
      ! Dummy values at the surface and below the sea floor
      log_Um(1) = loglog_ref(1)
      log_Um(numD+1:XSNDe) = loglog_ref(numD+1:XSNDe)
      
      ! Avoid depths where Um is not decreasing like 'in the vicinity of'
      ! the reference shape Um(1) * exp(-AM * KZ**PM)

      where ( log_Um < loglog_ref - 1. )
        log_Um = loglog_ref - 1.
        fqc = 1
        end where      
      ! where ( log_Um < 1/e*log_ref )
        
      where ( log_Um > loglog_ref + 1. )
        log_Um = loglog_ref + 1.
        fqc = 1
        end where
      ! where ( log_Um > e*log_ref )

      if ( index(fit_kind,'deep') > 0 ) then
        amx = PMAXd
        amn = PMINd
      else
        amx = PMAX
        amn = PMIN
        end if
      ! Linear regression fit
      if (xsmf_verbose > 2 ) write (NDSV,*), '  lin_reg () ... '
      if ( present(A0) ) then
         ! Best fit of PM, only, given AM=A0
         log_AM=log(A0)
         call lin_reg1( log_Um(2:numDe), log_KZ(2:numDe), PM, log_AM)
      else if ( present(P0) ) then
         ! Best fit of log_AM, only, given PM=P0
         call lin_reg0( log_Um(2:numDe), log_KZ(2:numDe), P0, log_AM)
      else
         ! Linear regression best fit PM, log_AM
         call lin_reg( log_Um(2:numDe), log_KZ(2:numDe), PM, log_AM, amn, amx)
        end if

      ! Number of depths that do not go into the fitting. Returned in Um_min
      Um_min = real(sum(fqc(2:numD)))
      
      if ( .not. present(A0) ) AM = exp(log_AM)

      end subroutine fit_expr

      
      subroutine fit_proj(AM,PM,log_KZ,Umr,lenSt,qcr,fit_kind,P0)
        implicit none
        real, intent(inout)         :: AM,PM,qcr
        real, intent(in)            :: log_KZ(:), Umr(:)
        integer, intent(in)         :: lenSt
        character(len=5), intent(in):: fit_kind
        real, intent(in), optional  :: P0
        real                        :: Umr_min, tmp
        integer                     :: ii, nneg, numPos

        if (present(P0)) then
           call fit_expr(lenSt,log_KZ,Umr,AM,PM,qcr,fit_kind,P0)
           return
        end if
        
!/      Determine the upper range of depths where Umr has positive values.
!/      There must be no more than 0.2 * lenSt negative or near zero values counted from above
        Umr_min = qcr
        nneg = int(0.2 * lenSt)
        do ii = 1,lenSt
          if  (Umr(ii) < Umr_min ) then
            nneg = nneg - 1
            if ( nneg == 0 ) then
              exit
              end if
            else
            numPos = ii
            end if
          end do
                
        if (numPos < 4 ) then
          if (numPos > 1 ) then
            PM=PMs
            call fit_expr(numPos,log_KZ,Umr,AM,PM,qcr,fit_kind,PM)
            ! Fraction of depths that do not go into the fitting:
            qcr = ( qcr + (lenSt - numPos) ) / lenSt
            end if
        else
!/      Determine AM, PM as the best fit of the profile, given the surface
!/      drift Up. Although Umr(1) is always positive, any of Umr(2:numPos)
!/      might be negative. fit_expr will first exchange negative or near-zero
!/      values with the previous (input) profile. The number of these is
!/      returned in the argument qcr. The input value of qcr is the minimum
!/      threshold value
          call fit_expr(numPos,log_KZ,Umr,AM,PM,qcr,fit_kind)
          qcr = ( qcr + (lenSt - numPos) ) / lenSt
          
          ! Limiters to PM
          if ( index(fit_kind,'deep') == 0 &
               ! .and. ( 2.*PM > PMAX+PMs .or. 2.*PM < PMs+PMIN) ) then
               .and. ( 2.*PM > PMAX+PMs .or. 2.*PM < 3.*PMIN) ) then
            if (2.*PM > PMAX+PMs) then
              tmp = PMAX-PMs
              PM = PMAX - tmp/(2.*(PM-PMs)/tmp + 1.)
            else
              tmp = PMIN
              PM = PMIN * (1. + 1./(5.-2.*PM/PMIN))              
              !tmp = PMs-PMIN !PMIN
              !PM = PMIN + tmp/(2.*(PMs-PM)/tmp + 1.)
              end if
            tmp = Umr_min
            ! Best fit value of AM given the new PM
            call fit_expr(numPos,log_KZ,Umr,AM,PM,tmp,fit_kind,PM)
            return
            end if

          end if ! numPos < 4

        if ( index(fit_kind,'deep') > 0 ) return
        
        ! Limiters to AM
        if ( AM < AMIN .or. 2. * AM > AMAX+AMs ) then
          if ( AM < AMIN ) then
            AM = AMIN
          else
            tmp = AMAX-AMs
            AM = AMAX - tmp/(2.*(AM-AMs)/tmp + 1.)
            end if
          tmp = Umr_min
          ! Best fit value of PM given the new AM
          call fit_expr(numPos,log_KZ,Umr,AM,PM,tmp,fit_kind,PM,AM)
          end if
      
      end subroutine fit_proj

      
      subroutine Ud_cap(Ud,Up,U0,Us,capped)
        ! Limiter to the magnitude of Ud. We presume that U0 = Up + Ud
        implicit none
        complex, intent(inout)  :: Ud,Up
        complex, intent(in)     :: U0,Us
        logical,optional,intent(out) :: capped
        real                    :: tmp
        complex                 :: Uds, unit
        logical                 :: iscapped

        iscapped = .False.
        Uds = Ud+Us-U0
        !if ( 2.*abs(Ud) > abs(Up) ) then
        if ( abs(Uds) > abs(Us) ) then
          ! We presume U0 = Up + Ud
          unit = Us/abs(Us)
          ! Projection of Ud+Us-U0 in the direction of Us
          tmp = real(Uds) * real(unit) + aimag(Uds) * aimag(unit)
          
          if ( tmp < 0. ) then
            ! Shift Ud in the direction of Us so that Ud and Us become
            ! perpendicular. If |Uds|>|Us| reduce to |Us|
            Uds = Uds - (tmp/abs(Us))*Us
            Ud = Uds*min(1.,abs(Us)/abs(Uds)) - (Us-U0)
            Up = U0 - Ud
            iscapped = .True.
          
          else ! if ( abs(Ud) > abs(Up) ) then
            ! Shift Ud in the direction of -U0 so that it's projection
            ! on U0 becomes 0.5*U0. If |Uds|>|Us| reduce to |Us| 
            Uds = Uds - (tmp/abs(Us) - 0.5)*Us
            Ud = Uds*min(1.,abs(Us)/abs(Uds)) - (Us-U0)
            Up = U0 - Ud
            iscapped = .True.
          end if
        end if
        if ( present(capped) ) capped = iscapped
      end subroutine Ud_cap

      subroutine S_span(Ut,Zt)
        implicit none
        complex, intent(out)    :: Ut
        integer, intent(inout)  :: Zt
        real                    :: us0,vs0,d20,d21
        integer                 :: ii
        us0 = U_S(1)
        vs0 = V_S(1)
        d20 = 0.
        do ii = 2, Zt
           d21 = (U_S(ii)-us0)**2 + (V_S(ii)-vs0)**2
           if ( d20 > d21 ) exit
           d20 = d21
           end do
        if ( d20 /= d21 ) Zt = ii - 1
        ! Zt = maxloc( (us0-U_S(2:Zt))**2 + (vs0-V_S(2:Zt))**2 )(1) + 1
        Ut = cmplx( us0-U_S(Zt), vs0-V_S(Zt) )

      end subroutine S_span

      real function calc_msd( Up, Ud, Pp, Pd, lenSt)

      ! Mean of squares of modulus deviation between a profile U_S, V_S
      ! and a parametric fit Up * Pp + Ud * Pd
      implicit none
      complex, intent(in)               :: Up, Ud
      real, dimension(:), intent(in)    :: Pp, Pd
      integer, intent(in)               :: lenSt
      real, allocatable, save           :: Um(:)
      real                              :: tmp
      integer                           :: ii
      
      if ( .not. allocated(Um) )  allocate( Um(XSND), stat=ii )      
 
      Um(2:lenSt) = ( U_S(2:lenSt) - real(Up) * Pp(2:lenSt)     &
                       - real(Ud) * Pd(2:lenSt) )
      tmp = sum( Um(2:lenSt) * Um(2:lenSt) * DZK_S(2:lenSt) )
      Um(2:lenSt) = ( V_S(2:lenSt) - aimag(Up) * Pp(2:lenSt)    &
                       - aimag(Ud) * Pd(2:lenSt) )     
      tmp = tmp + sum( Um(2:lenSt) * Um(2:lenSt) * DZK_S(2:lenSt) )
      calc_msd = tmp / ZK_S(lenSt)
      
      end function calc_msd
      
        
      subroutine swap_r(xr,yr)
      implicit none
      real, intent(inout)         :: xr, yr
      real                        :: tmp

      tmp = xr; xr = yr; yr = tmp

      end subroutine swap_r
      
      subroutine swap_c(xc,yc)
      implicit none
      complex, intent(inout)      :: xc, yc
      complex                     :: tmp

      tmp = xc; xc = yc; yc = tmp

      end subroutine swap_c


      subroutine lin_reg0( yy, xx, a0, bb)
      ! Find the y-intercept (bb) of
      ! yf = a0 * xx + bb, where ||yy - yf|| is a minimum
      IMPLICIT NONE
      real, intent(in)            :: yy(:), xx(:)
      real, intent(in)            :: a0
      real, intent(out)           :: bb
     
      integer :: lenArr

      lenArr =  float(size(yy))

      bb = sum(yy) / lenArr - a0 * ( sum(xx) / lenArr )

      end subroutine lin_reg0


      subroutine lin_reg1( yy, xx, aa, b0)
      ! Find the slope (aa) of
      ! yf = aa * xx + b0, where ||yy - yf|| is a minimum
      IMPLICIT NONE
      real, intent(in)            :: yy(:), xx(:)
      real, intent(out)           :: aa
      real, intent(in)            :: b0
     
      integer :: lenArr

      lenArr =  float(size(yy))

      aa = ( sum(yy) - b0 * lenArr ) / sum(xx)

      end subroutine lin_reg1


      subroutine lin_reg( yy, xx, aa, bb, amn, amx )
      ! Find the slope (aa) and y-intercept (bb) of
      ! yf = aa * xx + bb, where ||yy - yf|| is a minimum

      IMPLICIT NONE
      real, intent(in)            :: yy(:), xx(:)
      real, intent(in)            :: amn, amx
      real, intent(out)           :: aa, bb
      real :: sumx, sumy, xave, yave, ad, ax

      integer :: KD_num, ii, lenArr
      
      lenArr =  float(size(yy))

      sumx = sum(xx)
      sumy = sum(yy)
      xave = sumx / lenArr
      yave = sumy / lenArr

      ! Find the slope (aa)
      aa = (dot_product(xx,yy) - sumx*yave)
      ad = (dot_product(xx,xx) - sumx*xave)
      ax = amx * ad
      if ( ax > aa .and. amn * ad < aa ) then
        ! aa is between min and max
        aa = aa / ad
      else if ( ax > aa ) then
        aa = amn 
      else
        aa = amx
        end if
      
      ! y-intercept (bb)
      bb = yave - aa*xave

      end subroutine lin_reg      

      real function IP_calc( KsD, AM, PM )
        !
        ! The integrated, normalized pseudo-momentum of the parameterized
        ! profile has the mathematical form, in the limit of infinitesimal depth
        ! increments,
        !   IP = \int_0^KsD exp(- AM * KZ^PM ) dKZ,
        ! where D is the local depth and Ks=KsD/D is an integral wave number.
        !
        ! This can be reformulated, substituting X = AM * KZ^PM,
        !   IP = q AM^{-q} \int_0^u X^{q-1} exp(-X) dX,
        ! where q = 1/PM and u = AM * KsD^PM
        ! The integral is an incomplete gamma function gammainc(q,u), and thus
        !   IP = AM^{-q} q gammainc(q,u)
        !
        IMPLICIT NONE
        REAL, intent(in)            :: KsD, AM, PM
        real                        :: q, u

        q = 1./PM
        u = AM * KsD**PM

        IP_calc = q / AM**q * gammain(q,u)

      end function IP_calc

      real function gammain( q, u )

        ! The incomplete gamma function P(q,u) multiplied by Gamma(q).
        !
        ! Weighted average of four approximate functions depending on the water
        ! depth, or more precisely, depending on the value of xc = u / (q + 1.)
        !
        ! Let xcm < xci < xct < xcd < xca with xcm >~ 0.4, xct ~ 4*xcm:
        !
        ! 1) 0.0 <= xc < xci : use a series representation, function gi()
        !                        (shallow and transitional water waves)
        ! 2) xcm <= xc < xcd   : Continued fraction factor, function GammaincG()
        !                        (transitional and deep water waves)
        ! 3) xct <= xc < xca   : Gamma(q) - u**(q-1) * exp(-u)
        !                        (deep water)
        ! 4) xca <= xc         : Gamma(q)
        !                        (most of the deep ocean)
        
        IMPLICIT NONE
        real, intent(in)             :: q, u
        real                         :: numit=0.
        real                         :: xc, xce, xcm, xca, xcd
        real                         :: GmA, gammainG, wP
        ! Number of powers in series, function gi():
        integer                      :: nmP

        xc = u/(q + 1.)

        ! Shallow and transitional water thresholds
        !
        ! A requirement in Numerical Recipes function gcf(a,x) is that
        ! xc > (q-1)/(q+1). Similarly we apply an asymptotic formula
        ! gammainc -> Gamma(q) - u**(q-1) * exp(-u) for xc > xcm =
        ! max(0.4, (q-0.8)/(q+1))+0.4
        ! We apply a power series gi(u) when xc <= xcd = 2.0 + xce, where        
        xce = max ( 0., (q - 0.8)/(q + 1.) - 0.4 )
        ! The two formulas are linearly ramped in the interval xcm < xc <= xcd
        
        ! Shallow water threshold
        xcm = 0.8 + xce

        if ( xc >= xcm ) then
           ! (transitional shallow and deep water waves)
           GmA = exp( GAMMLN(q) )
        end if
        
        ! very deep water threshold
        xca = 3.0 + xce
        
        if ( xc >= xca ) then
           ! asymptotic value for xc -> infinity (very deep water)
           gammain = GmA
           ! For very deep water waves we are finished
           return
        end if
        
        ! Intermediate water
        if ( xc > xcm ) then
           gammain = GmA - u**(q-1) * exp(-u) * (xca-xc)/(xca-xcm)
           ! W = (xca-xc)/(xca-xcm); W->0 as xc -> xca; W -> 1 as xc -> xcm

           ! Intermediate to deep water threshold
           xcd = 2.0 + xce
        
           ! For moderate deep water waves we are finished
           if ( xc > xcd ) return
        end if

        ! Shallow and intermediate water
        ! Power series in u, truncated after maximally nmP terms
        nmP = int(10. * (xc + 1.)*(u/100.**(1./q)+2.)) ! Suits u in [0.1;100]
        gammainG = giGR(q, u, nmP)
        
        if ( xc > xcm ) then
           ! (transitional from shallow to deep water waves)
           wP = (xcd-xc)/(xcd-xcm)
           ! wP -> 0 as xc -> xcd; wP -> 1 as xc -> xcm
           gammain = gammainG * wP + gammain * (1. - wP)
        else
           ! xc <= xcm: Asymptotic as xc -> 0
           ! (shallow water waves)
           gammain = gammainG
        end if

      end function gammain
      
      real FUNCTION giGR(q,u,nm)
        !
        ! The incomplete gamma function, power series representation for small
        ! values of u / (q + 1.), to power nm
        !
        ! G&R: Gradshteyn and Ryzhik: Table of integrals, series and products,
        ! Academic Press 1980
        !
        ! Apply G&R 8.354.1, with al=q-1, x=u:
        !           gi(al,x) = sum_{n=0}^nm (-1)**n * frac{x^(al+n)}{n!*(al+n)}
        !                    = x^al * sum_{n=0}^nm (-1)**n * frac{x^n}{n!*(al+n)}
        !
        ! G&R 8.356.1: gi(al + 1, x) = al * gi(al,x) - x**al * exp(-x)

        IMPLICIT NONE
        REAL, intent(in)         :: q, u
        integer, intent(in)      :: nm
        integer                  :: n
        real                     :: al, dn, tn, sm, xt, tni, eps=0.001

        if ( q < 1.001 ) then
           ! Max steps in GammaincG:
           n = 4. + 10. * (q + 1.) / u
           giGR=GammaincG(q,u,n)
           return
        end if
        
        al = q - 1.

        dn = al
        tn = 1.
        sm = 0.
        xt = -u
        tni=tn/dn
        do n = 1,nm
           sm = sm + tni
           ! Exit loop when converged
           if ( abs(tni) < eps*sm) exit
           tn = tn * xt/n
           dn = dn + 1.
           tni=tn/dn
        end do

        ! Check convergence
        if (abs(tni) > eps*sm) then
           WRITE (NDSV, *), 'WARNING in w3xsmfmd function giGR: ', \
           'max number of terms (', nm, ') too small for q=', q, 'u=', u
        
            do n = nm,2*nm
               sm = sm + tni
               ! Exit loop if converged
               if ( abs(tni) < eps*sm) then
                  WRITE (NDSV, *), ' - Sufficient number of terms: ', n
                  exit
               end if
               tn = tn * xt/n
               dn = dn + 1.
               tni=tn/dn
            end do            
        end if
        
        giGR = ( al * sm  - exp(-u) ) * u**al

      end FUNCTION giGR

      real FUNCTION GAMMLN(XX)
        ! A routine from Numerical Recipes

        IMPLICIT NONE
        REAL, intent(in)             :: XX
        REAL*8 X,TMP,SER

        REAL*8, dimension(6) :: COF = (/76.18009173, -86.50532033, 24.01409822,&
                                     -1.231739516, .120858003E-2,-.536382E-5 /)
        REAL*8               :: STP = 2.50662827465D0
        REAL*8               :: HALF = 0.5D0, ONE = 1.0D0, FPF = 5.5D0

        INTEGER              :: J

        X = XX - ONE
        TMP = X + FPF
        TMP = ( X + HALF ) * LOG(TMP) - TMP
        SER = ONE
        DO J = 1,6
           X = X + ONE
           SER = SER + COF(J)/X
        END DO
        GAMMLN = TMP + LOG( STP * SER )

      END FUNCTION GAMMLN

      real FUNCTION GammaincG(A,X,NUMIT)
        ! 
        ! GammaincG(A,X,GmA) = GmA*gammainc(A,X) = GmA*(1-GAMMCF(A,X))
        !                    = Gamma(A) - EXP(-X) * X**A * GCF(A,X,NUMIT)
        ! GmA == Gamma(A). The user must supply this value.
        ! GAMMCF: Continued fraction method for the complement of the
        ! incomplete gamma function. GAMMCF is the name adpted in Numerical
        ! Recipes routines

        IMPLICIT NONE
        real, intent(in)            :: A,X
        integer, intent(in)         :: NUMIT
        real                        :: Gf,GmA
        
        GmA = exp( GAMMLN(A) )
        Gf = EXP(-X + A * LOG(X))
        GammaincG = GmA - Gf * GCF(A,X,GmA/Gf,NUMIT) 
        RETURN

      END FUNCTION GammaincG

      real FUNCTION GCF(A,X,Gof,NUMIT)
        ! Continued fraction factor in complementary incomplete gamma function,
        !    GammaincG = Gamma(A) - EXP(-X) * X**A * GCF(A,X,NUMIT)
        ! Algorithm from Numerical Recipes
        IMPLICIT NONE
        real, intent(in)            :: A,X,Gof ! Gof = Gamma(A)/(EXP(-X)*X**A)
        integer, intent(in)         :: NUMIT
        real                        :: EPS = 0.00001
        real                        :: G,GOLD,A0,A1,B0,B1
        real                        :: AN,ANA,FAC,ANF
        real                        :: FPMIN
        integer                     :: N

        G=0.
        GOLD=G
        A0=1.
        A1=X
        B0=0.
        B1=1.
        FAC=1.
        FPMIN = X * 1.e-7
        
        DO N=1,NUMIT
           AN=FLOAT(N)
           ANA=AN-A
           A0=(A1+A0*ANA)*FAC
           B0=(B1+B0*ANA)*FAC
           ANF=AN*FAC
           A1=X*A0+ANF*A1
           B1=X*B0+ANF*B1
           IF ( ABS(A1) < FPMIN ) THEN
              write(ndse,*) 'ERROR in W3XSMF FUNCTION GCF: abs(A1) < ', FPMIN
              CALL EXTCDE(1)
              end if
           FAC=1./A1
           GOLD=G
           G=B1*FAC           
           ! Test convergence of Gi = GmA - Gf * G:
           ! Gi > 0 and abs((Gi - GiOLD)/GiOLD) < eps, equivalent to:
           if ( abs(G-GOLD) < EPS*(Gof - GOLD) ) exit
        END DO
        
        GCF=G
        
        IF ( N == NUMIT .and.  xsmf_verbose > 1 ) &
           write (NDSV, *), 'WARNING in w3xsmfmd function GCF: ', &
           'number of iterations (', NUMIT, ') too small for A=', A, 'X=', X


      END FUNCTION GCF

      END MODULE W3XSMFMD
