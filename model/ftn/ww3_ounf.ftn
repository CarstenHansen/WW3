#include "w3macros.h"
#define CHECK_ERR(I) CHECK_ERROR(I, __LINE__)
!/ ------------------------------------------------------------------- /
      PROGRAM W3OUNF
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           F. Ardhuin              |
!/                  |           M. Accensi              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         07-Oct-2019 |
!/                  +-----------------------------------+
!/
!/    17-Mar-2010 : Creation                            ( version 3.14_SHOM )
!/    07-Nov-2011 : Debug for spectral output on UNST   ( version 4.04 )
!/    13-Mar-2012 : Update of NC attributes             ( version 4.04 )
!/    02-Apr-2013 : New structure of output fields.     ( version 4.10 )
!/    02-Jul-2013 : Bug correction for lat in unst grid ( version 4.11 )
!/    02-Nov-2013 : Removes unnecessary IDFM            ( version 4.12 )
!/    30-Apr-2014 : Correct group3 freq dim.            ( version 5.00 )
!/    23-May-2014 : Adding ice fluxes to W3SRCE         ( version 5.01 )
!/    14-Oct-2014 : Keep the output files opened        ( version 5.01 )
!/    27-Aug-2015 : ICEH and ICEF added as output       ( version 5.10 )
!/    10-Jan-2017 : Changes for US3D and USSP output    ( version 6.01 )
!/    01-May-2017 : Adds directional MSS parameters     ( version 6.04 )
!/    01-Mar-2018 : RTD option add variable de-rotation,( version 6.02 )
!/                  standard lat-lons and rotated grid
!/                  metadata
!/    15-May-2018 : Add namelist feature                ( version 6.05 )
!/    06-Jun-2018 : Add DEBUG/SETUP                     ( version 6.04 )
!/    27-Jun-2018 : Updated to handle SMC output.       ( version 6.05 )
!/    26-Jul-2018 : Changed reading of TABIPART         ( version 6.05 )
!/    12-Sep-2018 : Added extra partitioned fields      ( version 6.06 )
!/    25-Sep-2018 : Add WBT parameter                   ( version 6.06 )
!/    28-Mar-2019 : Bugfix to NBIPART check.            ( version 6.07 )
!/    18-Jun-2020 : Support for 360-day calendar.       ( version 7.08 )
!/    07-Oct-2019 : RTD option with standard lat-lon
!/                  grid when nesting to rotated grid   ( version 7.11 )
!/    03-Nov-2020 : Moved NetCDF metadata to separate   ( version 7.12 )
!/                  module.
!/    09-Dec-2020 : Set fixed values for VARID indices  ( version 7.12 )
!/    15-Jan-2021 : Extend handling of 3'rd dimension   ( version 7.XX )
!/    15-Jan-2021 : XSTO option: Stokes drift profile   ( version 7.XX )
!/                  for extended spectral tail
!/    15-Jan-2021 : MFIT+XSTO options: Stokes drift     ( version 7.XX )
!/                  profile parametric fit
!/
!/    Copyright 2009-2013 National Weather Service (NWS),
!/       National Oceanic and Atmospheric Administration.  All rights
!/       reserved.  WAVEWATCH III is a trademark of the NWS. 
!/       No unauthorized use without permission.
!/
!  1. Purpose :
!
!     Post-processing of grid output to NetCDF files
!
!  2. Method :
!
!     Data is read from the grid output file out_grd.ww3 (raw data)
!     and from the file ww3_ounf.nml or ww3_ounf.inp (NDSI)
!     Model definition and raw data files are read using WAVEWATCH III
!     subroutines. Extra global NetCDF attributes may be read from 
!     ASCII file NC_globatt.inp.
!
!     Output types :
!      4 : NetCDF files
!
!  3. Parameters :
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3NMOD    Subr. W3GDATMD Set number of model.
!      W3SETG    Subr.   Id.    Point to selected model.
!      W3NDAT    Subr. W3WDATMD Set number of model for wave data.
!      W3SETW    Subr.   Id.    Point to selected model for wave data.
!      W2NAUX    Subr. W3ADATMD Set number of model for aux data.
!      W3SETA    Subr.   Id.    Point to selected model for aux data.
!      ITRACE    Subr. W3SERVMD Subroutine tracing initialization.
!      STRACE    Subr.   Id.    Subroutine tracing.
!      NEXTLN    Subr.   Id.    Get next line from input filw
!      EXTCDE    Subr.   Id.    Abort program as graceful as possible.
!      STME21    Subr. W3TIMEMD Convert time to string.
!      TICK21    Subr.   Id.    Advance time.
!      DSEC21    Func.   Id.    Difference between times.
!      W3IOGR    Subr. W3IOGRMD Reading/writing model definition file.
!      W3IOGO    Subr. W3IOGOMD Reading/writing raw gridded data file.
!      W3EXNC    Subr. Internal Execute grid netcdf output.
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!     None, stand-alone program.
!
!  6. Error messages :
!
!     Checks on input, checks in W3IOxx.
!
!  7. Remarks :
!
!     The VARID array stores netCDF variable IDs for all variables in
!     file. The first 20 elements are reserved for dimension/auxiliary
!     variables as defined below:
!
!       Index     Variable
!       =====     ========
!         1       Lon
!         2       Lat
!         3       Time
!         4       Tri (UGRD)
!         5       SMC CX (SMC)
!         6       SMC CY (SMC)
!         7       Standard longitude (SMC/RTD)
!         8       Standard latitude (SMC/RTD)
!         9       Coordinate reference system (upcoming feature / RTD)
!        10       Freq (extradim)
!        11       Forecast period (upcoming feature)
!        12       Forecast reference time (upcoming feature)
!        13-19    [Reserved for future use]
!        20       MAPSTA
!
!    Indices 21 - 300 are for storage of field output variable IDs.
!
!  8. Structure :
!
!     See source code.
!
!  9. Switches :
!
!     !/S     Enable subroutine tracing.
!     !/XSTO  Stokes drift profile for spectrum with extended tail
!     !/MFIT  Stokes drift profile parametric fit
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
      USE CONSTANTS

!/
      USE W3WDATMD, ONLY: W3NDAT, W3SETW
      USE W3ADATMD, ONLY: W3NAUX, W3SETA
      USE W3ODATMD, ONLY: W3NOUT, W3SETO
      USE W3SERVMD, ONLY: ITRACE, NEXTLN, EXTCDE
!/S      USE W3SERVMD, ONLY : STRACE
      USE W3TIMEMD
      USE W3IOGRMD, ONLY: W3IOGR
      USE W3IOGOMD, ONLY: W3IOGO, W3READFLGRD, W3FLGRDFLAG
      USE W3INITMD, ONLY: WWVER, SWITCHES
      USE W3ODATMD, ONLY: NAPROC, NOSWLL, PTMETH, PTFCUT
!/DEBUG      USE W3ODATMD, only : IAPROC
!/
      USE W3GDATMD
!/XSTO! Comment: USE W3GDATMD, ONLY: XSND, XSDS, NK, NX, NY, NSEA, MAPSF, ...
      USE W3WDATMD, ONLY: TIME, WLV, ICE, ICEH, ICEF, BERG, UST, USTDIR
!/SETUP     USE W3WDATMD, ONLY: ZETA_SETUP
      USE W3ADATMD, ONLY: DW, UA, UD, AS, CX, CY, HS, WLM, T0M1, THM,  &
                          THS, FP0, THP0, DTDYN, FCUT,                 &
                          ABA, ABD, UBA, UBD, SXX, SYY, SXY, USERO,    &
                          PHS, PTP, PLP, PDIR, PSI, PWS, PWST, PNR,    &
                          PTM1, PT1, PT2, PEP,                         &
                          PTHP0, PQP, PSW, PPE, PGW, QP,               &
                          TAUOX, TAUOY, TAUWIX,                        &
                          TAUWIY, PHIAW, PHIOC, TUSX, TUSY, PRMS, TPMS,&
                          USSX, USSY, MSSX, MSSY, MSSD, MSCX, MSCY,    &
                          MSCD, CHARN, TWS,                            &
                          TAUWNX, TAUWNY, BHD, T02, HSIG, CGE,         &
                          T01, BEDFORMS, WHITECAP, TAUBBL, PHIBBL,     &
                          CFLTHMAX, CFLXYMAX, CFLKMAX, TAUICE, PHICE,  &
                          STMAXE, STMAXD, HMAXE, HCMAXE, HMAXD, HCMAXD,&
                          P2SMS, EF, US3D, TH1M, STH1M, TH2M, STH2M,   &
                          WN, USSP, WBT
!/XSTO! UXSP
      USE W3ADATMD, ONLY: UXSP
      USE W3ODATMD, ONLY: NDSO, NDSE, SCREEN, NOGRP, NGRPP, IDOUT,     &
                          UNDEF, FLOGRD, FNMPRE, NOSWLL, NOGE
!
      USE W3NMLOUNFMD
!
      USE W3OUNFMETAMD, ONLY: INIT_META, TEARDOWN_META, GETMETA,       &
                              WRITE_META, WRITE_GLOBAL_META,           &
                              META_T, NCVARTYPE
!
      USE NETCDF

!/SMC      USE W3SMCOMD

      IMPLICIT NONE

!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      TYPE(NML_FIELD_T)       :: NML_FIELD
      TYPE(NML_FILE_T)        :: NML_FILE
      TYPE(NML_SMC_T)         :: NML_SMC
!
      INTEGER                 :: NDSI, NDSM, NDSOG,                    &
                                 NDSTRC, NTRACE, IERR, I, I1F, I2F,    &
                                 IOTEST, NOUT,                         &
                                 IFI, IFJ, NCTYPE, IX1, IXN, IY1, IYN, &
                                 IOUT, S3, IRET, HASNC4,               &
                                 NBIPART, CNTIPART, NCVARTYPEI, IPART, &
                                 RTDNX, RTDNY
      INTEGER                 :: NFPMAX = 7 ! Depends on the hard-coded max
      INTEGER                 :: TOUT(2), TDUM(2), STOPDATE(8)
!
      INTEGER, ALLOCATABLE    :: TABIPART(:), NCIDS(:,:,:)
!
!/S      INTEGER, SAVE           :: IENT = 0
!
      REAL                    :: DTREQ, DTEST
!
      CHARACTER*30            :: STRSTOPDATE, FILEPREFIX, STRINGIPART
      CHARACTER*1024          :: FLDOUT
      CHARACTER               :: COMSTR*1, IDTIME*23, IDDDAY*11
!
      LOGICAL                 :: FLG2D(NOGRP,NGRPP), FLG1D(NOGRP),     &
                                 VECTOR, TOGETHER, FLGNML

      LOGICAL                 :: SMCGRD = .FALSE.
!/MFIT!
!/MFIT      LOGICAL                 :: SVP = .TRUE.
!/MFIT      character(len=10)       :: cmt_PMd = 'PMd = 1.30'
!/MFIT      character(len=10)       :: sMK0 = '0.01'
!/MFIT      ! real                    :: MK02 = 0.00001 ! small limiter to M2K**2
!/MFIT      real                    :: MK0 = 0.003333 ! small limiter to M2K
!/
!/ ------------------------------------------------------------------- /
!/
! 1.  IO set-up.
!
      CALL W3NMOD ( 1, 6, 6 )
      CALL W3SETG ( 1, 6, 6 )
      CALL W3NDAT (    6, 6 )
      CALL W3SETW ( 1, 6, 6 )
      CALL W3NAUX (    6, 6 )
      CALL W3SETA ( 1, 6, 6 )
      CALL W3NOUT (    6, 6 )
      CALL W3SETO ( 1, 6, 6 )
!
      NDSI   = 10
      NDSM   = 20
      NDSOG  = 20
!
      NDSTRC =  6
      NTRACE = 10
      CALL ITRACE ( NDSTRC, NTRACE )
!
!/S      CALL STRACE (IENT, 'W3OUNF')
!
      WRITE (NDSO,900)

!/SMC      SMCGRD = .TRUE.
!
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 2.  Read model definition file.
!
      CALL W3IOGR ( 'READ', NDSM )
      WRITE (NDSO,920) GNAME
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 3.  Read general data and first fields from file
!
!/DEBUG      WRITE (NDSO,*) 'Before FLOGRD(2,1)=', FLOGRD(2,1)
!/DEBUG      WRITE (NDSO,*) 'IAPROC=', IAPROC
!/DEBUG      WRITE(740+IAPROC,*) 'Calling W3IOGO from ww3_ounf'
!/DEBUG      FLUSH(740+IAPROC)
      CALL W3IOGO ( 'READ', NDSOG, IOTEST )
!
      WRITE (NDSO,930)
      DO IFI=1, NOGRP
        DO IFJ=1, NGRPP
          IF ( FLOGRD(IFI,IFJ) ) WRITE (NDSO,931) IDOUT(IFI,IFJ)
        END DO
      END DO
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 4.  Read requests from input file.
!

!
! process ww3_ounf namelist
!
      INQUIRE(FILE=TRIM(FNMPRE)//"ww3_ounf.nml", EXIST=FLGNML) 
      IF (FLGNML) THEN
        ! Read namelist
        CALL W3NMLOUNF (NDSI, TRIM(FNMPRE)//'ww3_ounf.nml', NML_FIELD, &
                        NML_FILE, NML_SMC, IERR)

! 4.1 Time setup
        READ(NML_FIELD%TIMESTRIDE, *)  DTREQ
        READ(NML_FIELD%TIMECOUNT, *)   NOUT
        READ(NML_FIELD%TIMESTART, *)   TOUT(1), TOUT(2)

! 4.2 Output fields
        FLDOUT = NML_FIELD%LIST
        CALL W3FLGRDFLAG ( NDSO, SCREEN, NDSE, FLDOUT, FLG1D,       &
                           FLG2D, 1, 1, IERR )
        IF (IERR.NE.0) GOTO 800 

! 4.3 Output type
        NCTYPE = NML_FILE%NETCDF
        NCVARTYPE = NML_FIELD%TYPE
        STRINGIPART = NML_FIELD%PARTITION
        TOGETHER = NML_FIELD%SAMEFILE
        FILEPREFIX = NML_FILE%PREFIX
        S3 = NML_FIELD%TIMESPLIT
        IF(SMCGRD) THEN
!/SMC          SMCTYPE = NML_SMC%TYPE
!/SMC          SXO = NML_SMC%SXO
!/SMC          SYO = NML_SMC%SYO
!/SMC          EXO = NML_SMC%EXO
!/SMC          EYO = NML_SMC%EYO
!/SMC          CELFAC = NML_SMC%CELFAC
!/SMC          NOVAL = NML_SMC%NOVAL
        ELSE
          IX1 = NML_FILE%IX0
          IXN = NML_FILE%IXN 
          IY1 = NML_FILE%IY0 
          IYN = NML_FILE%IYN
        ENDIF ! SMCGRD
      END IF ! FLGNML

!
! process old ww3_ounf.inp format
!
      IF (.NOT. FLGNML) THEN
        OPEN (NDSI,FILE=TRIM(FNMPRE)//'ww3_ounf.inp',STATUS='OLD',ERR=800,IOSTAT=IERR)
        REWIND (NDSI)

        READ (NDSI,'(A)',END=801,ERR=802,IOSTAT=IERR) COMSTR
        IF (COMSTR.EQ.' ') COMSTR = '$'
        WRITE (NDSO,901) COMSTR
        CALL NEXTLN ( COMSTR , NDSI , NDSE )

! 4.1 Time setup
        READ (NDSI,*,END=801,ERR=802) TOUT, DTREQ, NOUT

! 4.2 Output fields
        CALL W3READFLGRD ( NDSI, NDSO, SCREEN, NDSE, COMSTR, FLG1D,      &
                           FLG2D, 1, 1, IERR )
        IF (IERR.NE.0) GOTO 800 

! 4.3 Output type
        CALL NEXTLN ( COMSTR , NDSI , NDSE )
        READ (NDSI,*,END=801,ERR=802) NCTYPE, NCVARTYPE
        CALL NEXTLN ( COMSTR , NDSI , NDSE )
        READ (NDSI,'(A)',END=801,ERR=802) STRINGIPART
        CALL NEXTLN ( COMSTR , NDSI , NDSE )
        READ (NDSI,*,END=801,ERR=802) TOGETHER
        CALL NEXTLN ( COMSTR , NDSI , NDSE )
        FILEPREFIX= 'ww3.'
        READ (NDSI,*,END=801,ERR=802) FILEPREFIX
        CALL NEXTLN ( COMSTR , NDSI , NDSE )
        READ (NDSI,*,END=801,ERR=802) S3
        CALL NEXTLN ( COMSTR , NDSI , NDSE )

!/SMC        ! SMC output type (1 or 2)
!/SMC        READ (NDSI,*,END=801,ERR=802) SMCTYPE
!/SMC        IF(SMCTYPE .EQ. 1) THEN  ! Flat sea point output
!/SMC           CALL NEXTLN ( COMSTR , NDSI , NDSE )
!/SMC           READ (NDSI,*,END=801,ERR=802) SXO, SYO, EXO, EYO
!/SMC        ELSE IF(SMCTYPE .EQ. 2) THEN  ! Regular grid output
!/SMC           CALL NEXTLN ( COMSTR , NDSI , NDSE )
!/SMC           READ (NDSI,*,END=801,ERR=802) SXO, SYO, EXO, EYO, CELFAC
!/SMC        ENDIF
!/SMC        NOVAL = UNDEF
        IF( .NOT. SMCGRD) THEN
           READ (NDSI,*,END=801,ERR=802) IX1, IXN, IY1, IYN
        ENDIF

        CLOSE(NDSI,ERR=800,IOSTAT=IERR)

      END IF ! .NOT. FLGNML

      ! Keep track of original NCVARTYPE, as it may change
      NCVARTYPEI = NCVARTYPE
!

! 4.1 Time setup
      DTREQ  = MAX ( 0. , DTREQ )
      IF ( DTREQ.EQ.0. ) NOUT = 1
      NOUT   = MAX ( 1 , NOUT )
      CALL STME21 ( TOUT , IDTIME )
      WRITE (NDSO,940) IDTIME
      TDUM = 0
      CALL TICK21 ( TDUM , DTREQ )
      CALL STME21 ( TDUM , IDTIME )
      IF ( DTREQ .GE. 86400. ) THEN
        WRITE (IDDDAY,'(I10,1X)') INT(DTREQ/86400.)
      ELSE
        IDDDAY = '           '
      END IF
      IDTIME(1:11) = IDDDAY
      IDTIME(21:23) = '   '
      WRITE (NDSO,941) IDTIME, NOUT


! 4.2 Output fields
      DO IFI=1, NOGRP
        DO IFJ=1, NGRPP
          IF ( FLG2D(IFI,IFJ) ) THEN
            IF ( FLOGRD(IFI,IFJ) ) THEN
              WRITE (NDSO,946) IDOUT(IFI,IFJ), ' '
            ELSE
              WRITE (NDSO,946) IDOUT(IFI,IFJ), '*** NOT AVAILABLE ***'
              FLG2D(IFI,IFJ) = .FALSE.
            END IF
          END IF
        END DO
      END DO

!/MFIT      ! Write UXSP(1:3) to netCDF if not the full profile is to be written
!/MFIT      IF ( FLG2D(10,1) .AND. .NOT. FLG2D(6,13) ) THEN
!/MFIT        SVP=.False.
!/MFIT        FLG2D(6,13) = .TRUE.
!/MFIT      END IF


! 4.3 Output type
!!      NBIPART=0
!!      DO I=1,29
!!        IF ((STRINGIPART(I:I+1).EQ.'0').OR.(STRINGIPART(I:I+1).EQ.'1')      &
!!            .OR.(STRINGIPART(I:I+1).EQ.'2').OR.(STRINGIPART(I:I+1).EQ.'3')  &
!!            .OR.(STRINGIPART(I:I+1).EQ.'4').OR.(STRINGIPART(I:I+1).EQ.'5')) THEN
!!          NBIPART=NBIPART+1
!!        END IF
!!      END DO
!!      ALLOCATE(TABIPART(NBIPART))
!!      CNTIPART=0
!!      DO I=1,29
!!        IF ((STRINGIPART(I:I+1).EQ.'0').OR.(STRINGIPART(I:I+1).EQ.'1')      &
!!            .OR.(STRINGIPART(I:I+1).EQ.'2').OR.(STRINGIPART(I:I+1).EQ.'3')  &
!!            .OR.(STRINGIPART(I:I+1).EQ.'4').OR.(STRINGIPART(I:I+1).EQ.'5')) THEN
!!          CNTIPART=CNTIPART+1
!!          READ(STRINGIPART(I:I+1),'(I1)') TABIPART(CNTIPART)
!!        END IF
!!      END DO

      ! Alternative processing of TABIPART to capture requests 
      ! greater than NOSWLL (C.Bunney):
      ALLOCATE(TABIPART(NOSWLL + 1))
      NBIPART=0
      DO I=1,30
        IF(STRINGIPART(I:I) .EQ. ' ') CYCLE
        READ(STRINGIPART(I:I),'(I1)') IPART
        IF(IPART .GT. NOSWLL) THEN
           WRITE(NDSO, 1500) IPART, NOSWLL
           CYCLE
        ENDIF
        NBIPART = NBIPART + 1
        IF(NBIPART .GT. NOSWLL + 1) THEN
           GOTO 803
        ENDIF
        TABIPART(NBIPART) = IPART
      ENDDO
      
      NFPMAX = MAX(NBIPART,NFPMAX)
      ALLOCATE(NCIDS(NOGRP,NGRPP,NFPMAX))
      
!
      IF ( NCTYPE.LT.3 .OR. NCTYPE.GT.4 ) THEN
        WRITE (NDSE,1010) NCTYPE
        CALL EXTCDE ( 1 )
      END IF
      ! if NCTYPE = 4 checking that it is compiled with NC4
      HASNC4=0
!/NC4      HASNC4=1
      IF ((HASNC4 .EQ. 0).AND.(NCTYPE.EQ.4)) THEN
        WRITE (NDSE,1012)
        CALL EXTCDE ( 1 )
      END IF

!/SMC      WRITE(NDSO, 4100)
!/SMC      IF(SMCTYPE .EQ. 1) THEN  ! Flat sea point output
!/SMC        ALLOCATE(SMCMASK(NSEA))
!/SMC        ALLOCATE(SMCIDX(NSEA))
!/SMC        SMCMASK(:) = .FALSE.
!/SMC        CALL SMC_INTERP()
!/SMC        SMCNOUT = COUNT(SMCMASK)
!/SMC        NXO = SMCNOUT
!/SMC        NYO = 1
!/SMC        WRITE(NDSO, 4120) SMCNOUT
!/SMC      ELSE IF(SMCTYPE .EQ. 2) THEN  ! Regular grid output
!/SMC        ! Calculate regridding weights:
!/SMC        ALLOCATE(XIDX(NSEA), YIDX(NSEA), XSPAN(NSEA),                   &
!/SMC                 YSPAN(NSEA), WTS(NSEA), SMCIDX(NSEA))
!/SMC        CALL SMC_INTERP()
!/SMC        WRITE(NDSO, 4110) NXO, NYO, SXO, SYO, DXO, DYO
!/SMC
!/SMC        ! Allocate space for coverage array and new MAPSTA array
!/SMC        ALLOCATE(COV(NXO,NYO), MAPSMC(NXO,NYO))
!/SMC      ENDIF
!/SMC
!/SMC      ! CB: IXN and IXY are calculated by SMC_INTERP for SMC GRID
!/SMC      IX1 = 1
!/SMC      IXN = NXO
!/SMC      IY1 = 1
!/SMC      IYN = NYO
!/SMC     
!/SMC      ! Also store NXO and NYO in __local__ RTDNX and RTDNY variables.
!/SMC      ! This avoids compilation errors when the RTD switch is enabled
!/SMC      ! but the SMC switch is not. TODO: Remove this when C-preprocessor
!/SMC      ! is used in preference to switches.
!/SMC      RTDNX = NXO
!/SMC      RTDNY = NYO
!/SMC

      IF(.NOT. SMCGRD) THEN
        IX1    = MAX ( IX1 , 1 )
        IXN    = MIN ( IXN , NX )
        IY1    = MAX ( IY1 , 1 )
        IYN    = MIN ( IYN , NY )
        WRITE (NDSO,3940) IX1, IXN, IY1, IYN
      ENDIF ! SMCGRD

      VECTOR = .TRUE.
!
! 4.4 Initialise meta-data
      CALL INIT_META()
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 5.  Time management.
!
      IOUT = 0
      NCIDS(:,:,:) = 0
      WRITE (NDSO,970)


! 5.1 Loops on out_grd.ww3 to read the time and data
      DO
        DTEST  = DSEC21 ( TIME , TOUT )
        IF ( DTEST .GT. 0. ) THEN
          CALL W3IOGO ( 'READ', NDSOG, IOTEST )
            IF ( IOTEST .EQ. -1 ) THEN
              WRITE (NDSO,944)
              EXIT
            END IF
          CYCLE
        END IF
        IF ( DTEST .LT. 0. ) THEN
          CALL TICK21 ( TOUT , DTREQ )
          CYCLE
        END IF


! 5.1.1 Increments the time counter IOUT
        IOUT   = IOUT + 1
        CALL STME21 ( TOUT , IDTIME )
        WRITE (NDSO,971) IDTIME


! 5.1.2  Processes the variable value for the time step IOUT
        CALL W3EXNC ( NX, NY, IX1, IXN, IY1, IYN, NSEA, FILEPREFIX,   &
                      E3DF, P2MSF, US3DF, USSPF, NCTYPE, TOGETHER, NCVARTYPEI,&
                      FLG2D, NCIDS, S3, STRSTOPDATE )

! 5.1.3 Defines the stop date
        CALL T2D(TOUT,STOPDATE,IERR)
        WRITE(STRSTOPDATE,'(I4.4,A,4(I2.2,A),I2.2)') STOPDATE(1),'-',STOPDATE(2), &
              '-',STOPDATE(3),' ',STOPDATE(5),':',STOPDATE(6),':',STOPDATE(7) 

        CALL TICK21 ( TOUT , DTREQ )
        IF ( IOUT .GE. NOUT ) EXIT
      END DO

      CALL TEARDOWN_META()


! 5.2 Closes the netCDF file
      DO IFI=1, NOGRP
        DO IFJ=1, NGRPP
          IF (NCIDS(IFI,IFJ,1).NE.0) THEN
            IRET = NF90_REDEF(NCIDS(IFI,IFJ,1))
            CALL CHECK_ERR(IRET)
            IRET=NF90_PUT_ATT(NCIDS(IFI,IFJ,1),NF90_GLOBAL,'stop_date',STRSTOPDATE)
            CALL CHECK_ERR(IRET)
            IRET=NF90_CLOSE(NCIDS(IFI,IFJ,1))
            CALL CHECK_ERR(IRET)
          END IF ! NCIDS
        END DO ! IFJ
      END DO ! IFI
!
      ! close partition files (except part 0 which is already closed by (IFI,IFJ,1)
      IF (NOGE(4).GE.1 .AND. .NOT.TOGETHER) THEN
        IFI = 4
        DO IFJ=1, NOGE(IFI)
          DO IPART=2,NFPMAX
            IF (NCIDS(IFI,IFJ,IPART).NE.0) THEN
              IRET = NF90_REDEF(NCIDS(IFI,IFJ,IPART))
              CALL CHECK_ERR(IRET)
              IRET=NF90_PUT_ATT(NCIDS(IFI,IFJ,IPART),NF90_GLOBAL,'stop_date',STRSTOPDATE)
              CALL CHECK_ERR(IRET)
              IRET=NF90_CLOSE(NCIDS(IFI,IFJ,IPART))
              CALL CHECK_ERR(IRET)
            END IF ! NCIDS
          END DO ! IPART
        END DO ! IFJ
      END IF ! NOGE(4).GE.1 .AND. .NOT.TOGETHER

!
      GOTO 888
!
! Escape locations read errors :
!
  800 CONTINUE
      WRITE (NDSE,1000) IERR
      CALL EXTCDE ( 10 )
!
  801 CONTINUE
      WRITE (NDSE,1001)
      CALL EXTCDE ( 11 )
!
  802 CONTINUE
      WRITE (NDSE,1002) IERR
      CALL EXTCDE ( 12 )
!
  803 CONTINUE
      WRITE (NDSE,1003) NBIPART, NOSWLL
      CALL EXTCDE (13)
!
  888 CONTINUE
      WRITE (NDSO,999)
!
! Formats
!
  900 FORMAT (/15X,'   *** WAVEWATCH III Field output postp. ***   '/ &
               15X,'==============================================='/)
  901 FORMAT ( '  Comment character is ''',A,''''/)
!
  920 FORMAT ( '  Grid name : ',A/)
!
  930 FORMAT ( '  Fields in file : '/                                 &
               ' --------------------------')
  931 FORMAT ( '      ',A)
!
  940 FORMAT (/'  Output time data : '/                               &
               ' --------------------------------------------------'/ &
               '      First time         : ',A)
  941 FORMAT ( '      Interval           : ',A/                       &
               '      Number of requests : ',I10)
  944 FORMAT (/'      End of file reached '/)
  946 FORMAT ( '      ',A,2X,A)
!
 3940 FORMAT ( '      X range : ',2I7/                                &
               '      Y range : ',2I7)
!
!/SMC 4100 FORMAT (//'  SMC grid output :' /                               &
!/SMC!
!/SMC               ' --------------------------------------------------')
!/SMC 4110 FORMAT ( '   SMC to regular lat/lon grid using cell averaging' /&
!/SMC               '   Aligned output grid definition: ' /                &
!/SMC               '      NX, NY           : ', 2I8 /                     &
!/SMC               '      X0, Y0           : ', 2F8.3 /                   &
!/SMC               '      DX, DY           : ', 2F8.5 )
!/SMC 4120 FORMAT ( '   Flat seapoint dimensioned SMC output file' /       &
!/SMC               '      Num seapoints    : ',I9 )
!/SMC!
!/SMC 4130 FORMAT ( '   SMC regridding to regular lat/lon grid.' /         &
!/SMC               '   Output grid definition: ' /                        &
!/SMC               '      NX, NY           : ', 2I8 /                     &
!/SMC               '      X0, Y0           : ', 2F8.3 /                   &
!/SMC               '      DX, DY           : ', 2F8.5 /                   &
!/SMC               '      Interpolate ?    : ', L )
!
  970 FORMAT (/'  Generating files '/                                 &
               ' --------------------------------------------------')
  971 FORMAT ( '      Files for ',A)
!
  999 FORMAT (/'  End of program '/                                   &
               ' ========================================='/          &
               '         WAVEWATCH III Field output '/)
!
 1000 FORMAT (/' *** WAVEWATCH III ERROR IN W3OUNF : '/               &
               '     ERROR IN OPENING INPUT FILE'/                    &
               '     IOSTAT =',I5/)
!
 1001 FORMAT (/' *** WAVEWATCH III ERROR IN W3OUNF : '/               &
               '     PREMATURE END OF INPUT FILE'/)
!
 1002 FORMAT (/' *** WAVEWATCH III ERROR IN W3OUNF : '/               &
               '     ERROR IN READING FROM INPUT FILE'/               &
               '     IOSTAT =',I5/)
!
 1003 FORMAT (/' *** WAVEWATCH III WERROR IN W3EXNC : '/              &
               '     OUT OF RANGE REQUEST FOR NBIPART =',I2, /        &
               '     MAX SWELL PARTITIONS (NOSW) =',I2 /)
!
 1010 FORMAT (/' *** WAVEWATCH III ERROR IN W3OUNF : '/               &
               '     ILLEGAL TYPE, NCTYPE =',I4/)
 1012 FORMAT (/' *** WAVEWATCH III ERROR IN W3OUNF : '/               &
               '     NCTYPE = 4 BUT NOT COMPILED WITH NC4'/)
!
 1500 FORMAT (/' *** WAVEWATCH III WARNING IN W3EXNC : '/             &
               '     IGNORING REQUEST FOR IPART =',I2, /              &
               '     MAX SWELL PARTITIONS (NOSW) =',I2 /)
!
!/
!/ Internal subroutine W3EXNC ---------------------------------------- /
!/
      CONTAINS
!/ ------------------------------------------------------------------- /
      SUBROUTINE W3EXNC ( NX, NY, IX1, IXN, IY1, IYN, NSEA,             &
                          FILEPREFIX, E3DF, P2MSF, US3DF, USSPF,NCTYPE, &
                          TOGETHER, NCVARTYPEI, FLG2D, NCIDS, S3, STRSTOPDATE )
!/
!/                  +-----------------------------------+
!/                  |           F. Ardhuin              |
!/                  |           M. Accensi              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         14-Oct-2014 |
!/                  +-----------------------------------+
!/
!/    17-Mar-2010 : Creation                            ( version 3.14_SHOM )
!/    28-Feb-2013 : New option for float output         ( version 4.08 )
!/    02-Apr-2013 : New structure of output fields.     ( version 4.09 )
!/    12-Apr-2013 : Allows curvilinear grids            ( version 4.10 ) 
!/    30-Apr-2014 : Correct group3 freq dim.            ( version 5.00 )
!/    23-May-2014 : Adding ice fluxes to W3SRCE         ( version 5.01 )
!/    14-Oct-2014 : Keep the output files opened        ( version 5.01 )
!/    03-Nov-2020 : NetCDF metadata moved to separate   ( version 7.12 )
!/                  module.
!/    09-Dec-2020 : Set fixed values for VARID indices  ( version 7.12 )
!/
!  1. Purpose :
!
!     Perform actual grid output in NetCDF file.
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       NX/Y    Int.  I  Grid dimensions.
!       IX1/IXN Int.  I  Grid indexes along X
!       IY1/IYN Int.  I  Grid indexes along Y
!       NSEA    Int.  I  Number of sea points.
!     ----------------------------------------------------------------
!
!     Internal parameters
!     ----------------------------------------------------------------
!       NTIM    Int.  Output time counter, saved. Initial value == 1
!       ! C Hansen: FLTWO FLDIR are obsolete
!       ! FLTWO   Log.  Flags for two-dimensional field X Y.
!       ! FLDIR   Log.  Flags for two-dimensional, directional field.
!       FLFRQ   Log.  Flags for frequency array (3D field)
!       X1, X2, XX, XY, XK, XXK, YYK
!               R.A.  Output fields
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      STRACE    Subr. W3SERVMD Subroutine tracing.
!      EXTCDE    Subr.   Id.    Abort program as graceful as possible.
!      W3S2XY    Subr.   Id.    Convert from storage to spatial grid.
!      PRTBLK    Subr. W3ARRYMD Print plot of array.
!      OUTA2I    Subr.   Id.    Print array of INTEGERS.
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!     Main program in which it is contained.
!
!  6. Error messages :
!
!       None.
!
!  7. Remarks :
!
!     - Note that arrays CX and CY of the main program now contain
!       the absolute current speed and direction respectively.
!
!  8. Structure :
!
!     See source code.
!
!  9. Switches :
!
!       !/S  Enable subroutine tracing.
!       !/T  Enable test output.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
      USE W3SERVMD, ONLY : W3S2XY
!/RTD      USE W3SERVMD, ONLY : W3THRTN, W3XYRTN, W3EQTOLL
      USE W3ARRYMD, ONLY : OUTA2I, PRTBLK
      USE W3GDATMD, ONLY : SIG, GTYPE, FLAGLL, MAPSTA, MAPST2
      USE W3GDATMD, ONLY : NK, UNGTYPE, MAPSF, NTRI, CLGTYPE, RLGTYPE, &
                           XGRD, YGRD, SX, SY, X0, Y0, XYB, TRIGP, USSP_WN
!/RTD ! Rotated pole data from the mod_def file
!/RTD      USE W3GDATMD, ONLY : POLAT, POLON, FLAGUNR, AnglD
!/T      USE W3ODATMD, ONLY : NDST
!/XSTO      USE W3ODATMD, ONLY : NZO
      USE NETCDF
      IMPLICIT NONE

!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      INTEGER, INTENT(IN)     :: NX, NY, IX1, IXN, IY1, IYN, NSEA,     &
                                 E3DF(3,5), P2MSF(3), US3DF(3),        & 
                                 USSPF(2), NCTYPE, NCVARTYPEI
      CHARACTER(30)           :: FILEPREFIX
      LOGICAL, INTENT(IN)     :: TOGETHER
      LOGICAL, INTENT(IN)     :: FLG2D(NOGRP,NGRPP)
      INTEGER, INTENT(INOUT)  :: NCIDS(NOGRP,NGRPP,NFPMAX), S3
      CHARACTER*30,INTENT(IN) :: STRSTOPDATE
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      INTEGER                 :: IFI, IFJ, MFILL, I, J, ISEA, IX, IY,  &
                                 I1, J1, IPART, INDEXIPART
      INTEGER, SAVE           :: NTIM = 1
      INTEGER                 :: S1, S2, S4, S5, NCID, OLDNCID,        & 
                                 MAPSTAOUT, NDSDAT,                    &
                                 NFIELD, IRET, IK, EXTRADIM, IVAR,  &
                                 IVAR1, IDVAROUT, NCVARTYPE
      INTEGER                 :: NCJID, IFP, NFP
      INTEGER                 :: N3, TDIM, EDIM, DIMID3
      INTEGER                 :: DIMID(6), VARID(300), START(4),       &
                                 COUNT(4), DIMLN(6), DIMFIELD(4),      &
                                 STARTDATE(8), CURDATE(8), REFDATE(8)
      ! C Hansen: Commented out MAP and MP2 not used anywhere.
      !                           MAP(NX+1,NY), MP2(NX+1,NY)
!
!/NC4    INTEGER                  :: DEFLATE=1
!/S      INTEGER, SAVE           :: IENT   =   0
!
      INTEGER, ALLOCATABLE    :: TRIGP2(:,:)
      ! Make the below allocatable to avoid stack overflow on some machines 
      INTEGER(KIND=2), ALLOCATABLE    :: MX1(:,:), MXX(:,:), &
                                         MXY(:,:), MAPOUT(:,:)
!
      REAL                    :: CABS, UABS, MFILLR
!/BT4   REAL, PARAMETER            :: LOG2=LOG(2.)
!
!/XSTO      INTEGER                            :: IZ
!/XSTO      REAL                               :: XZK, zki
      REAL,DIMENSION(:),  ALLOCATABLE    :: LON, LAT, DIM3VAR
      REAL,DIMENSION(:,:),  ALLOCATABLE  :: LON2D, LAT2D, ANGLD2D
!/RTD      REAL,DIMENSION(:,:),  ALLOCATABLE  :: LON2DEQ, LAT2DEQ
      ! Make the below allocatable to avoid stack overflow on some machines 
      REAL, ALLOCATABLE       :: X1(:,:), X2(:,:), XX(:,:), XY(:,:),   &
                                 XK(:,:,:), XXK(:,:,:), XYK(:,:,:)
!
      DOUBLE PRECISION        :: OUTJULDAY
      DOUBLE PRECISION        :: SXD, SYD, X0D, Y0D
!      
      CHARACTER*120           :: STR2
      CHARACTER*512           :: PARTCOM
      !CHARACTER*30            :: UNITVAR(3),FORMAT1
      CHARACTER*30            :: FORMAT1
      CHARACTER*30            :: STRSTARTDATE
      CHARACTER               :: FNAMENC*50
      ! C Hansen: Commented out obsolete FORMF
      ! CHARACTER               :: FORMF*11
      CHARACTER, SAVE         :: OLDTIMEID*16 = '0000000000000000'
      CHARACTER, SAVE         :: TIMEID*16 = '0000000000000000'
!
      CHARACTER*9             :: DIM3NAME = '         '
!     ! C Hansen: ! FLDIR is obsolete
      LOGICAL                 :: FLFRQ, FEXIST, FREMOVE ! , FLDIR
      LOGICAL                 :: FLSEP, NEW3D, FIRST_TOGETHER
      LOGICAL                 :: CUSTOMFRQ=.FALSE.
!/T      LOGICAL                 :: LTEMP(NGRPP)
!/RTD ! RTDL == False for a standard lat-lon grid. Will be set to True if the
!/RTD ! grid is rotated
!/RTD      LOGICAL                 :: RTDL = .FALSE.

      TYPE(META_T)            :: META(3)
      !TYPE(META_T)            :: META
!/MFIT
!/MFIT      REAL, ALLOCATABLE    :: M2K(:), MKfac(:)

!/
!/ ------------------------------------------------------------------- /
!/
!
!/S      CALL STRACE (IENT, 'W3EXNC')
!
!/RTD ! Is the grid really rotated
!/RTD      IF ( Polat < 90. ) RTDL = .True.
!/RTD !
!/T      DO IFI=1, NOGRP 
!/T        LTEMP  = FLG2D(IFI,:)
!/T        WRITE (NDST,9000) IFI, LTEMP
!/T        END DO
!/T      WRITE (NDST,9001) NCTYPE, IX1, IXN, IY1, IYN, VECTOR
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 1.  Preparations
!

      ! Length of 3'rd dimension in the file. The default is none:
      N3 = 0
      ! If spectral output is requested, then
      ! let N3 = NK: the largest possible number of frequencies
      IF ( FLG2D(6,8) .OR. FLG2D(6,9) .OR. FLG2D(6,12) ) THEN
        N3 = NK
      ELSE
        ! All fields in group 3 are spectral
        DO IFJ=1, NGRPP
          IF ( N3 .EQ. NK ) EXIT
          IF ( FLG2D(3,IFJ)  ) N3 = NK
        END DO
      END IF
!/XSTO      ! If a vertical Stokes profile dimension 'zk' is requested,
!/XSTO      IF ( FLG2D(6,13) ) N3 = max(N3,NZO) ! size(UXSP,2) == 3 + 2*NZO

      ! Allocate output storage. This is required with the introduction
      ! of the SMC grid output as the regridded output grid dimensions could
      ! conceivably be larger than the NX and NY values. Making these (large)
      ! arrays allocatable also moves them to the heap and avoids stack
      ! overflow issues that can occur on some architectures. (Chris Bunney)
      IF(SMCGRD) THEN
!/SMC        ALLOCATE(X1(NXO,NYO), X2(NXO,NYO), XX(NXO,NYO), XY(NXO,NYO))
!/SMC        IF ( N3 .GT. 0 ) &
!/SMC          ALLOCATE(XK(NXO,NYO,N3), XXK(NXO,NYO,N3), XYK(NXO,NYO,N3))
!/SMC
!/SMC        ALLOCATE(MX1(NXO,NYO), MXX(NXO,NYO),                       &
!/SMC                 MXY(NXO,NYO), MAPOUT(NXO,NYO))
      ELSE
        ALLOCATE(X1(NX+1,NY),X2(NX+1,NY),XX(NX+1,NY),XY(NX+1,NY))
        IF ( N3 .GT. 0 ) &
          ALLOCATE(XK(NX+1,NY,N3), XXK(NX+1,NY,N3), XYK(NX+1,NY,N3))
        ALLOCATE(MX1(NX,NY), MXX(NX,NY), MXY(NX,NY), MAPOUT(NX,NY))
      ENDIF ! SMCGRD

      X1     = UNDEF
      X2     = UNDEF
      XX     = UNDEF
      XY     = UNDEF
      ! CB: Dont output MAPSTA for SMC grid - it does not make sense
      IF( SMCGRD ) THEN
        MAPSTAOUT = 0
      ELSE
        MAPSTAOUT = 1
      ENDIF
      NCVARTYPE  = NCVARTYPEI
      NDSDAT=30
      NCID = 0
!
!
      CALL U2D('days since 1990-01-01 00:00:00',REFDATE,IERR)

! 1.1 Set-up transfer files
      MFILL  = NF90_FILL_SHORT
      MFILLR  = NF90_FILL_FLOAT

! 1.2 Sets the date as ISO8601 convention 
      ! S3 defines the number of characters in the date for the filename
      ! S3=0 -> field, S3=4-> YYYY, S3=6 -> YYYYMM, S3=10 -> YYYYMMDDHH
      ! Setups min and max date format
      IF (S3.GT.0 .AND. S3.LT.4) S3=4 
      IF (S3.GT.10) S3=10 
!
      ! Defines the format of FILETIME
      S5=S3-8
      S4=S3
      OLDTIMEID=TIMEID
      ! if S3=>nodate then filetime='field'
      IF (S3.EQ.0) THEN
        S4=5
        TIMEID="field"
      ! if S3=>YYYYMMDDHH then filetime='YYYYMMDDTHHZ'
      ELSE IF (S3.EQ.10) THEN 
        S4=S4+2 ! add chars for ISO8601 : day T hours Z
        WRITE(FORMAT1,'(A,I1,A,I1,A)') '(I8.8,A1,I',S5,'.',S5,',A1)'
        WRITE (TIMEID,FORMAT1) TIME(1), 'T', &
               FLOOR(REAL(TIME(2))/NINT(10.**(6-S5))), 'Z'
      ! if S3=>YYYYMMDD then filetime='YYYYMMDD'
      ELSE IF (S3.EQ.8) THEN
        WRITE(FORMAT1,'(A,I1,A,I1,A)') '(I',S3,'.',S3,')'
        WRITE (TIMEID,FORMAT1) TIME(1)
      ! if S3=>YYYYMM then filetime='YYYYMM'
      ! or S3=>YYYY then filetime='YYYY'
      ELSE 
        WRITE(FORMAT1,'(A,I1,A,I1,A)') '(I',S3,'.',S3,')'
        WRITE (TIMEID,FORMAT1) FLOOR(REAL(TIME(1))/NINT(10.**(8-S3)))
      END IF       
      ! redefines filename with updated date format
      S1=LEN_TRIM(FILEPREFIX)
      FNAMENC=''
      FNAMENC(1:S1)=FILEPREFIX(1:S1)
      FNAMENC(S1+1:S1+S4) = TIMEID(1:S4)

      !

! 1.4 Increment the time step or set a flag when an new time stamp in files

      IF ( INDEX(TIMEID,OLDTIMEID) .EQ. 0 ) THEN
         ! time splitted condition
         NTIM = 1
         ! The first field in a file TOGETHER. Will be set FALSE for
         ! following fields in the file
         FIRST_TOGETHER = .TRUE.
      ELSE
         NTIM = NTIM + 1
         FIRST_TOGETHER = .FALSE.
      END IF

!/SMC!
!/SMC!---  Update MAPSMC for SMC type 2 output. This needs to be
!/SMC!     done at each timestep as MAPSTA could change if there
!/SMC!     are water level or ice input chagnes.
!/SMC!
!/SMC      IF(SMCTYPE .EQ. 2) CALL MAPSTA_SMC()
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 2.  Loop over output fields.
!

      ! Instanciates the field and group indexes
      I1=0
      J1=0
!
      DO IFI=1, NOGRP
        DO IFJ=1, NGRPP

          IF ( .NOT. FLG2D(IFI,IFJ) ) CYCLE
          ! Here, the flag for the field IFI of the group IFJ is .TRUE.
          
          ! Instanciates the partition array
          INDEXIPART=1

          ! NFP: Number of partitions or sub-fields under each fields flag.
          ! Is to be incremented by one for each partition or extra subfield
          NFP = 1
          ! Subfield index, to be incremented
          IFP = 0
          ! Current attribute meta index under (IFI,IFJ), to be incremented
          IFK = 0
          DO WHILE ( IFP .LT. NFP )
            IFP = IFP + 1

            NFIELD = 1

            ! Increment NFP by one if a following partition is requested
            ! (Loops over IPART for partition variables)
            ! ChrisBunney: Don't loop IPART for last two entries in section 4
            ! (16: total wind sea fraction, 17: number of parts) as these fields
            ! do not have partitions.
            IF (IFI .EQ. 4 .AND. IFJ .LE. NOGE(IFI) - 2) THEN
              IPART=TABIPART(INDEXIPART)
              DO WHILE (INDEXIPART.LT.NBIPART)
                INDEXIPART=INDEXIPART+1
                IF (TABIPART(INDEXIPART).EQ.-1) CYCLE
                NFP = NFP + 1
                EXIT
              END DO
             END IF

            ! C Hansen: Comment out FORMF not used anywhere
            ! FORMF  = '(1X,32I5)'
!/T            IF ( INDEXIPART .GT. 0 ) THEN
!/T              WRITE (NDST,9021) IDOUT(IFI,IFJ), IPART
!/T            ELSE IF ( IFP .GT. 1 ) THEN
!/T              WRITE (NDST,9021) IDOUT(IFI,IFJ), IFP
!/T            ELSE
!/T              WRITE (NDST,9020) IDOUT(IFI,IFJ)
!/T            END IF
!
! 2.1 Set output arrays and parameters
!
            ! Initializes the flags for optional 3'rd dimension
            FLFRQ = .FALSE.
            DIM3NAME = ''
            ! C Hansen: Comment out obsolete FLDIR
            ! FLDIR = .FALSE.
!
            ! NCVARTYPEI.EQ.3 means the NetCDF data type depends on the
            ! field. Datatype real is set for a field
            ! (IFI,IFJ,IFP) by coding: 'IF (NCVARTYPEI.EQ.3) NCVARTYPE=4'
            ! The default data type is short integer: 
            IF (NCVARTYPEI.EQ.3) NCVARTYPE=2
!
            ! Depth
            IF ( IFI .EQ. 1 .AND. IFJ .EQ. 1 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC( DW(1:NSEA), X1 )
              ELSE ! IF(SMCGRD)
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, DW(1:NSEA)     &
                                                            , MAPSF, X1 )
              ENDIF

            ! Surface current
            ELSE IF ( IFI .EQ. 1 .AND. IFJ .EQ. 2 ) THEN
              !! Note - CX and CY read in from .ww3 file are X-Y vectors
!/RTD              ! Rotate x,y vector back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3XYRTN(NSEA, CX(1:NSEA), CY(1:NSEA), AnglD)
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC( CX(1:NSEA), XX )
!/SMC                 CALL W3S2XY_SMC( CY(1:NSEA), XY )
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, CX(1:NSEA)        &
                                                        , MAPSF, XX )
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, CY(1:NSEA)        &
                                                        , MAPSF, XY )
              ENDIF
              NFIELD=2
!
            ! Wind
            ELSE IF ( IFI .EQ. 1 .AND. IFJ .EQ. 3 ) THEN
              !! Note - UA and UD read in from .ww3 file are UX,UY
!/RTD              ! Rotate x,y vector back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3XYRTN(NSEA, UA(1:NSEA), UD(1:NSEA), AnglD)
              
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC( UA(1:NSEA), XX )
!/SMC                 CALL W3S2XY_SMC( UD(1:NSEA), XY )
              ELSE ! IF(SMCGRD)
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, UA(1:NSEA)        &
                                                        , MAPSF, XX )
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, UD(1:NSEA)        &
                                                        , MAPSF, XY )
              ENDIF
              NFIELD=2
!
            ! Air-sea temperature difference
            ELSE IF ( IFI .EQ. 1 .AND. IFJ .EQ. 4 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC(AS(1:NSEA), X1)
              ELSE ! IF(SMCGRD)
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, AS(1:NSEA)        &
                                                        , MAPSF, X1 )
              ENDIF
!
            ! Sea surface height above sea level
            ELSE IF ( IFI .EQ. 1 .AND. IFJ .EQ. 5 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC(WLV, X1)
              ELSE ! IF(SMCGRD)
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, WLV   , MAPSF, X1 )
              ENDIF
!
            ! Sea ice area fraction
            ELSE IF ( IFI .EQ. 1 .AND. IFJ .EQ. 6 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC(ICE, X1)
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, ICE(1:NSEA), MAPSF, X1 )
              ENDIF

            ! Icebergs_damping
            ELSE IF ( IFI .EQ. 1 .AND. IFJ .EQ. 7 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC(BERG, X1)
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, BERG   , MAPSF, X1 )
              ENDIF
              WHERE ( X1.NE.UNDEF) X1 = X1*0.1
!
!/BT4 ! Krumbein phi scale
!/BT4 ELSE IF ( IFI .EQ. 1 .AND. IFJ .EQ. 8 ) THEN
!/BT4              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, SED_D50   , MAPSF, X1 )
!/BT4              WHERE ( X1.NE.UNDEF) X1 = -LOG(X1/0.001)/LOG2    
!/BT4              NFIELD=1
!
!/IS2 ! Ice thickness
!/IS2 ELSE IF (IFI .EQ. 1 .AND. IFJ .EQ. 9 ) THEN
!/IS2              CALL W3S2XY (NSEA, NSEA, NX+1, NY, ICEH(1:NSEA), MAPSF, X1 )
!/IS2              NFIELD=1
!
!/IS2 ! Maximum ice floe diameter
!/IS2 ELSE IF (IFI .EQ. 1 .AND. IFJ .EQ. 10 ) THEN
!/IS2              CALL W3S2XY (NSEA, NSEA, NX+1, NY, ICEF(1:NSEA), MAPSF, X1 )
!/IS2              NFIELD=1

            ! Significant wave height
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 1 ) THEN
              IF (NCVARTYPEI.EQ.3) NCVARTYPE=2
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC( HS, X1 )
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, HS    , MAPSF, X1 )
              ENDIF

            ! Mean wave length
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 2 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC(WLM, X1 )
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, WLM, MAPSF, X1 )
              ENDIF
!
            ! Mean period T02
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 3 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC( T02, X1 )
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, T02, MAPSF, X1 )
              ENDIF
!
            ! Mean period T0m1
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 4 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( T0M1, X1 )
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, T0M1, MAPSF, X1 )
              ENDIF
!
            ! Mean period T01
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 5 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( T01, X1 )
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, T01   , MAPSF, X1 )
              ENDIF
!
            ! Wave peak frequency
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 6 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC(FP0, X1)
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, FP0   , MAPSF, X1 )
              ENDIF
!
            ! Wave mean direction
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 7 ) THEN
!/RTD              ! Rotate direction back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3THRTN(NSEA, THM, AnglD, .FALSE.)
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( THM, X1, .TRUE. )
              ELSE
                 DO ISEA=1, NSEA
                   IF ( THM(ISEA) .NE. UNDEF )  THEN
                     THM(ISEA) = MOD ( 630. - RADE*THM(ISEA) , 360. )
                     END IF
                   END DO
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, THM, MAPSF, X1 )
              ENDIF
!
            ! Directional spread
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 8 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( THS, X1 )
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, THS   , MAPSF, X1 )
              ENDIF
!
            ! Peak direction
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 9 ) THEN
!/RTD              ! Rotate direction back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3THRTN(NSEA, THP0, AnglD, .FALSE.)
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( THP0, X1, .TRUE. )
              ELSE
                 DO ISEA=1, NSEA
                   IF ( THP0(ISEA) .NE. UNDEF ) THEN
                     THP0(ISEA) = MOD ( 630-RADE*THP0(ISEA) , 360. )
                     END IF
                   END DO
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, THP0  , MAPSF, X1 )
              ENDIF
!
            ! Infragravity wave height
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 10 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( HSIG, X1 )
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, HSIG, MAPSF, X1 )
              ENDIF
!
            ! Expected maximum sea surface elevation
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 11 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( STMAXE, X1 )
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, STMAXE, MAPSF, X1 )
              ENDIF
!
            ! Standard deviation of maximum sea surface elevation
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 12 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( STMAXD, X1 )
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, STMAXD, MAPSF, X1 )
              ENDIF
!
            ! Expected maximum wave height 
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 13 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( HMAXE, X1 )
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, HMAXE, MAPSF, X1 )
              ENDIF
!
            ! Expected maximum wave height from crest
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 14 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( HCMAXE, X1 )
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, HCMAXE, MAPSF, X1 )
              ENDIF
!
            ! STD of maximum wave height
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 15 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( HMAXD, X1 )
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, HMAXD, MAPSF, X1 )
              ENDIF
!
            ! STD of maximum wave height from crest
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 16 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( HCMAXD, X1 )
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, HCMAXD, MAPSF, X1 )
              ENDIF
!
            ! Dominant wave breaking probability
            ELSE IF ( IFI .EQ. 2 .AND. IFJ .EQ. 17 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( WBT, X1 )
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, WBT, MAPSF, X1 )
              END IF
!
            ! Wave elevation spectrum
            ELSE IF ( IFI .EQ. 3 .AND. IFJ .EQ. 1 ) THEN
              ! Information for spectral
              FLFRQ  = .TRUE.
              I1F=E3DF(2,1)
              I2F=E3DF(3,1)
              DO IK=I1F,I2F
                IF( SMCGRD ) THEN
!/SMC                  CALL W3S2XY_SMC( EF(:,IK), XX )
                ELSE
                   CALL W3S2XY ( NSEA, NSEA, NX+1,NY,EF(:,IK),MAPSF, XX )
                ENDIF
                IF (NCVARTYPE.EQ.2) WHERE ( XX.GE.0.) XX = ALOG10(XX+1E-12)
                XK(:,:,IK)=XX
                END DO
!
            ! Mean wave direction frequency spectrum
            ELSE IF ( IFI .EQ. 3 .AND. IFJ .EQ. 2 ) THEN
              ! Information for spectral
              FLFRQ  = .TRUE.
              I1F=E3DF(2,2)
              I2F=E3DF(3,2)
              DO IK=I1F,I2F
!/RTD                ! Rotate direction back to standard pole
!/RTD                IF ( FLAGUNR ) CALL W3THRTN(NSEA, TH1M(:,IK), AnglD, .FALSE.)
                IF( SMCGRD ) THEN
!/SMC                   CALL W3S2XY_SMC( TH1M(:,IK), XX )
                ELSE
                   CALL W3S2XY ( NSEA, NSEA, NX+1,NY,TH1M(:,IK),MAPSF, XX )
                ENDIF
                XK(:,:,IK)=XX
                END DO
!
            ! Spreading frequency spectrum
            ELSE IF ( IFI .EQ. 3 .AND. IFJ .EQ. 3 ) THEN
              ! Information for spectral
              FLFRQ  = .TRUE.
              I1F=E3DF(2,3)
              I2F=E3DF(3,3)
              DO IK=I1F,I2F
                IF( SMCGRD ) THEN
!/SMC                   CALL  W3S2XY_SMC( STH1M(:,IK), XX )
                ELSE
                   CALL W3S2XY ( NSEA, NSEA, NX+1,NY,STH1M(:,IK),MAPSF, XX )
                ENDIF
                XK(:,:,IK)=XX
                END DO
!
            ! Second mean wave direction frequency spectrum
            ELSE IF ( IFI .EQ. 3 .AND. IFJ .EQ. 4 ) THEN
              ! Information for spectral
              FLFRQ  = .TRUE.
              I1F=E3DF(2,4)
              I2F=E3DF(3,4)
              DO IK=I1F,I2F
!/RTD                ! Rotate direction back to standard pole
!/RTD                IF ( FLAGUNR ) CALL W3THRTN(NSEA, TH2M(:,IK), AnglD, .FALSE.)
                IF( SMCGRD ) THEN
!/SMC                  CALL W3S2XY_SMC( TH2M(:,IK), XX )
                ELSE
                   CALL W3S2XY ( NSEA, NSEA, NX+1,NY,TH2M(:,IK),MAPSF, XX )
                ENDIF
                XK(:,:,IK)=XX
                END DO
!
            ! Second spreading frequency spectrum
            ELSE IF ( IFI .EQ. 3 .AND. IFJ .EQ. 5 ) THEN
              ! Information for spectral
              FLFRQ  = .TRUE.
              I1F=E3DF(2,5)
              I2F=E3DF(3,5)
              DO IK=I1F,I2F
                IF( SMCGRD ) THEN
!/SMC                  CALL W3S2XY_SMC( STH2M(:,IK), XX )
                ELSE
                   CALL W3S2XY ( NSEA, NSEA, NX+1,NY,STH2M(:,IK),MAPSF, XX )
                ENDIF
                XK(:,:,IK)=XX
                END DO
!
            ! Wave numbers
            ELSE IF ( IFI .EQ. 3 .AND. IFJ .EQ. 6 ) THEN
              ! Information for spectral
              FLFRQ  = .TRUE.
              I1F=1
              I2F=NK
              DO IK=1,NK 
                IF( SMCGRD ) THEN
!/SMC                  CALL W3S2XY_SMC( WN(IK,:), XX )
                ELSE
                   CALL W3S2XY ( NSEA, NSEA, NX+1, NY, WN(IK,:), MAPSF, XX )
                ENDIF
                XK(:,:,IK)=XX
              END DO
!
            ! Partition wave significant height
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 1 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC( PHS(:,IPART), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PHS(:,IPART), MAPSF, X1 )
              ENDIF
!
            ! Partition peak period
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 2 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC( PTP(:,IPART), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PTP(:,IPART), MAPSF, X1 )
              ENDIF

            ! Partition peak wave length
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 3 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( PLP(:,IPART), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PLP(:,IPART), MAPSF, X1 )
              ENDIF
!
            ! Partition wave mean direction
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 4 ) THEN
!/RTD                ! Rotate direction back to standard pole
!/RTD                IF ( FLAGUNR ) CALL W3THRTN(NSEA, PDIR(:,IPART), AnglD, .FALSE.)
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( PDIR(:,IPART), X1, .TRUE. )
              ELSE
                DO ISEA=1, NSEA
                  IF ( PDIR(ISEA,IPART) .NE. UNDEF ) THEN
                     PDIR(ISEA,IPART) = MOD ( 630-RADE*PDIR(ISEA,IPART) , 360. )
                  END IF
                END DO
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PDIR(:,IPART), MAPSF, X1 )
              ENDIF
!
            ! Partition directional spread
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 5 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( PSI(:,IPART), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PSI(:,IPART), MAPSF, X1 )
              ENDIF

            ! Partition wind sea fraction
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 6 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( PWS(:,IPART), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PWS(:,IPART), MAPSF, X1 )
              ENDIF
!
            ! Partition peak direction
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 7 ) THEN
!/RTD                ! Rotate direction back to standard pole
!/RTD                IF ( FLAGUNR ) CALL W3THRTN(NSEA, PTHP0(:,IPART), AnglD, .FALSE.)
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( PTHP0(:,IPART), X1, .TRUE. )
              ELSE
                DO ISEA=1, NSEA
                  IF ( PTHP0(ISEA,IPART) .NE. UNDEF ) THEN
                    PTHP0(ISEA,IPART) = MOD ( 630-RADE*PTHP0(ISEA,IPART) , 360. )
                    END IF
                  END DO
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PTHP0(:,IPART), MAPSF, X1 )
              END IF
!
            ! Partition peakedness
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 8 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC( PQP(:,IPART), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PQP(:,IPART), MAPSF, X1 )
              ENDIF
!
            ! Partition peak enhancement factor
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 9 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC( PPE(:,IPART), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PPE(:,IPART), MAPSF, X1 )
              ENDIF
!
            ! Partition frequency width
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 10 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC( PGW(:,IPART), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PGW(:,IPART), MAPSF, X1 )
              ENDIF
!
            ! Partition spectral width
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 11 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC( PSW(:,IPART), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PSW(:,IPART), MAPSF, X1 )
              ENDIF
!
            ! Partition mean period Tm10
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 12 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC( PTM1(:,IPART), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PTM1(:,IPART), MAPSF, X1 )
              ENDIF
!
            ! Partition mean period T01
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 13 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC( PT1(:,IPART), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PT1(:,IPART), MAPSF, X1 )
              ENDIF
!
            ! Partition mean period T02
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 14 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC( PT2(:,IPART), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PT2(:,IPART), MAPSF, X1 )
              ENDIF
!
            ! Partition energy at peak frequency
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 15 ) THEN
              IF( SMCGRD ) THEN
!/SMC                 CALL W3S2XY_SMC( PEP(:,IPART), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PEP(:,IPART), MAPSF, X1 )
              ENDIF
              NFIELD=1
!
            ! Partition wind sea fraction
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 16 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( PWST(:), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PWST(:), MAPSF, X1 )
              ENDIF
!
            ! Number of wave partitions
            ELSE IF ( IFI .EQ. 4 .AND. IFJ .EQ. 17 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( PNR(:), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PNR(:), MAPSF, X1 )
              ENDIF
!
            ! Friction velocity
            ELSE IF ( IFI .EQ. 5 .AND. IFJ .EQ. 1 ) THEN
              !! Note - UST and USTDIR read in from .ww3 file are X-Y vectors
              DO ISEA=1, NSEA
                UABS   = SQRT(UST(ISEA)**2+USTDIR(ISEA)**2)
                 IF (UABS.GE.10.) THEN
                  UST(ISEA)=UNDEF
                  USTDIR(ISEA)=UNDEF
                  END IF
                 END DO
!/RTD              ! Rotate x,y vector back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3XYRTN(NSEA, UST(1:NSEA), USTDIR(1:NSEA), AnglD)
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( UST(1:NSEA), XX )
!/SMC                CALL W3S2XY_SMC( USTDIR(1:NSEA), XY )
              ELSE
                CALL W3S2XY (NSEA,NSEA,NX+1,NY, UST   (1:NSEA), MAPSF, XX )
                CALL W3S2XY (NSEA,NSEA,NX+1,NY, USTDIR(1:NSEA), MAPSF, XY )
              ENDIF ! SMCGRD
              !! Commented out unnecessary statements below for time being
              !! UST,USTDIR are in north-east convention and X1,X2
              !! are not actually written out below
              !DO ISEA=1, NSEA
              !  UABS   = SQRT(UST(ISEA)**2+USTDIR(ISEA)**2)
              !  IF ( UST(ISEA) .EQ. UNDEF ) THEN
              !      USTDIR(ISEA) = UNDEF
              !      UABS         = UNDEF
              !    ELSE IF ( UABS .GT. 0.05 ) THEN
              !      USTDIR(ISEA) = MOD ( 630. -                     &
              !        RADE*ATAN2(USTDIR(ISEA),UST(ISEA)) , 360. )
              !    ELSE
              !      USTDIR(ISEA) = UNDEF
              !    END IF
              !  UST(ISEA) = UABS
              !  END DO
              !CALL W3S2XY (NSEA,NSEA,NX+1,NY, UST   (1:NSEA) , MAPSF, X1 )
              !CALL W3S2XY (NSEA,NSEA,NX+1,NY, USTDIR(1:NSEA) , MAPSF, X2 )
              NFIELD=2
!
            ! Charnock coefficient
            ELSE IF ( IFI .EQ. 5 .AND. IFJ .EQ. 2 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( CHARN(1:NSEA), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, CHARN(1:NSEA), MAPSF, X1 )
              ENDIF ! SMCGRD
!
            ! Wave energy flux
            ELSE IF ( IFI .EQ. 5 .AND. IFJ .EQ. 3 ) THEN
              CGE=CGE*0.001  ! from W / m to kW / m 
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( CGE(1:NSEA), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, CGE(1:NSEA), MAPSF, X1 )
              ENDIF ! SMCGRD
!
            ! Wind to wave energy flux
            ELSE IF ( IFI .EQ. 5 .AND. IFJ .EQ. 4 ) THEN
              IF (NCVARTYPEI.EQ.3) NCVARTYPE=4
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( PHIAW(1:NSEA), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PHIAW(1:NSEA) , MAPSF, X1 )
              ENDIF ! SMCGRD
!
            ! Wave supported wind stress
            ELSE IF ( IFI .EQ. 5 .AND. IFJ .EQ. 5 ) THEN
!/RTD              ! Rotate x,y vector back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3XYRTN(NSEA, TAUWIX(1:NSEA), TAUWIY(1:NSEA), AnglD)
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( TAUWIX(1:NSEA), XX )
!/SMC                CALL W3S2XY_SMC( TAUWIY(1:NSEA), XY )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, TAUWIX(1:NSEA)      &
                                                        , MAPSF, XX )
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, TAUWIY(1:NSEA)      &
                                                        , MAPSF, XY )
              ENDIF ! SMCGRD
              !! Commented out unnecessary statements below for time being
              !! TAUWIX, TAUWIY are in north-east convention and X1,X2
              !! are not actually written out below
              !DO ISEA=1, NSEA
              !  CABS   = SQRT(TAUWIX(ISEA)**2+TAUWIY(ISEA)**2)
              !  IF ( CABS .NE. UNDEF ) THEN
              !      TAUWIY(ISEA) = MOD ( 630. -                         &
              !            RADE*ATAN2(TAUWIY(ISEA),TAUWIX(ISEA)) , 360. )
              !    ELSE
              !      TAUWIY(ISEA) = UNDEF
              !    END IF
              !  TAUWIX(ISEA) = CABS
              !  END DO
              !CALL W3S2XY ( NSEA, NSEA, NX+1, NY, TAUWIX, MAPSF, X1 )
              !CALL W3S2XY ( NSEA, NSEA, NX+1, NY, TAUWIY, MAPSF, X2 )
              NFIELD=2
!
            ! Wave to wind stress
            ELSE IF ( IFI .EQ. 5 .AND. IFJ .EQ. 6 ) THEN
!/RTD              ! Rotate x,y vector back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3XYRTN(NSEA, TAUWNX(1:NSEA), TAUWNY(1:NSEA), AnglD)
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( TAUWNX(1:NSEA), XX )
!/SMC                CALL W3S2XY_SMC( TAUWNY(1:NSEA), XY )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, TAUWNX(1:NSEA)   &
                                                        , MAPSF, XX )
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, TAUWNY(1:NSEA)   &
                                                        , MAPSF, XY )
              ENDIF ! SMCGRD
              NFIELD=2
!
            ! Whitecap coverage
            ELSE IF ( IFI .EQ. 5 .AND. IFJ .EQ. 7 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( WHITECAP(1:NSEA,1), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, WHITECAP(1:NSEA,1) &
                                                        , MAPSF, X1 )
              ENDIF ! SMCGRD
!
            ! Whitecap foam thickness
            ELSE IF ( IFI .EQ. 5 .AND. IFJ .EQ. 8 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( WHITECAP(1:NSEA,2), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, WHITECAP(1:NSEA,2) &
                                                        , MAPSF, X1 )
              ENDIF
!
            ! Significant breaking wave height
            ELSE IF ( IFI .EQ. 5 .AND. IFJ .EQ. 9 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( WHITECAP(1:NSEA,3), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, WHITECAP(1:NSEA,3) &
                                                        , MAPSF, X1 )
              ENDIF ! SMCGRD
!
            ! Whitecap moment
            ELSE IF ( IFI .EQ. 5 .AND. IFJ .EQ. 10 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( WHITECAP(1:NSEA,4), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, WHITECAP(1:NSEA,4) &
                                                        , MAPSF, X1 )
              ENDIF ! SMCGRD
!
            ! Wind sea mean period T0M1
            ELSE IF ( IFI .EQ. 5 .AND. IFJ .EQ. 11 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( TWS(1:NSEA), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, TWS(1:NSEA), MAPSF, X1 )
              ENDIF ! SMCGRD
!
            ! Radiation stress
            ELSE IF ( IFI .EQ. 6 .AND. IFJ .EQ. 1 ) THEN
!/RTD         ! Radition stress components are always left on rotated pole
!/RTD         ! at present - need to confirm how to de-rotate

              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( SXX(1:NSEA), X1 )
!/SMC                CALL W3S2XY_SMC( SYY(1:NSEA), X2 )
!/SMC                CALL W3S2XY_SMC( SXY(1:NSEA), XY )
              ELSE
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, SXX(1:NSEA)       &
                                                        , MAPSF, X1 )
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, SYY(1:NSEA)       &
                                                        , MAPSF, X2 )
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, SXY(1:NSEA)       &
                                                        , MAPSF, XY )
              ENDIF ! SMCGRD
              NFIELD=3
!
            ! Wave to ocean stress
            ELSE IF ( IFI .EQ. 6 .AND. IFJ .EQ. 2 ) THEN
!/RTD              ! Rotate x,y vector back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3XYRTN(NSEA, TAUOX(1:NSEA), TAUOY(1:NSEA), AnglD)
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( TAUOX(1:NSEA), XX )
!/SMC                CALL W3S2XY_SMC( TAUOY(1:NSEA), XY )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, TAUOX(1:NSEA)      &
                                                        , MAPSF, XX )
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, TAUOY(1:NSEA)      &
                                                        , MAPSF, XY )
              ENDIF ! SMCGRD
              NFIELD=2
!
            ! Radiation pressure (Bernouilli Head)
            ELSE IF ( IFI .EQ. 6 .AND. IFJ .EQ. 3 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( BHD(1:NSEA), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, BHD(1:NSEA)  &
                                                        , MAPSF, X1 )
              ENDIF ! SMCGRD
!
            ! Wave to ocean energy flux
            ELSE IF ( IFI .EQ. 6 .AND. IFJ .EQ. 4 ) THEN
              IF (NCVARTYPEI.EQ.3) NCVARTYPE=4
              DO ISEA=1, NSEA
                 PHIOC(ISEA)=MIN(3000.,PHIOC(ISEA))
                 END DO
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( PHIOC(1:NSEA), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PHIOC(1:NSEA)  &
                                                        , MAPSF, X1 )
              ENDIF ! SMCGRD
!
            ! Stokes transport
            ELSE IF ( IFI .EQ. 6 .AND. IFJ .EQ. 5 ) THEN
!/RTD              ! Rotate x,y vector back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3XYRTN(NSEA, TUSX(1:NSEA), TUSY(1:NSEA), AnglD)
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( TUSX(1:NSEA), XX )
!/SMC                CALL W3S2XY_SMC( TUSY(1:NSEA), XY )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, TUSX(1:NSEA)      &
                                                        , MAPSF, XX )
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, TUSY(1:NSEA)      &
                                                        , MAPSF, XY )
              ENDIF ! SMCGRD
              !! Commented out unnecessary statements below for time being
              !! like for CX,CY (IFI==1 .AND. IFJ==2), and others
              ! DO ISEA=1, NSEA
              !   CABS   = SQRT(TUSX(ISEA)**2+TUSY(ISEA)**2)
              !   IF ( CABS .NE. UNDEF ) THEN
              !       TUSY(ISEA) = MOD ( 630. -                         &
              !             RADE*ATAN2(TUSY(ISEA),TUSX(ISEA)) , 360. )
              !     ELSE
              !       TUSY(ISEA) = UNDEF
              !     END IF
              !   TUSX(ISEA) = CABS
              !   END DO
              ! IF( SMCGRD ) THEN
! !/SMC                CALL W3S2XY_SMC( TUSX(:), X1 )
! !/SMC                CALL W3S2XY_SMC( TUSY(:), X2 ) ! TODO: CHRISB: TUSY is in degrees....W3S2XY_SMC expects radians...
              ! ELSE
              !   CALL W3S2XY ( NSEA, NSEA, NX+1, NY,TUSX,MAPSF, X1 )
              !   CALL W3S2XY ( NSEA, NSEA, NX+1, NY,TUSY,MAPSF, X2 )
              ! ENDIF ! SMCGRD
              NFIELD=2
!
            ! Surface stokes drift
            ELSE IF ( IFI .EQ. 6 .AND. IFJ .EQ. 6 ) THEN
              DO ISEA=1, NSEA
                 USSX(ISEA)=MAX(-0.9998,MIN(0.9998,USSX(ISEA)))
                 USSY(ISEA)=MAX(-0.9998,MIN(0.9998,USSY(ISEA)))
                 END DO
!/RTD              ! Rotate x,y vector back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3XYRTN(NSEA, USSX(1:NSEA), USSY(1:NSEA), AnglD)
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( USSX(1:NSEA), XX )
!/SMC                CALL W3S2XY_SMC( USSY(1:NSEA), XY )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, USSX(1:NSEA)      &
                                                        , MAPSF, XX )
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, USSY(1:NSEA)      &
                                                        , MAPSF, XY )
              ENDIF ! SMCGRD
              !! Commented out unnecessary statements below for time being
              !! USSX, USSY are in north-east convention and X1,X2
              !! are not actually written out below
              !DO ISEA=1, NSEA
              !  CABS   = SQRT(USSX(ISEA)**2+USSY(ISEA)**2)
              !  IF ( CABS .NE. UNDEF ) THEN
              !      USSY(ISEA) = MOD ( 630. -                         &
              !            RADE*ATAN2(USSY(ISEA),USSX(ISEA)) , 360. )
              !    ELSE
              !      USSY(ISEA) = UNDEF
              !    END IF
              !  USSX(ISEA) = CABS
              !  END DO
              !CALL W3S2XY ( NSEA, NSEA, NX+1, NY,USSX,MAPSF, X1 )
              !CALL W3S2XY ( NSEA, NSEA, NX+1, NY,USSY,MAPSF, X2 )
              NFIELD=2
!
            ! Power spectral density of equivalent surface pressure
            ELSE IF ( IFI .EQ. 6 .AND. IFJ .EQ. 7 ) THEN
              NFIELD=2
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( PRMS(1:NSEA), XX )
!/SMC                CALL W3S2XY_SMC( TPMS(1:NSEA), XY )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PRMS(1:NSEA)      &
                                                        , MAPSF, XX )
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, TPMS(1:NSEA)      &
                                                        , MAPSF, XY )
              ENDIF ! SMCGRD
!
            ! Spectral variance of surface stokes drift
            ELSE IF ( IFI .EQ. 6 .AND. IFJ .EQ. 8 ) THEN
              ! Information for spectral distribution of surface Stokes drift (2nd file)
              FLFRQ=.TRUE.
              NFIELD=2
              I1F=US3DF(2)
              I2F=US3DF(3)
              DO IK= I1F,I2F
!/RTD                ! Rotate x,y vector back to standard pole
!/RTD                IF ( FLAGUNR ) CALL W3XYRTN(NSEA, US3D(:,IK), US3D(:,NK+IK), AnglD)
                IF( SMCGRD ) THEN
!/SMC                  CALL W3S2XY_SMC( US3D(:,IK), XX )
!/SMC                  CALL W3S2XY_SMC( US3D(:,NK+IK), XY )
                ELSE
                  CALL W3S2XY ( NSEA, NSEA, NX+1,NY,US3D(:,IK), MAPSF, XX )
                  CALL W3S2XY ( NSEA, NSEA, NX+1,NY,US3D(:,NK+IK), MAPSF, XY )
                ENDIF ! SMCGRD
                XXK(:,:,IK)=XX
                XYK(:,:,IK)=XY
              END DO
!
            ! Base10 logarithm of power spectral density of equivalent surface pressure
            ELSE IF ( IFI .EQ. 6 .AND. IFJ .EQ.  9 ) THEN
                ! Information for spectral microseismic generation data (2nd file)
                FLFRQ=.TRUE.
                I1F=P2MSF(2)
                I2F=P2MSF(3)
                DO IK=I1F,I2F
                  IF( SMCGRD ) THEN
!/SMC                    CALL W3S2XY_SMC( P2SMS(:,IK), XX )
                  ELSE
                    CALL W3S2XY ( NSEA, NSEA, NX+1,NY,P2SMS(:,IK),MAPSF, XX )
                  ENDIF ! SMCGRD
                  IF (NCVARTYPE.EQ.2) THEN 
                     WHERE ( XX.GE.0.) XX = ALOG10(XX*(DWAT*GRAV)**2+1E-12)
                  ELSE 
                     WHERE ( XX.GE.0.) XX = XX*(DWAT*GRAV)**2
                  END IF
                
                  XK(:,:,IK)=XX
                END DO
!
            ! Wave to sea ice stress
            ELSE IF ( IFI .EQ. 6 .AND. IFJ .EQ. 10 ) THEN
!/RTD              ! Rotate x,y vector back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3XYRTN(NSEA, TAUICE(1:NSEA,1), TAUICE(1:NSEA,2), AnglD)
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( TAUICE(1:NSEA,1), XX )
!/SMC                CALL W3S2XY_SMC( TAUICE(1:NSEA,2), XY )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, TAUICE(1:NSEA,1)        &
                                                        , MAPSF, XX )
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, TAUICE(1:NSEA,2)        &
                                                        , MAPSF, XY )
              ENDIF ! SMCGRD
              NFIELD=2
!
            ! Wave to sea ice energy flux
            ELSE IF ( IFI .EQ. 6 .AND. IFJ .EQ. 11 ) THEN
              IF (NCVARTYPEI.EQ.3) NCVARTYPE=4
              DO ISEA=1, NSEA
                 PHIOC(ISEA)=MIN(3000.,PHIOC(ISEA))
                 END DO
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( PHICE(1:NSEA), X1 )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PHICE(1:NSEA)  &
                                                        , MAPSF, X1 )
              ENDIF ! SMCGRD

           ! Partitioned surface stokes drift
           ELSE IF ( IFI .EQ. 6 .AND. IFJ .EQ. 12 ) THEN
              ! Information for spectral distribution of surface Stokes drift (2nd file)
              FLFRQ=.TRUE.
              IF (USSPF(1)==1) THEN
                 CUSTOMFRQ=.TRUE.
              ENDIF
              NFIELD=2
              I1F=1
              I2F=USSPF(2)
              DO IK= I1F,I2F
!/RTD                ! Rotate x,y vector back to standard pole
!/RTD                IF ( FLAGUNR ) CALL W3XYRTN(NSEA, USSP(:,IK), USSP(:,NK+IK), AnglD)
                IF( SMCGRD ) THEN
!/SMC                  CALL W3S2XY_SMC( USSP(:,IK), XX )
!/SMC                  CALL W3S2XY_SMC( USSP(:,NK+IK), XY )
                ELSE
                  CALL W3S2XY ( NSEA, NSEA, NX+1,NY,USSP(:,IK), MAPSF, XX )
                  CALL W3S2XY ( NSEA, NSEA, NX+1,NY,USSP(:,NK+IK), MAPSF, XY )
                ENDIF ! SMCGRD
                XXK(:,:,IK)=XX
                XYK(:,:,IK)=XY
              END DO
!
!/XSTO     ELSE IF ( IFI .EQ. 6 .AND. IFJ .EQ. 13 ) THEN
!/XSTO        ! The three subfields (NFP=3) are joined in the netCDF file
!/XSTO        NFP = 3 ! Number of subfields loop over IFP=1,NFP
!/XSTO!/MFIT  IF (.NOT. SVP) NFP = 2 ! Write only UXSP(:,1:3), not the profile
!/XSTO!
!/XSTO        IF ( IFP .EQ. 1 ) THEN
!/XSTO          ! 'Wavenumber of the zero-upcrossing period'
!/XSTO          ! For an XSTO spectral tail
!/XSTO          NFIELD=1
!/XSTO      ! NOTE: The magnitude of ksc spans from O(1e-2) to O(1e+1)
!/XSTO      !       It can be scaled to a 16-bit integer only with an
!/XSTO      !       accuracy of order O(1e-3), and a value of FSC larger
!/XSTO      !       than about 0.0005.
!/XSTO          IF (NCVARTYPEI.EQ.3) NCVARTYPE=4
!/XSTO          IF( SMCGRD ) THEN
!/XSTO!/SMC            CALL W3S2XY_SMC( UXSP(1:NSEA,1), X1 )
!/XSTO          ELSE
!/XSTO            CALL W3S2XY ( NSEA, NSEA, NX+1, NY, UXSP(1:NSEA,1), MAPSF, X1 )
!/XSTO          ENDIF ! SMCGRD
!/XSTO!
!/XSTO        ELSE IF ( IFP .EQ. 2 ) THEN
!/XSTO          ! Vertical profile of Stokes drift
!/XSTO          ! For an XSTO spectral tail
!/XSTO          DIM3NAME='zk'
!/XSTO          NFIELD=2
!/XSTO          IFK=1
!/XSTO          I1F=1
!/XSTO          I2F=NZO
!/XSTO          DO IK = 4,NZO+3
!/XSTO!/RTD       ! Rotate x,y vector back to standard pole
!/XSTO!/RTD       IF ( FLAGUNR ) CALL W3XYRTN(NSEA, UXSP(:,IK), UXSP(:,NZO+IK), AnglD)
!/XSTO            IF( SMCGRD ) THEN
!/XSTO!/SMC         CALL W3S2XY_SMC( UXSP(:,IK), XX )
!/XSTO!/SMC         CALL W3S2XY_SMC( UXSP(:,NZO+IK), XY )
!/XSTO            ELSE
!/XSTO              CALL W3S2XY ( NSEA, NSEA, NX+1,NY,UXSP(:,IK), MAPSF, XX )
!/XSTO              CALL W3S2XY ( NSEA, NSEA, NX+1,NY,UXSP(:,NZO+IK), MAPSF, XY )
!/XSTO            ENDIF ! SMCGRD
!/XSTO            XXK(:,:,IK-3)=XX
!/XSTO            XYK(:,:,IK-3)=XY
!/XSTO          END DO
!/XSTO!
!/XSTO        ELSE IF ( IFP .EQ. 3 ) THEN
!/XSTO          ! Vertically integrated Stokes drift == wave pseudo momentum
!/XSTO          ! For an XSTO spectral tail
!/XSTO          ! This variable is nearly the same as TUS, the
!/XSTO          ! 'Stokes transport', but with the XSTO extended tail
!/XSTO          NFIELD=2
!/XSTO          IFK = 2
!/XSTO!/MFIT    ! Multiply by 2*ksc
!/XSTO!/MFIT    UXSP(1:NSEA,2) = UXSP(1:NSEA,2)*UXSP(1:NSEA,1)*2.
!/XSTO!/MFIT    UXSP(1:NSEA,3) = UXSP(1:NSEA,3)*UXSP(1:NSEA,1)*2.
!/XSTO!/MFIT    ! Stokes drift parts at surface to be normalized by abs(2MK)+MK0
!/XSTO!/MFIT    allocate ( M2K(NSEA), stat=IRET )
!/XSTO!/MFIT    ! Avoid small value of M2K in square root
!/XSTO!/MFIT    where ( UXSP(:,2) * UXSP(:,2) + UXSP(:,3) * UXSP(:,3) < 1.09e-9 )
!/XSTO!/MFIT      UXSP(:,2) = 2.34e-5
!/XSTO!/MFIT      UXSP(:,3) = 2.34e-5
!/XSTO!/MFIT      end where
!/XSTO!/MFIT    M2K(:) = sqrt(UXSP(:,2) * UXSP(:,2) + UXSP(:,3) * UXSP(:,3) )
!/XSTO!/MFIT    ! Avoid division by small values of M2K
!/XSTO!/MFIT    allocate ( MKfac(NSEA), stat=IRET )
!/XSTO!/MFIT    MKfac = 1.
!/XSTO!/MFIT    IF (NCVARTYPEI.GT.3) MK0 = 3.3e-5 !  0.033 mm/s
!/XSTO!/MFIT    where ( M2K < MK0 ) MKfac = MK0/M2K
!/XSTO!/MFIT    where ( MKfac .gt. 1. )
!/XSTO!/MFIT      UXSP(:,2) = UXSP(:,2) * MKfac
!/XSTO!/MFIT      UXSP(:,3) = UXSP(:,3) * MKfac
!/XSTO!/MFIT      M2K = MK0
!/XSTO!/MFIT    end where
!/XSTO!/MFIT    ! "S0": 'Upper' fit surface drift normalized by abs(2MK)+MK0
!/XSTO!/MFIT    UXSP(:,4) = UXSP(:,4)/M2K(:)
!/XSTO!/MFIT    UXSP(:,4+NZO) = UXSP(:,4+NZO)/M2K(:)
!/XSTO!/MFIT    ! "Sd": 'Deep' fit surface drift normalized by abs(2MK)
!/XSTO!/MFIT    USERO(1:NSEA,1) = USERO(1:NSEA,1)/M2K(:)
!/XSTO!/MFIT    USERO(1:NSEA,2) = USERO(1:NSEA,2)/M2K(:)
!/XSTO!/MFIT    IF (NCVARTYPEI.LE.3) THEN
!/XSTO!/MFIT      ! Apply a lower limiter to |M2K| if large short int output
!/XSTO!/MFIT      MKfac = 1.
!/XSTO!/MFIT      WHERE ( ABS(UXSP(:,4)) > 30. .OR. ABS(UXSP(:,4+NZO)) > 30. &
!/XSTO!/MFIT        .OR. ABS(USERO(1:NSEA,1))>30. .OR. ABS(USERO(1:NSEA,2))>30.)&
!/XSTO!/MFIT        ! 2MK should be enlarged by a factor (stored in M2K):
!/XSTO!/MFIT        MKfac = MAX( ABS(UXSP(:,4)), ABS(UXSP(:,4+NZO)), &
!/XSTO!/MFIT                     ABS(USERO(1:NSEA,1)), ABS(USERO(1:NSEA,2)) ) &
!/XSTO!/MFIT                    / 30.
!/XSTO!/MFIT      WHERE (MKfac .ne. 1. )
!/XSTO!/MFIT        UXSP(:,2) = UXSP(:,2)*MKfac
!/XSTO!/MFIT        UXSP(:,3) = UXSP(:,3)*MKfac
!/XSTO!/MFIT        ! One of the surface drift components / abs(2MK) is 30:
!/XSTO!/MFIT        UXSP(:,4) = UXSP(:,4)/MKfac
!/XSTO!/MFIT        UXSP(:,4+NZO) = UXSP(:,4+NZO)/MKfac
!/XSTO!/MFIT        USERO(1:NSEA,1) = USERO(1:NSEA,1)/MKfac
!/XSTO!/MFIT        USERO(1:NSEA,2) = USERO(1:NSEA,2)/MKfac
!/XSTO!/MFIT      ENDWHERE
!/XSTO!/MFIT    ENDIF
!/XSTO!/MFIT    deallocate ( MKfac ) 
!/XSTO!/MFIT    deallocate ( M2K )              
!/XSTO!/RTD          ! Rotate x,y vector back to standard pole
!/XSTO!/RTD          IF ( FLAGUNR ) CALL W3XYRTN(NSEA, UXSP(1:NSEA,2), &
!/XSTO!/RTD                                      UXSP(1:NSEA,3), AnglD)
!/XSTO          IF( SMCGRD ) THEN
!/XSTO!/SMC            CALL W3S2XY_SMC( UXSP(1:NSEA,2), XX )
!/XSTO!/SMC            CALL W3S2XY_SMC( UXSP(1:NSEA,3), XY )
!/XSTO          ELSE
!/XSTO            CALL W3S2XY ( NSEA, NSEA, NX+1, NY, UXSP(1:NSEA,2), MAPSF, XX )
!/XSTO            CALL W3S2XY ( NSEA, NSEA, NX+1, NY, UXSP(1:NSEA,3), MAPSF, XY )
!/XSTO          ENDIF ! SMCGRD
!/XSTO!/MFIT          IF ( .FALSE. ) THEN
!/XSTO! NOTE: The magnitude of wave pseudo momentum spans from O(1e-3) to O(1e+3)
!/XSTO!       Thus it cannot be scaled to a 16-bit integer
!/XSTO!       We might alternatively consider to store xsm * ksc
!/XSTO          IF (NCVARTYPEI.EQ.3) NCVARTYPE=4
!/XSTO!
!/XSTO!/MFIT          END IF
!/XSTO          END IF ! IFP .EQ. 3
!/XSTO!
!
!
! 7) Wave-bottom layer
!
            ! RMS of bottom displacement amplitude
            ELSE IF ( IFI .EQ. 7 .AND. IFJ .EQ. 1 ) THEN
              ! NB: ABA and ABD are the X and Y components of the bottom displacement
!/RTD              ! Rotate x,y vector back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3XYRTN(NSEA, ABA(1:NSEA), ABD(1:NSEA), AnglD)
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( ABA(1:NSEA), XX )
!/SMC                CALL W3S2XY_SMC( ABD(1:NSEA), XY )
              ELSE
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, ABA(1:NSEA)     &
                                                        , MAPSF, XX )
                CALL W3S2XY ( NSEA, NSEA, NX+1, NY, ABD(1:NSEA)     &
                                                        , MAPSF, XY )
              ENDIF ! SMCGRD
              NFIELD=2
!
            ! RMS of bottom velocity amplitude
            ELSE IF ( IFI .EQ. 7 .AND. IFJ .EQ. 2 ) THEN
              ! NB: UBA and UBD are the X and Y components of the bottom velocity
!/RTD              ! Rotate x,y vector back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3XYRTN(NSEA, UBA(1:NSEA), UBD(1:NSEA), AnglD)
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, UBA(1:NSEA)       &
                                                        , MAPSF, XX )
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, UBD(1:NSEA)       &
                                                        , MAPSF, XY )
              NFIELD=2
!
            ! Bottom roughness
            ELSE IF ( IFI .EQ. 7 .AND. IFJ .EQ. 3 ) THEN
!/RTD              ! Rotate x,y vector back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3XYRTN(NSEA, BEDFORMS(1:NSEA,2), &
!/RTD                                           BEDFORMS(1:NSEA,3), AnglD)
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, BEDFORMS(1:NSEA,1)    &
                                                        , MAPSF, X1 )
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, BEDFORMS(1:NSEA,2)    &
                                                        , MAPSF, X2 )
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, BEDFORMS(1:NSEA,3)    &
                                                        , MAPSF, XY )
              NFIELD=3
!
            ! Wave dissipation in bottom boundary layer
            ELSE IF ( IFI .EQ. 7 .AND. IFJ .EQ. 4 ) THEN
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, PHIBBL(1:NSEA)    &
                                                        , MAPSF, X1 )
!
            ! Wave to bottom boundary layer stress
            ELSE IF ( IFI .EQ. 7 .AND. IFJ .EQ. 5 ) THEN
!/RTD              ! Rotate x,y vector back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3XYRTN(NSEA, TAUBBL(1:NSEA,1), &
!/RTD                                           TAUBBL(1:NSEA,2), AnglD)
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, TAUBBL(1:NSEA,1) &
                                                        , MAPSF, XX )
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, TAUBBL(1:NSEA,2) &
                                                        , MAPSF, XY )
              NFIELD=2
!
            ! Mean square slope
            ELSE IF ( IFI .EQ. 8 .AND. IFJ .EQ. 1 ) THEN
!/RTD              ! Rotate x,y vector back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3XYRTN(NSEA, MSSX, MSSY, AnglD)
              CALL W3S2XY ( NSEA, NSEA, NX+1,NY,MSSX,MAPSF, XX )
              CALL W3S2XY ( NSEA, NSEA, NX+1,NY,MSSY,MAPSF, XY )
              NFIELD=2
!
            ! Phillips constant
            ELSE IF ( IFI .EQ. 8 .AND. IFJ .EQ. 2 ) THEN
!/RTD              ! Rotate x,y vector back to standard pole
!/RTD              IF ( FLAGUNR ) CALL W3XYRTN(NSEA, MSCX, MSCY, AnglD)
              CALL W3S2XY ( NSEA, NSEA, NX+1,NY,MSCX,MAPSF, XX )
              CALL W3S2XY ( NSEA, NSEA, NX+1,NY,MSCY,MAPSF, XY )
              NFIELD=2
!
            ! u direction for mss
            ELSE IF ( IFI .EQ. 8 .AND. IFJ .EQ. 3 ) THEN
!/RTD                ! Rotate direction back to standard pole
!/RTD                IF ( FLAGUNR ) CALL W3THRTN(NSEA, MSSD, AnglD, .FALSE.)
              DO ISEA=1, NSEA
                IF ( MSSD(ISEA) .NE. UNDEF )  THEN
                  MSSD(ISEA) = MOD ( 630. - RADE*MSSD(ISEA) , 180. )
                  END IF
                END DO
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, MSSD   , MAPSF, X1 )
!
            ! x direction for msc
            ELSE IF ( IFI .EQ. 8 .AND. IFJ .EQ. 4 ) THEN
!/RTD                ! Rotate direction back to standard pole
!/RTD                IF ( FLAGUNR ) CALL W3THRTN(NSEA, MSCD, AnglD, .FALSE.)
              DO ISEA=1, NSEA
                IF ( MSCD(ISEA) .NE. UNDEF )  THEN
                  MSCD(ISEA) = MOD ( 630. - RADE*MSCD(ISEA) , 180. )
                  END IF
                END DO
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, MSCD   , MAPSF, X1 )
!
             ! Peakedness
             ELSE IF ( IFI .EQ. 8 .AND. IFJ .EQ. 5 ) THEN
              IF( SMCGRD ) THEN
!/SMC                CALL W3S2XY_SMC( QP, X1 )
              ELSE
                 CALL W3S2XY ( NSEA, NSEA, NX+1, NY, QP, MAPSF, X1 )
              ENDIF
!
            ! Dynamic time step
            ELSE IF ( IFI .EQ. 9 .AND. IFJ .EQ. 1 ) THEN
              DO ISEA=1, NSEA
                IF ( DTDYN(ISEA) .NE. UNDEF ) THEN
                  DTDYN(ISEA) = DTDYN(ISEA) / 60.
                  END IF
                END DO
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, DTDYN , MAPSF, X1 )
!
            ! Cut off frequency
            ELSE IF ( IFI .EQ. 9 .AND. IFJ .EQ. 2 ) THEN
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, FCUT  , MAPSF, X1 )
!
            ! Maximum CFL for spatial advection
            ELSE IF ( IFI .EQ. 9 .AND. IFJ .EQ. 3 ) THEN
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, CFLXYMAX  , MAPSF, X1 )
!
            ! Maximum CFL for direction advection
            ELSE IF ( IFI .EQ. 9 .AND. IFJ .EQ. 4 ) THEN
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, CFLTHMAX  , MAPSF, X1 )
!
            ! Maximum CFL for frequency advection
            ELSE IF ( IFI .EQ. 9 .AND. IFJ .EQ. 5 ) THEN
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, CFLKMAX  , MAPSF, X1 )
!
!/MFIT            ELSE IF ( IFI .EQ. 10 .AND. IFJ .EQ. 1 ) THEN
!/MFIT              ! The seven subfields (IFP=1..7) are joined in netCDF file
!/MFIT              NFP = 7 ! Number of subfields loop over IFP=1,NFP
!/MFIT              ! 2D Vectors "S0", "Sd"
!/MFIT            IF ( IFP .EQ. 1 ) THEN
!/MFIT              NFIELD=2
!/MFIT              ! "S0": Surface drift normalized by abs(2MK)+MK0
!/MFIT              ! Normalization was done during output of MKX, MKY
!/MFIT              CALL W3S2XY ( NSEA, NSEA, NX+1, NY,                   &
!/MFIT                            UXSP(:,4), MAPSF, XX )
!/MFIT              CALL W3S2XY ( NSEA, NSEA, NX+1, NY,                   &
!/MFIT                            UXSP(:,4+NZO), MAPSF, XY )
!/MFIT            ELSE IF ( IFP .EQ. 2 ) THEN
!/MFIT              NFIELD=2
!/MFIT              IFK = 1
!/MFIT              ! "Sd": Deep fit surface drift normalized by abs(2MK)+MK0
!/MFIT              CALL W3S2XY ( NSEA, NSEA, NX+1, NY,                   &
!/MFIT                            USERO(:,1), MAPSF, XX )
!/MFIT              CALL W3S2XY ( NSEA, NSEA, NX+1, NY,                   &
!/MFIT                            USERO(:,2), MAPSF, XY )
!/MFIT!
!/MFIT            ELSE IF ( IFP .LE. 7 ) THEN
!/MFIT              ! AM, PM, AMd, PMd, SIC
!/MFIT              NFIELD=1
!/MFIT              IFK=IFP-1
!/MFIT              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, USERO(:,IFP)      &
!/MFIT                                                       , MAPSF, X1 )
!/MFIT            END IF ! IFP
!/MFIT!
            ! User defined...
            ELSE IF ( IFI .EQ. 10 ) THEN
              !CB WRITE (ENAME,'(A2,I2.2)') '.u', IFJ
!/MFIT              IF (.FALSE.) &
              CALL W3S2XY ( NSEA, NSEA, NX+1, NY, USERO(:,IFJ)        &
                                                        , MAPSF, X1 )
!/MFIT               CALL W3S2XY ( NSEA, NSEA, NX+1, NY, USERO(:,8)    &
!/MFIT                                                        , MAPSF, X1 )
            ELSE
              WRITE (NDSE,999) IFI, IFJ
              CALL EXTCDE ( 1 )
!
            END IF ! IFI AND IFJ

            ! CB Get netCDF metadata for IFI, IFJ combination (all components).
            DO I=1,NFIELD
              META(I) = GETMETA(IFI, IFJ+IFK, ICOMP=I, IPART=IPART)
            ENDDO

! 2.2 Make map

            ! CB: TODO - need to handle MAPSTA differently for SMC grid output.
            IF( .NOT. SMCGRD ) THEN
            DO IX=1, NX
              DO IY=1, NY
                MAPOUT(IX,IY)=INT2(MAPSTA(IY,IX) + 8*MAPST2(IY,IX))
                IF ( MAPSTA(IY,IX) .EQ. 0 ) THEN
                  X1(IX,IY) = UNDEF
                  X2(IX,IY) = UNDEF
                  XX(IX,IY) = UNDEF
                  XY(IX,IY) = UNDEF
                END IF
                ! CarstenHansen: Commented out MAP and MP2 not used anywhere.
                ! IF ( X1(IX,IY) .EQ. UNDEF ) THEN
                !   MAP(IX,IY) = 0
                ! ELSE
                !   MAP(IX,IY) = 1
                ! END IF
                ! IF ( X2(IX,IY) .EQ. UNDEF ) THEN
                !   MP2(IX,IY) = 0
                ! ELSE
                !   MP2(IX,IY) = 1
                ! END IF
              END DO
            END DO
            ENDIF ! CB


! 2.3 Setups the output type 4 ( NetCDF file )

      ! Subsections:
      ! 2.3.1 Set flag for the variable to be together or in a separate netCDF
      ! 2.3.2 Set variable name substring (META(1)%ENAME in FNAMENC)
      ! 2.3.3 Initialize dimensions etc.
      ! 2.3.4 Initialize an optional third dimension

! 2.3.1 Set flag for the variable to be together or in a separate netCDF file

            ! FLSEP and NCJID: Control if output goes to to a separate file
            ! 
            ! FLSEP is a logical flag indicating that a field should be put
            ! in a separate netCDF file. This represents one of two uses of
            ! a flag FLFRQ for spectral fields with the third dimension
            ! frequency ('f').
            !  
            ! NCJID (a 'Joint netCDF ID') may be applied for a field that
            ! contains two or more subfields with different units or scales.
            ! 
            ! To manage this, the loop over partition variables is rewritten
            ! to loop over such subfields as well applying a counter IFP 
            ! starting at 1 and incremented by one. Any such subfield
            ! with IFP >= 2, which is NOT a swell partition, is put in the
            ! same file as the field with IFP == 1, even if TOGETHER is .FALSE.
            ! 
            ! An example for FLSEP could apply to the field 
            ! USP (IFI,IFJ = 6,12) as follows in two settings a,b below (this
            ! doesn't change the actual output except for the dimension name):
            ! a) Specify the name of the third dimension, e.g. segmented wave
            ! frequencies DIM3NAME(1:2)='fs' (for how to further modify the
            ! code, look for 'fs' in the comments lines).
            ! b) Set FLSEP=.TRUE. to indicate that the field must be in a
            ! separate netCDF file (similar to FLFRQ=.TRUE. when DIM3NAME=='f').
            ! If you choose FLSEP=.FALSE., the field can go to a common
            ! netCDF if mode TOGETHER is chosen by the user.
            !

            ! FLSEP: Default is .FALSE.
            FLSEP = .FALSE.
            ! The variable goes to a separate file if it has a
            ! frequency 'f' dimension
            FLSEP = (FLSEP .OR. FLFRQ)

            ! The variable goes to a separate file if TOGETHER is .FALSE.
            FLSEP = (FLSEP .OR. .NOT.TOGETHER)

            ! The negation (.NOT. FLSEP) is equivalent to
            ! (TOGETHER .AND. .NOT.FLFRQ)

            ! The index of variable and group at the first
            ! write to a file in mode together
            IF (I1.EQ.0 .AND. .NOT. FLSEP) I1=IFI
            IF (J1.EQ.0 .AND. .NOT. FLSEP) J1=IFJ

            ! NCJID: ID of a joint netCDF file if that is requested
            !        This will overrule a True value of FLSEP for this field
            !        This is not applied for swell partitions with INDEXIPART>1
            NCJID = 0
            IF ( IFP .GT. 1 .AND. FLSEP .AND. INDEXIPART .EQ. 1 ) &
              NCJID = NCIDS(IFI, IFJ, 1) ! is already open

! 2.3.2 Set variable name substring in the name of a new file (ENAME in FNAMENC)

            S2=LEN_TRIM(META(1)%ENAME)
            S1=LEN_TRIM(FILEPREFIX)+S4
            FNAMENC(S1+1:50)='       '
            FNAMENC(S1+1:S1+1) = '_'

            ! If flag TOGETHER and not variable with freq dim &
            ! (ef, p2l, ...), no variable name in file name
            IF (.NOT. FLSEP) THEN 
              S2=0
            ! If NOT flag TOGETHER or variable with freq dim &
            ! (ef, p2l, ...), add variable name in file name
            ELSE
              FNAMENC(S1+2:S1+S2) = META(1)%ENAME(2:S2)
            ENDIF
            ! Defines the netcdf extension
            FNAMENC(S1+S2+1:S1+S2+3) = '.nc'
            FNAMENC(S1+S2+4:S1+S2+6) = '   '

            ! If the field goes to another open file (and not actually
            ! to a separate file),
            IF ( NCJID .NE. 0 ) FLSEP = .FALSE.

            ! Note: From here FLSEP == .TRUE. implies that NCJID == 0.
            ! If NCJID == 0 and FLSEP is True, the variable goes to
            ! a separate netCDF file. If NCJID == 0 and FLSEP is False,
            ! the variable go in a common netCDF id. NCIDS(1,1,1)
            
! 2.3.3 Initialize the space-time grid dimension lengths for a new netCDF file
            
            ! If regular grid, initializes the lat/lon or x/y dimension lenghts
            IF (GTYPE.NE.UNGTYPE) THEN 
              IF( SMCGRD ) THEN
!/SMC                IF( SMCTYPE .EQ. 1 ) THEN
!/SMC                  ! Flat seapoints file
!/SMC                  !dimln(2) = NSEA
!/SMC                  dimln(2) = SMCNOUT
!/SMC                  dimln(3) = -1  ! not used
!/SMC                ELSE
!/SMC                  ! Regular gridded lat/lon file:
!/SMC                  dimln(2) = NXO
!/SMC                  dimln(3) = NYO
!/SMC                ENDIF ! SMCTYPE
              ELSE ! SMCGRD
                DIMLN(2)=IXN-IX1+1
                DIMLN(3)=IYN-IY1+1
              ENDIF ! SMCGRD
            ! If unstructured mesh, initializes the nelem,tri dimension lengths
            ELSE
              DIMLN(2)=IXN-IX1+1
              DIMLN(3)=NTRI
            ENDIF

            ! Three arrays are defined here to contain netCDF id.'s:
            !   DIMID is the netCDF dimension id.'s to be defined for each field,
            !   DIMFIELD is the netCDF dimensions of the individual field, and
            !   VARID the dimension variable id.'s corresponding to DIMID
            !
            ! For an unstructured mesh or an SMC flat grid there is no y
            ! dimension. If the field has a third dimension (e.g. frequency 'f')
            ! in FIELD(x,y,f,time), then the index in DIMID of the time dimension
            ! is also shifted by one from 4 to 5. Let ITD denote this index here:
            !                                                                   
            ! COORD TYPE:  Dims in DIMFIELD:  Dims in DIMID:
            ! Regular   :  (x, y, [f,] time)  (lvl,    x,    y, [f,] time)
            ! SMC flat  :  (cell, [f,] time)  (lvl, cell,   [], [f,] time)
            ! Unstruct  :  (node, [f,] time)  (lvl, node, elem, [f,] time, noel)
            ! INDEX in DIMID:                         2     3  [IT-1] IT  IT+1
            ! INDEX in VARID:                         1     2    10    3    4
            ! (DIMID(1) (lvl='level') is not a dimension of any actual field)

            ! Further, let TDIM be the index in DIMFIELD of the time dimension  
            ! If there is no third dimension:                                   
            TDIM = 3                                                            
!/SMC            IF( SMCTYPE .EQ. 1 ) TDIM = 2                                  
            IF ( GTYPE.EQ.UNGTYPE ) TDIM = 2                                    
            ! If the variable has a third dimension, we will set TDIM = TDIM + 1
            
! 2.3.4 Define an optional third dimension

            ! Allow other third dimensions in addition to 'f' for frequency.
            !
            ! A new third dimension may be added to the code, e.g. segmented
            ! frequencies 'fs'. One third dimension, frequency 'f', already
            ! exists in the code for which a logical flag, FLFRQ, is set. The
            ! netCDF attributes for a third dimension variable ('f' or 'fs')
            ! are defined in the netCDF file using a subroutine W3NCDEF3.
            ! The procedure is constructed so that when such a 3'rd dimension
            ! (other than 'f') is requested, the variable may be put in a netCDF
            ! file together with other variables. However, if a another third
            ! dimension with the same name is requested for another variable,
            ! output is forced to a separate netCDF file.

            ! A binary index EXTRADIM is one or zero depending on the individual
            ! variable having a third dimension or not.
            
            ! By default the variable has no third dimension:
            DIMLN(4)=0
            EXTRADIM = 0
            
            ! By default we only add a new third dimension to the netCDF file
            ! if this is the first timestep in the file
            NEW3D = .FALSE.

            ! If there is a third dimension:            
            IF ( FLFRQ &
              ! ( You may here add condition for other third dimensions: )
              ! .OR. ( TRIM(DIM3NAME) .EQ. 'fs' ) &
!/XSTO           .OR. ( TRIM(DIM3NAME) .EQ. 'zk' ) &
                 ) THEN
              EXTRADIM = 1
              TDIM = TDIM + 1

              ! Define and write a new third dimension if this is the first
              ! timestep in the netCDF file
              IF ( NTIM.EQ.1 ) NEW3D=.TRUE.
            END IF
            
            ! Contents of the new third dimension variable
            IF ( NEW3D ) THEN
              DIMLN(4) = I2F-I1F+1 
              ALLOCATE(DIM3VAR(DIMLN(4)))
              ! (DIM3VAR will be deallocated after write to netCDF)
              IF ( FLFRQ ) THEN
                DIM3NAME = 'f'
                ! Set frequency values
                !BGR Here is where we should tell it what frequencies are.
                IF (CUSTOMFRQ) THEN
                   DIM3VAR(:) = sqrt(GRAV*USSP_WN(1:usspf(2)))*TPIINV
                ELSE
                   DIM3VAR(:) = SIG(I1F:I2F)*TPIINV
                END IF
!/XSTO              ELSE IF ( TRIM(DIM3NAME) .EQ. 'zk' ) THEN
!/XSTO                ! May assert that for 'zk': NZO == I2F-I1F+1
!/XSTO                ! Set values of the dimensionless depths
!/XSTO                ! The dimensionless depths are distributed as expA(i-1)-1:
!/XSTO                ! DIM3VAR(IZ)  = XZK**(IZ-1) - 1.
!/XSTO                ! The exponential base XZK is defined so that the deepest
!/XSTO                ! point is DIM3VAR(XSND) = XSDS,
!/XSTO                XZK = (1. + XSDS)**(1./(XSND-1.))
!/XSTO                ! First calculate XZK**(IZ-1) for IZ = 1,NZO
!/XSTO                zki = 1.
!/XSTO                do IZ = 1,NZO
!/XSTO                  DIM3VAR(IZ) = zki
!/XSTO                  zki = zki * XZK ! = XZK**IZ
!/XSTO                end do
!/XSTO                ! Then subtract 1
!/XSTO                DIM3VAR(:) = DIM3VAR(:) - 1.
              ! The netCDF attributes of DIM3VAR are specified in the
              ! subroutine W3NCDEF3
              END IF ! FLFRQ
            END IF ! .NEW3D.

            ! If we need the third dimension in a netCDF file already open,
            ! check if the third dimension exists, and if it matches
            IF ( NEW3D .AND. .NOT.FLSEP ) THEN
              ! Tentative id. if already open
              OLDNCID=NCJID
              ! If all variables in the same file
              IF ( NCJID .EQ. 0 )  OLDNCID = NCIDS(1,1,1)
              
              CALL W3NCINQ3( OLDNCID, DIM3NAME, DIMID3, DIMLN(4), VCHCK=DIM3VAR )
              IF ( DIMID3 .EQ. -1 ) THEN
                ! If DIM3NAME is defined in the netCDF but doesn't match
                ! DIM3VAR, then nullify the NCJID and write to separate file
                WRITE(NDSE,*) ' Must output to a separate file for IFI,IFJ=',&
                                IFI,IFJ
                FLSEP = .TRUE.
                NCJID = 0
                ! Note: DIM3VAR is kept allocated as long as NEW3D is True
              ELSE IF ( DIMID3 .GE. 1 ) THEN
                ! DIM3NAME already exists in netCDF, and matches the dim var
                NEW3D = .FALSE.
                DEALLOCATE(DIM3VAR)
              END IF
            END IF


! 2.4 Manage netCDF file id

      ! Subsections:
      ! 2.4.1 Save the id of the previous file
      ! 2.4.2 Remove the new file (if not created by the run)
      ! 2.4.3 Finalize the previous file (if a new one will be created)

! 2.4.1 Save the id of the previous file

            IF ( NCJID .NE. 0 ) THEN
              ! the variable in the same file as another variable
              OLDNCID = NCJID
            ELSE IF (.NOT. FLSEP) THEN
              ! all variables in the same file
              OLDNCID = NCIDS(1,1,1)
            ELSE
              ! the variable in a separate file
              OLDNCID = NCIDS(IFI,IFJ,IFP) ! IFP may be an index of a partition
            END IF


! 2.4.2 Remove the new file (if not created by the run)

            INQUIRE(FILE=FNAMENC, EXIST=FEXIST)
            IF (FEXIST) THEN
              FREMOVE = .FALSE.
              ! time splitted condition
              IF (INDEX(TIMEID,OLDTIMEID).EQ.0) THEN
                ! all variables in the same file, and the variable is the first
                ! in a new file
                IF ( .NOT. FLSEP .AND. FIRST_TOGETHER ) FREMOVE = .TRUE.
                ! a file per variable
                IF ( FLSEP ) FREMOVE = .TRUE.
              END IF

              IF (FREMOVE) THEN
                OPEN(UNIT=1234, IOSTAT=IRET, FILE=FNAMENC, STATUS='old')
                IF (IRET == 0) CLOSE(1234, STATUS='delete')
                FEXIST=.FALSE.
              END IF
            END IF

            ! Set FIRST_TOGETHER FALSE for following fields in the file
            IF ( .NOT. FLSEP .AND. FIRST_TOGETHER ) FIRST_TOGETHER = .FALSE.
            
            ! If directed to another file, that file actually exists
            IF (NCJID .NE. 0) FEXIST = .TRUE.
            
            ! From here, FEXIST == .FALSE. means a new file will be created.
            ! If FEXIST is .TRUE., then the file is open with OLDNCID > 0.
            IF (FEXIST) NCID = OLDNCID
            
! 2.4.3 Finalize the previous file (if a new one will be created)

            IF (.NOT.FEXIST) THEN 
              IF (INDEX('0000000000000000',OLDTIMEID).EQ.0 .AND. INDEX(TIMEID,OLDTIMEID).EQ.0) THEN
                IRET = NF90_REDEF(OLDNCID)
                CALL CHECK_ERR(IRET)
                IRET=NF90_PUT_ATT(OLDNCID,NF90_GLOBAL,'stop_date',STRSTOPDATE)
                CALL CHECK_ERR(IRET)
                IRET=NF90_CLOSE(OLDNCID)
                CALL CHECK_ERR(IRET)
              END IF
            END IF


! 2.5 Creates the netcdf file

      ! Subsections:
      ! 2.5.1 Creates the NetCDF file 
      ! 2.5.2 Generates Lat-Lon arrays
      ! 2.5.3 Writes longitudes, latitudes, triangles, frequency and status map

            IF (.NOT.FEXIST) THEN 

              ! Set the size of the 'level' dim
              DIMLN(1)=1

! 2.5.1 Creates the NetCDF file 
              CALL W3CRNC(FNAMENC,NCID,DIMID,DIMLN,VARID, &
                          EXTRADIM,NCTYPE,MAPSTAOUT)

              ! Saves the NCID to keep the file opened to write all the variables
              ! and open/close at each time step
              IF (.NOT. FLSEP) THEN
                NCIDS(1,1,1)=NCID
              ELSE
                NCIDS(IFI,IFJ,IFP)=NCID
              END IF

              ! Define a new third dimension if determined in Sect. 2.3.4
              ! (Keep NEW3D = .TRUE. and DIM3VAR allocated to write the dimension
              ! variable later after having left the netCDF define mode )
              IF ( NEW3D ) &
                CALL W3NCDEF3(NCID,DIM3NAME,DIMID(4),DIMLN(4),VARID(10))

              ! If curvilinear grid, instanciates lat / lon
              IF (GTYPE.EQ.CLGTYPE) THEN
                IF (.NOT.ALLOCATED(LON2D)) ALLOCATE(LON2D(NX,NY),LAT2D(NX,NY))
                LON2D=TRANSPOSE(XGRD)
                LAT2D=TRANSPOSE(YGRD)
                IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL, &
                                     'latitude_resolution','n/a')
                CALL CHECK_ERR(IRET)
                IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL, &
                                     'longitude_resolution','n/a')
                CALL CHECK_ERR(IRET)
              ! If NOT curvilinear grid,
              ELSE 
                IF( SMCGRD ) THEN
!/SMC                   IF(SMCTYPE .EQ. 1) THEN
!/SMC                     ! Flat seapoints file
!/SMC                     IF(.NOT.ALLOCATED(lon)) ALLOCATE(lon(SMCNOUT))
!/SMC                     IF(.NOT.ALLOCATED(lat)) ALLOCATE(lat(SMCNOUT))
!/SMC                     IF(.NOT.ALLOCATED(smccx)) ALLOCATE(smccx(SMCNOUT))
!/SMC                     IF(.NOT.ALLOCATED(smccy)) ALLOCATE(smccy(SMCNOUT))
!/SMC                   ELSE
!/SMC                     ! Regular gridded file
!/SMC                     IF(.NOT.ALLOCATED(lon)) ALLOCATE(lon(NXO))
!/SMC                     IF(.NOT.ALLOCATED(lat)) ALLOCATE(lat(NYO))
!/RTD                     ! Intermediate EQUatorial lat/lon arrays for de-rotation
!/RTD                     ! of rotated pole coordinates:
!/RTD                     !!IF(.NOT.ALLOCATED(LON2DEQ)) ALLOCATE(LON2DEQ(NXO,NYO))
!/RTD                     !!IF(.NOT.ALLOCATED(LAT2DEQ)) ALLOCATE(LAT2DEQ(NXO,NYO))
!/RTD                     !
!/RTD                     ! Use local RTDNX/RTDNY variables until CPP implemented to
!/RTD                     ! avoid compile error when SMC switch not enabled (C.Bunney):
!/RTD                     IF(.NOT.ALLOCATED(LON2DEQ)) ALLOCATE(LON2DEQ(RTDNX,RTDNY))
!/RTD                     IF(.NOT.ALLOCATED(LAT2DEQ)) ALLOCATE(LAT2DEQ(RTDNX,RTDNY))
!/SMC                   ENDIF
!/RTD                   ! Arrays for de-rotated lat/lon coordinates:
!/RTD                   IF(.NOT.ALLOCATED(LON2D)) THEN
!/RTD                      !!ALLOCATE(LON2D(NXO,NYO), LAT2D(NXO,NYO))
!/RTD                      !!ALLOCATE(ANGLD2D(NXO,NYO))
!/RTD                      !
!/RTD                      ! Use local RTDNX/RTDNY variables until CPP implemented to
!/RTD                      ! avoid compile error when SMC switch not enabled (C.Bunney):
!/RTD                      ALLOCATE(LON2D(RTDNX,RTDNY), LAT2D(RTDNX,RTDNY))
!/RTD                      ALLOCATE(ANGLD2D(RTDNX,RTDNY))
!/RTD                   ENDIF
                ELSE ! SMCGRD
                  ! instanciates lon with x/lon for regular grid or nodes for unstructured mesh
                  IF (.NOT.ALLOCATED(LON)) ALLOCATE(LON(NX))
!/RTD                  ! 2d longitude array for standard grid coordinates
!/RTD                  IF ( RTDL .AND. .NOT.ALLOCATED(LON2D)) &
!/RTD                    ALLOCATE(LON2D(NX,NY),LON2DEQ(NX,NY),ANGLD2D(NX,NY))
                  IF (.NOT.ALLOCATED(LAT)) THEN 
                    ! If regular grid, instanciates lat with y/lat
                    IF (GTYPE.EQ.RLGTYPE) THEN 
                      ALLOCATE(LAT(NY))
!/RTD                      ! 2d latitude array for standard grid coordinates
!/RTD                      IF ( RTDL .AND. .NOT.ALLOCATED(LAT2D)) &
!/RTD                        ALLOCATE(LAT2D(NX,NY),LAT2DEQ(NX,NY))
                    ! If unstructured mesh, instanciates lat with nodes
                    ELSE 
                      ALLOCATE(LAT(NX))
                    END IF 
                  END IF
                END IF ! SMCGRD
              END IF


! 2.5.2 Generates Lat-Lon arrays

              ! If regular grid
              IF (GTYPE.EQ.RLGTYPE) THEN 
                IF( SMCGRD ) THEN
!/SMC                  ! CB: Calculate lat/lons of SMC grid
!/SMC                  IF( SMCTYPE .EQ. 1 ) THEN
!/SMC                    ! CB: Flat seapoints file
!/SMC                    DO i=1,SMCNOUT
!/SMC                       j = SMCIDX(i)
!/SMC                       lon(i) = (X0-0.5*SX) + (IJKCel(1,j) + 0.5 * IJKCel(3,j)) * dlon
!/SMC                       lat(i) = (Y0-0.5*SY) + (IJKCel(2,j) + 0.5 * IJKCel(4,j)) * dlat
!/SMC                       smccx(i) = IJKCel(3,j)
!/SMC                       smccy(i) = IJKCel(4,j)
!/SMC                    ENDDO
!/RTD                    !!CALL W3EQTOLL(lat, lon, LAT2D(:,1), LON2D(:,1),       &
!/RTD                    !!              ANGLD2D(:,1), POLAT, POLON, NYO*NXO)
!/RTD                    !
!/RTD                    ! Use local RTDNX/RTDNY variables until CPP implemented to
!/RTD                    ! avoid compile error when SMC switch not enabled (C.Bunney):
!/RTD                    CALL W3EQTOLL(lat, lon, LAT2D(:,1), LON2D(:,1),       &
!/RTD                                  ANGLD2D(:,1), POLAT, POLON, RTDNY*RTDNX)
!/SMC                  ELSE
!/SMC                    ! CB: Regridded SMC data
!/SMC                    SXD=DBLE(0.000001d0*DNINT(1d6*(DBLE(DXO)) ))
!/SMC                    SYD=DBLE(0.000001d0*DNINT(1d6*(DBLE(DYO)) ))
!/SMC                    X0D=DBLE(0.000001d0*DNINT(1d6*(DBLE(SXO)) ))
!/SMC                    Y0D=DBLE(0.000001d0*DNINT(1d6*(DBLE(SYO)) ))
!/SMC                    DO i=1,NXO
!/SMC                      lon(i)=REAL(X0D+SXD*DBLE(i-1))
!/RTD                      LON2DEQ(i,:) = lon(i)
!/SMC                    END DO
!/SMC                    DO i=1,NYO
!/SMC                      lat(i)=REAL(Y0D+SYD*DBLE(i-1))
!/RTD                      LAT2DEQ(:,i) = lat(i)
!/SMC                    END DO
!/SMC                    WRITE(STR2,'(F12.7)') DYO
!/SMC                    STR2=ADJUSTL(STR2)
!/SMC                    IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,   &
!/SMC                             'latitude_resolution', TRIM(str2))
!/SMC                    WRITE(STR2,'(F12.7)') DXO
!/SMC                    STR2=ADJUSTL(STR2)
!/SMC                    IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,   &
!/SMC                             'longitude_resolution',TRIM(str2))
!/RTD                    !!CALL W3EQTOLL(LAT2DEQ, LON2DEQ, LAT2D, LON2D,       &
!/RTD                    !!              ANGLD2D, POLAT, POLON, NYO*NXO)
!/RTD                    !
!/RTD                    ! Use local RTDNX/RTDNY variables until CPP implemented to
!/RTD                    ! avoid compile error when SMC switch not enabled (C.Bunney):
!/RTD                    CALL W3EQTOLL(LAT2DEQ, LON2DEQ, LAT2D, LON2D,       &
!/RTD                                  ANGLD2D, POLAT, POLON, RTDNY*RTDNX)
!/SMC                  ENDIF ! SMCTYPE
                ELSE ! SMCGRD
                    SXD=DBLE(0.000001d0*DNINT(1d6*(DBLE(SX)) ))
                    SYD=DBLE(0.000001d0*DNINT(1d6*(DBLE(SY)) ))
                    X0D=DBLE(0.000001d0*DNINT(1d6*(DBLE(X0)) ))
                    Y0D=DBLE(0.000001d0*DNINT(1d6*(DBLE(Y0)) ))
                    DO I=1,NX
                      LON(I)=REAL(X0D+SXD*DBLE(I-1))
                    END DO
                    DO I=1,NY
                      LAT(I)=REAL(Y0D+SYD*DBLE(I-1))
                    END DO
!/RTD                  IF ( RTDL ) THEN
!/RTD                    ! Calculate the standard grid coordinates
!/RTD                    DO I=1,NX
!/RTD                      LON2DEQ(I,:)=LON(I)
!/RTD                    END DO
!/RTD                    DO I=1,NY
!/RTD                      LAT2DEQ(:,I)=LAT(I)
!/RTD                    END DO                    
!/RTD                    CALL W3EQTOLL(LAT2DEQ, LON2DEQ, LAT2D, LON2D,       &
!/RTD                                  ANGLD2D, POLAT, POLON, NY*NX)
!/RTD                  END IF ! RTDL
                  WRITE(STR2,'(F12.0)') SY
                  STR2=ADJUSTL(STR2)
                  IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,   &
                           'latitude_resolution', TRIM(STR2))
                  CALL CHECK_ERR(IRET)
                  WRITE(STR2,'(F12.0)') SX 
                  STR2=ADJUSTL(STR2)
                  IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,   &
                           'longitude_resolution',TRIM(STR2))
                  CALL CHECK_ERR(IRET)
                END IF ! SMCGRD
              END IF

              ! If unstructured mesh
              IF (GTYPE.EQ.UNGTYPE) THEN 
                LON(:)=XYB(:,1) 
                LAT(:)=XYB(:,2)
                IF (.NOT.ALLOCATED(TRIGP2)) ALLOCATE(TRIGP2(3,NTRI))
                DIMLN(2)=NX
                DIMLN(3)=NTRI
                TRIGP2=TRANSPOSE(TRIGP)
                IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL, &
                                     'latitude_resolution','n/a')
                CALL CHECK_ERR(IRET)
                IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL, &
                                     'longitude_resolution','n/a')
                CALL CHECK_ERR(IRET)
              END IF

              ! Finishes declaration part in file by adding geographical bounds
              IF(SMCGRD) THEN
                WRITE(STR2,'(F12.0)') MINVAL(LAT)
              ELSE
                WRITE(STR2,'(F12.0)') MINVAL(YGRD)
              ENDIF
              STR2=ADJUSTL(STR2)
              IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,  &
                   'southernmost_latitude',TRIM(STR2))
              CALL CHECK_ERR(IRET)

              IF(SMCGRD) THEN
                WRITE(STR2,'(F12.0)') MAXVAL(LAT)
              ELSE
                WRITE(STR2,'(F12.0)') MAXVAL(YGRD)
              ENDIF
              STR2=ADJUSTL(STR2)
              IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,  &
                   'northernmost_latitude',TRIM(STR2))
              CALL CHECK_ERR(IRET)

              IF(SMCGRD) THEN
                WRITE(STR2,'(F12.0)') MINVAL(LON)
              ELSE
                WRITE(STR2,'(F12.0)') MINVAL(XGRD)
              ENDIF
              STR2=ADJUSTL(STR2)
              IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,  &
                  'westernmost_longitude',TRIM(STR2))
              CALL CHECK_ERR(IRET)


              IF(SMCGRD) THEN
                WRITE(STR2,'(F12.0)') MAXVAL(LON)
              ELSE
                WRITE(STR2,'(F12.0)') MAXVAL(XGRD)
              ENDIF
              STR2=ADJUSTL(STR2)
              IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,  &
                  'easternmost_longitude',TRIM(STR2))
              CALL CHECK_ERR(IRET)
              IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,  &
                  'minimum_altitude','-12000 m')
              CALL CHECK_ERR(IRET)
              IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,  &
                  'maximum_altitude','9000 m')
              CALL CHECK_ERR(IRET)
              IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,  &
                  'altitude_resolution','n/a')
              CALL CHECK_ERR(IRET)

!/RTD              IF ( RTDL ) THEN
!/RTD                  IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,  &
!/RTD                      'grid_north_pole_latitude',POLAT)
!/RTD                  IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,  &
!/RTD                      'grid_north_pole_longitude',POLON)
!/RTD                END IF
              
              CALL T2D(TIME,STARTDATE,IERR)
              WRITE(STRSTARTDATE,'(I4.4,A,4(I2.2,A),I2.2)') STARTDATE(1),'-',STARTDATE(2),'-', &
                    STARTDATE(3),' ',STARTDATE(5),':',STARTDATE(6),':',STARTDATE(7)

! 2.5.3 Writes longitudes, latitudes, triangles, frequency and status map (mapsta) to netcdf file

              ! End of define mode of netCDF file (will re-enter in Sect. 2.6.3
              ! to define the variables identifiers)
              IRET = NF90_ENDDEF(NCID)
              CALL CHECK_ERR(IRET)

              ! If regular grid
              IF (GTYPE.EQ.RLGTYPE) THEN 
                IF(SMCGRD) THEN ! CB: shelter original code from SMC grid
!/SMC                  IRET=NF90_PUT_VAR(NCID,VARID(1),LON(:))
!/SMC                  CALL CHECK_ERR(IRET)
!/SMC                  IRET=NF90_PUT_VAR(NCID,VARID(2),LAT(:))
!/SMC                  CALL CHECK_ERR(IRET)
!/SMC                  IF(SMCTYPE .EQ. 1) THEN
!/SMC                    ! For type 1 SCM file also put lat/lons and cell sizes:
!/SMC                    IRET=NF90_PUT_VAR(NCID,VARID(5),SMCCX)
!/SMC                    CALL CHECK_ERR(IRET)
!/SMC                    IRET=NF90_PUT_VAR(NCID,VARID(6),SMCCY)
!/SMC                    CALL CHECK_ERR(IRET)
!/SMC                  ENDIF
                ELSE ! SMCGRD
                  IRET=NF90_PUT_VAR(NCID,VARID(1),LON(IX1:IXN))
                  CALL CHECK_ERR(IRET)
                  IRET=NF90_PUT_VAR(NCID,VARID(2),LAT(IY1:IYN))
                  CALL CHECK_ERR(IRET)
                ENDIF ! SMCGRD
!/RTD                IF ( RTDL ) THEN
!/RTD                  IRET=NF90_PUT_VAR(NCID,VARID(7),LON2D(IX1:IXN,IY1:IYN))
!/RTD                  CALL CHECK_ERR(IRET)
!/RTD                  IRET=NF90_PUT_VAR(NCID,VARID(8),LAT2D(IX1:IXN,IY1:IYN))
!/RTD                  CALL CHECK_ERR(IRET)
!/RTD                  END IF
              END IF

              ! If curvilinear grid
              IF (GTYPE.EQ.CLGTYPE) THEN 
                IRET=NF90_PUT_VAR(NCID,VARID(1),LON2D(IX1:IXN,IY1:IYN))
                CALL CHECK_ERR(IRET)
                IRET=NF90_PUT_VAR(NCID,VARID(2),LAT2D(IX1:IXN,IY1:IYN))
                CALL CHECK_ERR(IRET)
              END IF

              ! If unstructured mesh
              IF (GTYPE.EQ.UNGTYPE) THEN 
                IRET=NF90_PUT_VAR(NCID,VARID(1),LON(IX1:IXN))
                CALL CHECK_ERR(IRET)
                IRET=NF90_PUT_VAR(NCID,VARID(2),LAT(IX1:IXN))
                CALL CHECK_ERR(IRET)
              END IF


              ! Writes triangles to netcdf file
              IF (GTYPE.EQ.UNGTYPE) THEN
                IRET=NF90_PUT_VAR(NCID,VARID(4),TRIGP2)
                CALL CHECK_ERR(IRET)
              END IF

              ! Writes status map array
              IF (MAPSTAOUT.EQ.1) THEN 
                START(1)=1
                START(2)=1
                COUNT(1)=IXN-IX1+1
                COUNT(2)=IYN-IY1+1
                IF (GTYPE.NE.UNGTYPE) THEN
                  IRET=NF90_PUT_VAR(NCID,VARID(20),MAPOUT(IX1:IXN,IY1:IYN), &
                                     (/START(1:2)/),(/COUNT(1:2)/))
                ELSE
                  IRET=NF90_PUT_VAR(NCID,VARID(20),MAPOUT(IX1:IXN,1),(/START(1)/),(/COUNT(1)/))
                ENDIF
                CALL CHECK_ERR(IRET)
              END IF

              WRITE (NDSO,973) FNAMENC

              ! Now the netCDF file has been created with space-time dimensions
              ! and attributes

              ! If it is the first time step (NTIM == 1) for the field, we
              ! still need to define the fields (I=1,NFIELD) and optional third
              ! 'spectral' dimension. This will be done in Sect. 2.6.3

! 2.6 Append data to the existing file

      ! Subsections:
      ! 2.6.1 Get the dimensions from the netcdf header
      ! 2.6.2 (-> Sect. 1.4) Increments the time step for existing file
      ! 2.6.3 Defines or gets the variables identifiers
      ! 2.6.4 Defines the current time step and index
      ! 2.6.5 Puts field(s) in NetCDF file                

            ELSE  ! FEXIST

! 2.6.1 Get the dimensions from the netcdf header

              ! If it is an unstructured mesh
              IF (GTYPE.EQ.UNGTYPE) THEN
                IRET=NF90_INQ_VARID (NCID, 'tri', VARID(4))
                CALL CHECK_ERR(IRET)
              ! If it is a regular grid
              ELSE
                ! If it is spherical coordinate
                IF (FLAGLL) THEN
                  IF(SMCGRD) THEN
!/SMC                    IF(SMCTYPE .EQ. 1) THEN
!/SMC                      IRET=NF90_INQ_DIMID (NCID, 'seapoint', DIMID(2))
!/SMC                    ELSE
!/SMC                      IRET=NF90_INQ_DIMID (NCID, 'longitude', DIMID(2))
!/SMC                      IRET=NF90_INQ_DIMID (NCID, 'latitude', DIMID(3))
!/SMC                    ENDIF
                  ELSE
                    IRET=NF90_INQ_DIMID (NCID, 'longitude', DIMID(2))
                    IRET=NF90_INQ_DIMID (NCID, 'latitude', DIMID(3))
                  ENDIF ! SMCGRD
                  IRET=NF90_INQ_VARID (NCID, 'longitude', VARID(1))
                  IRET=NF90_INQ_VARID (NCID, 'latitude', VARID(2))
                ! If it is cartesian coordinate
                ELSE
                  IRET=NF90_INQ_DIMID (NCID, 'x', DIMID(2))
                  IRET=NF90_INQ_VARID (NCID, 'x', VARID(1))
                  IRET=NF90_INQ_DIMID (NCID, 'y', DIMID(3)) 
                  IRET=NF90_INQ_VARID (NCID, 'y', VARID(2))
                END IF 
                CALL CHECK_ERR(IRET)
              END IF
              ! Get the dimension time
              IRET=NF90_INQ_DIMID (NCID, 'time', DIMID(4+EXTRADIM))
              IRET=NF90_INQ_VARID (NCID, 'time', VARID(3))
              CALL CHECK_ERR(IRET)
              
              ! Define or get a third dimension (e.g. DIM3NAME='f')
!/XSTO        ! (or DIM3NAME='zk')
              IF ( NEW3D ) THEN
                ! A new third dimension has to be defined in an existing file
                IRET = NF90_REDEF(NCID)
                CALL W3NCDEF3( NCID, DIM3NAME, DIMID(4), DIMLN(4), VARID(10) )
                IF ( IRET .EQ. NF90_NOERR ) THEN
                  IRET = NF90_ENDDEF(NCID)
                  CALL CHECK_ERR(IRET)
                END IF
                ! (Keep NEW3D = .TRUE. and DIM3VAR allocated to write the
                ! variable contents later)
              ELSE IF (EXTRADIM.EQ.1) THEN
                 IRET=NF90_INQ_DIMID (NCID, DIM3NAME, DIMID(4))
              END IF

              CALL CHECK_ERR(IRET)
              
            END IF  ! FEXIST

! 2.6.2 Increments the time step for existing file
        ! The time step NTIM has been incremented in Sect. 1.4 .
        ! NTIM is reset to 1 when the time stamp in files is updated

! 2.6.3 Defines or gets the variables identifiers

            ! Defines index of first field variable
            IVAR1=21
            
            ! If it is the first time step, define all the variables and attributes            
            IF (NTIM.EQ.1) THEN

              ! We reach here from one of two cases:
              ! - From Sect. 2.5 where the netCDF file was created for the first
              !   output variable.
              ! - From Sect. 2.6.1 for a new variable to existing file

              ! If we require a new 3'rd dimension as determined in Sect. 2.3.4
              IF ( NEW3D ) THEN
                ! Write to netCDF, e.g. Frequencies
                ! VARID(10) has been determined in Sect. 2.5.1 or 2.6.1
                IRET = NF90_PUT_VAR(NCID, VARID(10), DIM3VAR)
                CALL CHECK_ERR(IRET)
                DEALLOCATE(DIM3VAR)
                NEW3D=.FALSE.
              END IF

              ! Defines the fields(LON,LAT,time) of the variable (i.e. ucur,vcur for current variable)

              ! Re-enter define mode of netCDF file (we left define mode in
              ! Sect. 2.5.3 to write dimensions variables and status map)
              IRET = NF90_REDEF(NCID)
              CALL CHECK_ERR(IRET)

              ! The field indices depend on the grid being regular or 'flat'
              ! TDIM: Index in DIMFIELD of time dimension. TDIM has been set
              ! in Sect. 2.3.4

              ! The first index is x, lon, SMC cell, or node:
              DIMFIELD(1) = DIMID(2)
              ! 'y' or 'lat' for regular grid, will else be overwritten:
              DIMFIELD(2) = DIMID(3)
              ! Third dimension (e.g. 'f'):
              IF ( EXTRADIM.EQ.1 ) DIMFIELD(TDIM-1) = DIMID(4)
              ! Time dimension:
              DIMFIELD(TDIM) = DIMID(4+EXTRADIM)

              ! Loops on all the fields of the variable (i.e. ucur/vcur for current)
              DO I=1,NFIELD
                IVAR=IVAR1+I
!/SMC!
!/SMC                IF( SMCTYPE .EQ. 1 ) THEN
!/SMC                  ! SMC Flat file
!/SMC                  IF (NCVARTYPE.EQ.2) THEN 
!/SMC                    IRET = NF90_DEF_VAR(NCID,META(I)%varnm, NF90_SHORT, (/DIMFIELD(1), DIMFIELD(TDIM)/), VARID(IVAR))
!/SMC                    CALL CHECK_ERR(IRET)
!/SMC                  ELSE
!/SMC                    IRET = NF90_DEF_VAR(NCID,META(I)%varnm, NF90_FLOAT, (/DIMFIELD(1), DIMFIELD(TDIM)/), VARID(IVAR))
!/SMC                    CALL CHECK_ERR(IRET)
!/SMC                  ENDIF
!/SMC                ELSE ! SMCTYPE .EQ. 1
!/SMC!                
                  IF (NCVARTYPE.EQ.2) THEN 
                    IRET=NF90_DEF_VAR(NCID,META(I)%VARNM, NF90_SHORT, DIMFIELD(1:TDIM), VARID(IVAR))
                    CALL CHECK_ERR(IRET)
                  ELSE
                    IRET=NF90_DEF_VAR(NCID,META(I)%VARNM, NF90_FLOAT, DIMFIELD(1:TDIM), VARID(IVAR))
                    CALL CHECK_ERR(IRET)
                  END IF
!/NC4                  IF (NCTYPE.EQ.4) THEN
!/NC4                    IRET = NF90_DEF_VAR_DEFLATE(NCID, VARID(IVAR), 1, 1, DEFLATE)
!/NC4                    CALL CHECK_ERR(IRET)
!/NC4                  ENDIF
!/SMC!
!/SMC                ENDIF ! SMCTYPE .EQ. 1

                  ! Set scale factor to 1.0 if using FLOAT variables for output
                  IF(NCVARTYPE .GT. 2) META(I)%FSC = 1.0

                  !! CB - USE NEW W3META MODULE
                  CALL WRITE_META(NCID, VARID(IVAR), META(I), IRET) ! CB
                  CALL CHECK_ERR(IRET) ! CB
!
!/RTD                IF ( RTDL ) THEN
!/RTD                  ! Add grid mapping attribute for rotated pole grids:
!/RTD                  IRET=NF90_PUT_ATT(NCID,VARID(IVAR),'grid_mapping',    &
!/RTD                                    'rotated_pole')
!/RTD                  CALL CHECK_ERR(IRET)
!/RTD                  END IF
!/RTD!
              END DO
!
              ! put START date in global attribute
              IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,'start_date',STRSTARTDATE)
              CALL CHECK_ERR(IRET)
!
              IRET = NF90_ENDDEF(NCID)
              CALL CHECK_ERR(IRET)

            END IF  ! NTIM.EQ.1

           ! If it is not the first time step, get all VARID from the netcdf file opened
            IF (NTIM.GT.1) THEN 
              DO I=1,NFIELD
                ! Get meta-data for field
                !META = GETMETA(IFI, IFJ, ICOMP=I, IPART=IPART)
                IVAR=IVAR1+I
                IRET=NF90_INQ_VARID (NCID, META(I)%VARNM, VARID(IVAR))
                CALL CHECK_ERR(IRET)
              END DO  
            END IF                

! 2.6.4 Defines the current time step and index
     
            CALL T2D(TIME,CURDATE,IERR)
            OUTJULDAY=TSUB(REFDATE,CURDATE)

            IF ( NCJID .NE. 0 ) FNAMENC(:)='(id.)'
            WRITE(NDSO,'(A,A9,A,I6,A,I4,A,I2.2,A,I2.2,A,I2.2,A,I2.2,A,I2.2,2A)')        &
                    'Writing new record ', META(1)%ENAME(2:) ,'number ',NTIM,    &
                    ' for ',CURDATE(1),':',CURDATE(2),':',CURDATE(3),'T',CURDATE(5),&
                    ':',CURDATE(6),':',CURDATE(7),' in file ',TRIM(FNAMENC)



            ! Defines starting point and size of arrays to be written
            START(1)=1
            START(2)=1
            START(3)=1
            START(4)=1

            ! Sets time index
            START(TDIM)=NTIM
            ! TDIM is the index in DIMFIELD of the time dim. (Sect. 2.3.4)
            COUNT(1)=IXN-IX1+1
            COUNT(2)=IYN-IY1+1
            COUNT(3)=1
            COUNT(4)=1

            ! Puts time in NetCDF file
            IF ( (IFI.EQ.I1 .AND. IFJ.EQ.J1 .AND. IFP.EQ.1) .OR. FLSEP ) THEN
              IVAR1 = 21
              IRET=NF90_PUT_VAR(NCID,VARID(3),OUTJULDAY,(/NTIM/))
              CALL CHECK_ERR(IRET)
            END IF
!
! 2.6.5 Puts field(s) in NetCDF file
!
            ! The START and COUNT above are for EXTRADIM==0 and a regular 2D
            ! grid. If EXTRADIM==1, START(EDIM=TDIM-1) will be incremented by 1
            ! on each loop over the third array index IK=I1F,I2F (see below).
            !
            ! For a regular grid ( SMCTYPE == 2 or .NOT.UNGTYPE ) we have
            ! if EXTRADIM==0: TDIM=3; START=(/1,1,NTIM/); COUNT=(/NX,NY,1/)
            ! if EXTRADIM==1: TDIM=4; START=(/1,1,IK,NTIM/); COUNT=(/NX,NY,1,1/)
            ! 
            ! For flat sea point array, let NX == COUNT(1) = IXN-IX1+1. We have:
            ! if EXTRADIM==0: TDIM=2; START=(/1,NTIM/); COUNT=(/NX,1/)
            ! if EXTRADIM==1: TDIM=3; START=(/1,IK,NTIM/); COUNT=(/NX,1,1/)
            !
            ! For flat sea point array IY1 = 1, IYN = 1, because
            ! NY = 1 for GTYPE.EQ.UNGTYPE. This is set by ww3_grid. ww3_ounf
            ! sets IY1 = MAX (NML_FILE%IY0, 1), IYN = MIN (NML_FILE%IYN, NY)
            ! with default values IY0 = 1, IYN = 1.
            
            IF (EXTRADIM.EQ.1) THEN
              ! The field variable has a third 'spectral' dimension
              EDIM = TDIM - 1
              START(EDIM) = 0 ! To be incremented by 1 in each step IK=I1F,I2F
            ELSE
              I1F = 0
              I2F = 0
              ! X1, X2, and XY are applied directly except if NFIELD.EQ.2,
              IF (NFIELD.EQ.2) THEN
                X1(:,:)=XX(:,:)
                X2(:,:)=XY(:,:)
              END IF
            END IF

            DO IK=I1F,I2F
              ! IK==I1F==I2F==0 unless EXTRADIM==1
              IF (EXTRADIM.EQ.1) THEN
                ! Increment START(EDIM) by 1
                START(EDIM) = START(EDIM)+1
                ! Copy the 2D field for each index IK of the third dim
                IF ( NFIELD.EQ.1 ) THEN
                  X1(:,:) = XK(:,:,IK)
                ELSE IF ( NFIELD.EQ.2 ) THEN
                  X1(:,:) = XXK(:,:,IK)
                  X2(:,:) = XYK(:,:,IK)
                ELSE
                  ! Implementation of an eventual variable with NFIELD==3 and
                  ! EXTRADIM==1 has to be completed here
                  WRITE(NDSE,*) ' *** WAVEWATCH III ERROR IN OUNF :'
                  WRITE(NDSE,*) ' No program code for NFIELD==3 with a third dim'
                  CALL EXTCDE ( 45 )                  
                END IF
              END IF
              
              IF ( .NOT. SMCGRD ) THEN
                DO IX=1, NX
                  DO IY=1, NY
                    IF ( MAPSTA(IY,IX) .LE. 0 ) &
                         X1(IX,IY) = MFILLR
                  END DO
                END DO
              END IF
!/SMC         ! TODO: Find some other way to access MAPSTA
              
              WHERE ( X1(IX1:IXN,IY1:IYN) .EQ. UNDEF )
                X1(IX1:IXN,IY1:IYN) = MFILLR
              END WHERE
              
!
! Short type output (NCVARTYPE.EQ.2)
!
              IF ( NCVARTYPE.EQ.2 ) THEN
                WHERE ( X1(IX1:IXN,IY1:IYN) .EQ. MFILLR )
                  MX1(IX1:IXN,IY1:IYN) = MFILL
                ELSEWHERE
                  MX1(IX1:IXN,IY1:IYN) = NINT(X1(IX1:IXN,IY1:IYN)/META(1)%FSC)
                END WHERE
                IF (NFIELD.GE.2 ) THEN
                  WHERE ( X1(IX1:IXN,IY1:IYN) .EQ. MFILLR )
                    MXX(IX1:IXN,IY1:IYN) = MFILL
                  ELSEWHERE
                    MXX(IX1:IXN,IY1:IYN) = NINT(X2(IX1:IXN,IY1:IYN)/META(2)%FSC)
                  END WHERE
                END IF
                IF (NFIELD.EQ.3 ) THEN
                  WHERE ( X1(IX1:IXN,IY1:IYN) .EQ. MFILLR )
                    MXY(IX1:IXN,IY1:IYN) = MFILL
                  ELSEWHERE
                    MXY(IX1:IXN,IY1:IYN) = NINT(XY(IX1:IXN,IY1:IYN)/META(3)%FSC)
                  END WHERE
                END IF
!
! Real type output (NCVARTYPE.GE.3)
!
              ELSE
                IF (NFIELD.GE.2 ) THEN
                  WHERE ( X1(IX1:IXN,IY1:IYN) .EQ. MFILLR )
                    X2(IX1:IXN,IY1:IYN) = MFILLR
                  END WHERE
                END IF                   
                IF (NFIELD.EQ.3 ) THEN
                  WHERE ( X1(IX1:IXN,IY1:IYN) .EQ. MFILLR )
                    XY(IX1:IXN,IY1:IYN) = MFILLR
                  END WHERE
                END IF                    
              END IF ! NCVARTYPE

!
! Write the fields to NetCDF
!
              IF ( NCVARTYPE.EQ.2 ) THEN
                ! Short type output
                IRET=NF90_PUT_VAR(NCID,VARID(IVAR1+1),               &
                    MX1(IX1:IXN,IY1:IYN),START(1:TDIM),COUNT(1:TDIM))
              ELSE
                 ! Real type output
                 IRET=NF90_PUT_VAR(NCID,VARID(IVAR1+1),               &
                    X1(IX1:IXN,IY1:IYN),START(1:TDIM),COUNT(1:TDIM))
              END IF              
              call CHECK_ERR(IRET)              
              IF (NFIELD.GE.2 ) THEN
                IF ( NCVARTYPE.EQ.2 ) THEN
                   IRET=NF90_PUT_VAR(NCID,VARID(IVAR1+2),             &
                       MXX(IX1:IXN,IY1:IYN),START(1:TDIM),COUNT(1:TDIM))
                ELSE
                  IRET=NF90_PUT_VAR(NCID,VARID(IVAR1+2),             &
                       X2(IX1:IXN,IY1:IYN),START(1:TDIM),COUNT(1:TDIM))
                END IF
                call CHECK_ERR(IRET)
              END IF
              IF (NFIELD.EQ.3 ) THEN
                IF ( NCVARTYPE.EQ.2 ) THEN
                  IRET=NF90_PUT_VAR(NCID,VARID(IVAR1+3),             &
                       MXY(IX1:IXN,IY1:IYN),START(1:TDIM),COUNT(1:TDIM))
                ELSE
                  IRET=NF90_PUT_VAR(NCID,VARID(IVAR1+3),             &
                       XY(IX1:IXN,IY1:IYN),START(1:TDIM),COUNT(1:TDIM))
                END IF
                call CHECK_ERR(IRET)                
              END IF
!                  
            END DO ! IK=I1F,I2F where IK==I1F==I2F==0 unless EXTRADIM==1

            ! updates the variable index
            IVAR1=IVAR1+NFIELD

          ! Repeat if there are extra partitions or subfields for the
          ! group (IFI,IFJ)
          IF ( NFP .GT. NFPMAX ) THEN
            ! This must never occur for the user
            WRITE(NDSE,*) 'Hardcoded configuration error: NFP > NFPMAX'
            CALL EXTCDE(1)
            END IF
          END DO ! WHILE IFP .LE. NFP
!      
        END DO  ! IFJ=1, NGRPP
      END DO  ! IFI=1, NOGRP
!
! Clean up
      DEALLOCATE(X1, X2, XX, XY)
      IF ( ALLOCATED(XK) ) DEALLOCATE(XK, XXK, XYK)
      DEALLOCATE(MX1, MXX, MXY, MAPOUT)
      IF (ALLOCATED(LON)) DEALLOCATE(LON, LAT)
      IF (ALLOCATED(LON2D)) DEALLOCATE(LON2D, LAT2D)
!/RTD      IF (ALLOCATED(LON2DEQ)) DEALLOCATE(LAT2DEQ, LON2DEQ, ANGLD2D)
!
      RETURN
!
! Error escape locations
!

!
! Formats
!
  973 FORMAT ( 'NEW NETCDF FILE WAS CREATED ',A)
  999 FORMAT (/' *** WAVEWATCH III ERROR IN W3EXNC :'/                &
               '     PLEASE UPDATE FIELDS !!! '/                      &
               '     IFI = ',I2, '- IFJ = ',I2/)
!               
!/T 9000 FORMAT (' TEST W3EXNC : FLAGS :',I3,2X,20L2)
!/T 9001 FORMAT (' TEST W3EXNC : ITPYE :',I4/                         &
!/T              '             IX1/N   :',2I7/                        &
!/T              '             IY1/N   :',2I7/                        &
!/T              '             VECTOR  :',1L2)
!
!/T 9012 FORMAT (' TEST W3EXNC : BLOK PARS    : ',3I4)
!/T 9014 FORMAT ('           BASE NAME : ',A)
!
!/T 9020 FORMAT (' TEST W3EXNC : OUTPUT FIELD : ',A)
!/T 9021 FORMAT (' TEST W3EXNC : OUTPUT FIELD : ',A,' PART. ',I2)
!/



!/ End of W3EXNC ----------------------------------------------------- /
!/
      END SUBROUTINE W3EXNC


!--------------------------------------------------------------------------    
      SUBROUTINE W3NCINQ3(NCID,DIMNAME,DIMID3,DIMLN3,VCHCK)
      
      ! Check if a third dimension is defined
      
      USE NETCDF

      IMPLICIT NONE
      
      INTEGER, INTENT(IN)               :: NCID
      CHARACTER*(*), INTENT(IN)         :: DIMNAME
      INTEGER, INTENT(OUT)              :: DIMID3
      INTEGER, INTENT(IN)               :: DIMLN3
      REAL, INTENT(IN), OPTIONAL        :: VCHCK(:)

!
!/ ------------------------------------------------------------------- /
!   Local parameters
!
      INTEGER                           :: DIMLNT, IRET, DIMIDT, VARID3
      REAL                              :: VART(2)


      ! Chech for a dimension (e.g. DIMNAME='f') in the netCDF file.
      
      ! Returns:
      ! DIMID3 = 0  : DIMNAME not defined
      ! DIMID3 > 0  : DIMNAME defined and matches
      ! DIMID3 = -1 : DIMNAME defined but doesn't match DIMLN, VCHC
      
      DIMID3 = 0

      ! check that NCID is defined
      IF ( NCID .EQ. 0 ) THEN
        RETURN
      END IF

      ! get the DIMID of the dimension 
      IRET = NF90_INQ_DIMID(NCID, TRIM(DIMNAME), DIMIDT)

      ! If DIMNAME not defined
      IF ( IRET .NE. NF90_NOERR ) RETURN

      ! If there is already a dimension named DIMNAME, analyze it and return
      DIMID3 = -1
      ! get the length of the dimension 
      IRET = NF90_INQUIRE_DIMENSION(NCID, DIMIDT, LEN=DIMLNT)        
      IF ( DIMLNT .NE. DIMLN3 ) RETURN
      
      ! get the VARID of the dimension variable
      IRET = NF90_INQ_VARID(NCID, TRIM(DIMNAME), VARID3)
      IF ( IRET .NE. NF90_NOERR ) RETURN
      
      !Check contents ...
      IRET = NF90_GET_VAR(NCID,VARID3,VART, &
                          START=(/1/), COUNT=(/2/), STRIDE=(/DIMLN3-1/))
      IF (IRET .NE. NF90_NOERR) RETURN
        
      IF ( PRESENT(VCHCK) ) THEN
        IF (VART(1) .NE. VCHCK(1) .OR. VART(2) .NE. VCHCK(DIMLN3)) THEN
          WRITE(NDSE,*) 'Dimension variable contents does not match'
          RETURN
        END IF
      END IF
      
      DIMID3 = DIMIDT
      
      END SUBROUTINE W3NCINQ3

      
!--------------------------------------------------------------------------    
      SUBROUTINE W3NCDEF3(NCID,DIMNAME,DIMID3,DIMLN3,VARID3)
      
      ! Define one of the known third dimensions (e.g. DIMNAME='f')
      ! The netCDF file must be open in define mode
      
      USE NETCDF

      IMPLICIT NONE
      
      INTEGER, INTENT(IN)               :: NCID
      CHARACTER*(*), INTENT(IN)         :: DIMNAME
      INTEGER, INTENT(OUT)              :: DIMID3
      INTEGER, INTENT(IN)               :: DIMLN3
      INTEGER, INTENT(OUT)              :: VARID3

!
!/ ------------------------------------------------------------------- /
!   Local parameters
!
      INTEGER                           :: IRET
      
      IRET = NF90_DEF_DIM(NCID, TRIM(DIMNAME), DIMLN3, DIMID3)
      CALL CHECK_ERR(IRET)
      
      IRET = NF90_DEF_VAR(NCID, TRIM(DIMNAME), NF90_FLOAT, DIMID3, VARID3)
!/NC4      IF (NCTYPE.EQ.4) IRET = NF90_DEF_VAR_DEFLATE(NCID, VARID3, 1, 1, DEFLATE)
      CALL CHECK_ERR(IRET)
!
! frequency
!
      IF ( TRIM(DIMNAME) .EQ. 'f' ) THEN
        IRET=NF90_PUT_ATT(NCID,VARID3,'long_name','wave_frequency')
        CALL CHECK_ERR(IRET)
        IRET=NF90_PUT_ATT(NCID,VARID3,'standard_name','wave_frequency')
        CALL CHECK_ERR(IRET)
        IRET=NF90_PUT_ATT(NCID,VARID3,'units','s-1')
        CALL CHECK_ERR(IRET)
        IRET=NF90_PUT_ATT(NCID,VARID3,'axis','Hz')
        CALL CHECK_ERR(IRET)
!/XSTO!
!/XSTO! profile depth below surface
!/XSTO!
!/XSTO      ELSE IF ( TRIM(DIMNAME) .EQ. 'zk' ) THEN
!/XSTO        IRET=NF90_PUT_ATT(NCID,VARID3,'long_name','normalized_depth')
!/XSTO        CALL CHECK_ERR(IRET)
!/XSTO        IRET=NF90_PUT_ATT(NCID,VARID3,'standard_name','normalized_depth_below_surface')
!/XSTO        IRET=NF90_PUT_ATT(NCID,VARID3,'comment','zk = Z * ksc')
!/XSTO        CALL CHECK_ERR(IRET)
!/XSTO        IRET=NF90_PUT_ATT(NCID,VARID3,'units','1')
!/XSTO        CALL CHECK_ERR(IRET)
!/XSTO        IRET=NF90_PUT_ATT(NCID,VARID3,'axis','down')
!/XSTO        CALL CHECK_ERR(IRET)
!
! Here you may put netcdf attibutes for another third dim
!
      ! ELSE IF ( TRIM(DIMNAME) .EQ. 'fs' ) THEN
      !   IRET=NF90_PUT_ATT(NCID,VARID3,'long_name','segmented_wave_frequency')
      !   ...
      END IF
      
      END SUBROUTINE W3NCDEF3


!--------------------------------------------------------------------------    
      SUBROUTINE W3CRNC (NCFILE, NCID, DIMID, DIMLN, VARID,  &
                         EXTRADIM, NCTYPE, MAPSTAOUT )
!
      USE W3GDATMD, ONLY : GTYPE, FLAGLL, UNGTYPE, CLGTYPE, RLGTYPE
!/RTD ! Rotated pole parameters from the mod_def file 
!/RTD      USE W3GDATMD, ONLY : POLAT, POLON
      USE NETCDF
      USE W3TIMEMD

      IMPLICIT NONE
      


      INTEGER, INTENT(IN)               :: EXTRADIM
      INTEGER, INTENT(IN)               :: NCTYPE
      CHARACTER*(*), INTENT(IN)         :: NCFILE
      INTEGER, INTENT(OUT)              :: NCID
      INTEGER, INTENT(OUT)              :: DIMID(6)
      INTEGER, INTENT(IN)               :: DIMLN(6)
      INTEGER, INTENT(OUT)              :: VARID(300)
      INTEGER, INTENT(IN)               :: MAPSTAOUT
!
!/ ------------------------------------------------------------------- /
!   Local parameters
!
      INTEGER                           :: IVAR,IRET,ICODE,STRL,STRL2
      INTEGER                           :: DIMTRI(2)
!/NC4    INTEGER                           :: DEFLATE=1
!
      CHARACTER                         :: ATTNAME*120,ATTVAL*120

!/RTD ! RTDL == False for a standard lat-lon grid. Will be set to True if the
!/RTD ! grid is rotated
!/RTD      LOGICAL                           :: RTDL = .FALSE.

!/RTD ! Is the grid really rotated
!/RTD        IF ( Polat < 90. ) RTDL = .True.
!      
! Creation in netCDF3 or netCDF4
!
      IF(NCTYPE.EQ.3)  IRET = NF90_CREATE(TRIM(NCFILE), NF90_CLOBBER, NCID)
!/NC4      IF(NCTYPE.EQ.4) IRET = NF90_CREATE(TRIM(NCFILE), NF90_NETCDF4, NCID)
      CALL CHECK_ERR(IRET)
!
! Define dimensions
!
! The atmospheric level (the surface), a dimension not used elsewise:
      IRET = NF90_DEF_DIM(NCID, 'level', DIMLN(1), DIMID(1))

!
! Regular structured case
!
      IF (GTYPE.NE.UNGTYPE) THEN 
        IF (FLAGLL) THEN
          IF (SMCGRD) THEN
!/SMC            IF(SMCTYPE .EQ. 1) THEN
!/SMC               ! Flat seapoints file
!/SMC               IRET = NF90_DEF_DIM(NCID, 'seapoint', dimln(2), DIMID(2))
!/SMC            ELSE
!/SMC               ! Regular gridded file:
!/SMC               IRET = NF90_DEF_DIM(NCID, 'longitude', dimln(2), DIMID(2))
!/SMC               IRET = NF90_DEF_DIM(NCID, 'latitude', dimln(3), DIMID(3))
!/SMC            ENDIF
          ELSE
            IRET = NF90_DEF_DIM(NCID, 'longitude', DIMLN(2), DIMID(2))
            IRET = NF90_DEF_DIM(NCID, 'latitude', DIMLN(3), DIMID(3))
          ENDIF ! SMCGRD
        ELSE                     
          IRET = NF90_DEF_DIM(NCID, 'x', DIMLN(2), DIMID(2))
          IRET = NF90_DEF_DIM(NCID, 'y', DIMLN(3), DIMID(3))
          END IF
        CALL CHECK_ERR(IRET)
!
! Unstructured case
!
      ELSE
        IRET = NF90_DEF_DIM(NCID, 'node', DIMLN(2), DIMID(2))
        IRET = NF90_DEF_DIM(NCID, 'element', DIMLN(3), DIMID(3))
        CALL CHECK_ERR(IRET)
      ENDIF
!
! ( If EXTRADIM == 1, an extra (third) dimension will be defined in a separate
!   subroutine W3NCDEF3 ).     
      IRET = NF90_DEF_DIM(NCID, 'time',NF90_UNLIMITED, DIMID(4+EXTRADIM))
      CALL CHECK_ERR(IRET)

      IF (GTYPE.EQ.UNGTYPE) THEN 
        IRET = NF90_DEF_DIM(NCID, 'noel',3, DIMID(5+EXTRADIM))
        CALL CHECK_ERR(IRET)
      ENDIF

      
!
!     define variables
!
      IF (FLAGLL) THEN 
!longitude
        IF (GTYPE.EQ.RLGTYPE) THEN 
          IF (SMCGRD) THEN
!/SMC            IF(SMCTYPE .EQ. 1) THEN
!/SMC              ! Flat SMC grid - use seapoint dimension:
!/SMC              IRET = NF90_DEF_VAR(NCID, 'longitude', NF90_FLOAT, DIMID(2), VARID(1))
!/SMC              CALL CHECK_ERR(IRET)
!/SMC              IRET = NF90_DEF_VAR(NCID, 'latitude', NF90_FLOAT, DIMID(2), VARID(2))
!/SMC              CALL CHECK_ERR(IRET)
!/SMC
!/SMC              ! For seapoint style SMC grid, also define out cell size variables:
!/SMC              IRET = NF90_DEF_VAR(NCID, 'cx', NF90_SHORT, DIMID(2), VARID(5))
!/SMC              CALL CHECK_ERR(IRET)
!/SMC              IRET = NF90_PUT_ATT(NCID, VARID(299), 'long_name',        &
!/SMC                                  'longitude cell size factor')
!/SMC              IRET = NF90_PUT_ATT(NCID, VARID(299), 'valid_min', 1)
!/SMC              IRET = NF90_PUT_ATT(NCID, VARID(299), 'valid_max', 256)
!/SMC
!/SMC              IRET = NF90_DEF_VAR(NCID, 'cy', NF90_SHORT, DIMID(2), VARID(6))
!/SMC              call CHECK_ERR(IRET)
!/SMC              IRET = NF90_PUT_ATT(NCID, VARID(300), 'long_name',        &
!/SMC                                  'latitude cell size factor')
!/SMC              IRET = NF90_PUT_ATT(NCID, VARID(300), 'valid_min', 1)
!/SMC              IRET = NF90_PUT_ATT(NCID, VARID(300), 'valid_max', 256)
!/SMC            ELSE
!/SMC              ! Regirdded regular SMC grid - use lon/lat dimensions:
!/SMC              IRET = NF90_DEF_VAR(NCID, 'longitude', NF90_FLOAT, DIMID(2), VARID(1))
!/SMC              call CHECK_ERR(IRET)
!/SMC              IRET = NF90_DEF_VAR(NCID, 'latitude', NF90_FLOAT, DIMID(3), VARID(2))
!/SMC              call CHECK_ERR(IRET)
!/SMC            ENDIF
          ELSE
            IRET = NF90_DEF_VAR(NCID, 'longitude', NF90_FLOAT, DIMID(2), VARID(1))
            IRET = NF90_DEF_VAR(NCID, 'latitude', NF90_FLOAT, DIMID(3), VARID(2))
          ENDIF ! SMCGRD
        ELSE IF (GTYPE.EQ.CLGTYPE) THEN
          IRET = NF90_DEF_VAR(NCID, 'longitude', NF90_FLOAT, (/ DIMID(2), DIMID(3)/), &
                                                                            VARID(1))
          IRET = NF90_DEF_VAR(NCID, 'latitude', NF90_FLOAT, (/ DIMID(2), DIMID(3)/), &
                                                                            VARID(2))
        ELSE
          IRET = NF90_DEF_VAR(NCID, 'longitude', NF90_FLOAT, DIMID(2), VARID(1))
          IRET = NF90_DEF_VAR(NCID, 'latitude', NF90_FLOAT, DIMID(2), VARID(2))
          END IF
        IRET=NF90_PUT_ATT(NCID,VARID(1),'units','degree_east')
!/RTD ! Is the grid really rotated
!/RTD        IF ( .NOT. RTDL ) THEN        
        IRET=NF90_PUT_ATT(NCID,VARID(1),'long_name','longitude')
        IRET=NF90_PUT_ATT(NCID,VARID(1),'standard_name','longitude')
!/RTD        ELSE     
!/RTD        ! Override the above for RTD pole:
!/RTD          IRET=NF90_PUT_ATT(NCID,VARID(1),'long_name','longitude in rotated pole grid')
!/RTD          IRET=NF90_PUT_ATT(NCID,VARID(1),'standard_name','grid_longitude')
!/RTD        END IF        
        IRET=NF90_PUT_ATT(NCID,VARID(1),'valid_min',-180.0)
        IRET=NF90_PUT_ATT(NCID,VARID(1),'valid_max',360.)
!
        IRET=NF90_PUT_ATT(NCID,VARID(2),'units','degree_north')
!/RTD        IF ( .NOT. RTDL ) THEN        
        IRET=NF90_PUT_ATT(NCID,VARID(2),'long_name','latitude')
        IRET=NF90_PUT_ATT(NCID,VARID(2),'standard_name','latitude')
!/RTD        ELSE        
!/RTD        ! Override the above for RTD pole:
!/RTD        IRET=NF90_PUT_ATT(NCID,VARID(2),'long_name','latitude in rotated pole grid')
!/RTD        IRET=NF90_PUT_ATT(NCID,VARID(2),'standard_name','grid_latitude')
!/RTD        END IF        
        IRET=NF90_PUT_ATT(NCID,VARID(2),'valid_min',-90.0)
        IRET=NF90_PUT_ATT(NCID,VARID(2),'valid_max',180.)
!
        IF(SMCGRD) THEN
!/SMC          IF(SMCTYPE .EQ. 1) THEN
!/RTD            ! For SMC grid type 1, standard lat/lon variables are 1D:
!/RTD            IRET = NF90_DEF_VAR(NCID, 'standard_longitude', NF90_FLOAT, &
!/RTD                    (/ DIMID(2) /), VARID(7))
!/RTD            call CHECK_ERR(IRET)
!/RTD 
!/RTD            IRET = NF90_DEF_VAR(NCID, 'standard_latitude', NF90_FLOAT, &
!/RTD                    (/ DIMID(2) /), VARID(8))
!/RTD            call CHECK_ERR(IRET)
!/SMC          ELSE
!/RTD            IRET = NF90_DEF_VAR(NCID, 'standard_longitude', NF90_FLOAT, &
!/RTD                    (/ DIMID(2), DIMID(3)/), VARID(7))
!/RTD            call CHECK_ERR(IRET)
!/RTD
!/RTD            IRET = NF90_DEF_VAR(NCID, 'standard_latitude', NF90_FLOAT, &
!/RTD                    (/ DIMID(2), DIMID(3)/), VARID(8))
!/RTD            call CHECK_ERR(IRET)
!/SMC          ENDIF
        ELSE
!/RTD      IF ( RTDL ) THEN
!/RTD        !Add secondary coordinate system linking rotated grid back to standard lat-lon
!/RTD        IRET = NF90_DEF_VAR(NCID, 'standard_longitude', NF90_FLOAT, (/ DIMID(2), DIMID(3)/), &
!/RTD                             VARID(7))
!/RTD        call CHECK_ERR(IRET)
!/RTD
!/RTD        IRET = NF90_DEF_VAR(NCID, 'standard_latitude', NF90_FLOAT, (/ DIMID(2), DIMID(3)/), &
!/RTD                             VARID(8))
!/RTD        call CHECK_ERR(IRET)
!/RTD      END IF
        ENDIF ! SMCGRD
!/RTD
!/RTD      IF ( RTDL ) THEN
!/RTD        ! Attributes for standard_longitude:
!/RTD        IRET=NF90_PUT_ATT(NCID,VARID(7),'units','degree_east')
!/RTD        IRET=NF90_PUT_ATT(NCID,VARID(7),'long_name','longitude')
!/RTD        IRET=NF90_PUT_ATT(NCID,VARID(7),'standard_name','longitude')
!/RTD        IRET=NF90_PUT_ATT(NCID,VARID(7),'valid_min',-180.0)
!/RTD        IRET=NF90_PUT_ATT(NCID,VARID(7),'valid_max',360.)
!/RTD
!/RTD        ! Attributes for standard_latitude:
!/RTD        IRET=NF90_PUT_ATT(NCID,VARID(8),'units','degree_north')
!/RTD        IRET=NF90_PUT_ATT(NCID,VARID(8),'long_name','latitude')
!/RTD        IRET=NF90_PUT_ATT(NCID,VARID(8),'standard_name','latitude')
!/RTD        IRET=NF90_PUT_ATT(NCID,VARID(8),'valid_min',-90.0)
!/RTD        IRET=NF90_PUT_ATT(NCID,VARID(8),'valid_max',180.)
!/RTD
!/RTD        ! Add rotated pole grid mapping variable (dummy scalar variable
!/RTD        ! used to simply store rotated pole information; see CF1.6 conventions).
!/RTD        ! TODO: FUTURE WW3_OUNF DEVELOPMENT WILL ALLOW USER TO DEFINE THE 
!/RTD        ! COORDINATE REFERENCE SYSTEM - THIS WILL REQUIRE THE BELOW TO BE
!/RTD        ! HANDLED DIFFERENTLY. C. Bunney.
!/RTD        IRET=NF90_DEF_VAR(NCID, 'rotated_pole', NF90_CHAR, VARID(12))
!/RTD        IRET=NF90_PUT_ATT(NCID, VARID(12), 'grid_north_pole_latitude',POLAT)
!/RTD        IRET=NF90_PUT_ATT(NCID, VARID(12), 'grid_north_pole_longitude',POLON)
!/RTD        IRET=NF90_PUT_ATT(NCID, VARID(12), 'grid_mapping_name',              &
!/RTD                                   'rotated_latitude_longitude')
!/RTD      END IF
!
      ELSE 
        IF (GTYPE.EQ.RLGTYPE) THEN 
          IRET = NF90_DEF_VAR(NCID, 'x', NF90_FLOAT, DIMID(2), VARID(1))
          IRET = NF90_DEF_VAR(NCID, 'y', NF90_FLOAT, DIMID(3), VARID(2))
        ELSE IF (GTYPE.EQ.CLGTYPE) THEN 
          IRET = NF90_DEF_VAR(NCID, 'x', NF90_FLOAT, (/ DIMID(2), DIMID(3)/), &
                                                                            VARID(1))
          IRET = NF90_DEF_VAR(NCID, 'y', NF90_FLOAT, (/ DIMID(2), DIMID(3)/), &
                                                                            VARID(2))
        ELSE
          IRET = NF90_DEF_VAR(NCID, 'x', NF90_FLOAT, DIMID(2), VARID(1))
          IRET = NF90_DEF_VAR(NCID, 'y', NF90_FLOAT, DIMID(2), VARID(2))
          END IF
!
        IRET=NF90_PUT_ATT(NCID,VARID(1),'units','m')
        IRET=NF90_PUT_ATT(NCID,VARID(1),'long_name','x')
        IRET=NF90_PUT_ATT(NCID,VARID(2),'units','m')
        IRET=NF90_PUT_ATT(NCID,VARID(2),'long_name','y')
!
      END IF  ! FLAGLL
!
      IRET=NF90_PUT_ATT(NCID,VARID(1),'axis','X')    
      IRET=NF90_PUT_ATT(NCID,VARID(2),'axis','Y')
!/NC4        IF (NCTYPE.EQ.4) IRET = NF90_DEF_VAR_DEFLATE(NCID, VARID(1), 1, 1, DEFLATE)
!/NC4        IF (NCTYPE.EQ.4) IRET = NF90_DEF_VAR_DEFLATE(NCID, VARID(2), 1, 1, DEFLATE)

! ( If EXTRADIM == 1, an extra (third) dimension will be defined in a separate
!   subroutine W3NCDEF3 ).

!
!  time
!
      IRET = NF90_DEF_VAR(NCID, 'time', NF90_DOUBLE, DIMID(4+EXTRADIM), VARID(3))
!/NC4      IF (NCTYPE.EQ.4) IRET = NF90_DEF_VAR_DEFLATE(NCID, VARID(3), 1, 1, DEFLATE)
      CALL CHECK_ERR(IRET)
      SELECT CASE (TRIM(CALTYPE))
        CASE ('360_day')
          IRET=NF90_PUT_ATT(NCID,VARID(3),'long_name','time in 360 day calendar')
        CASE ('365_day')
          IRET=NF90_PUT_ATT(NCID,VARID(3),'long_name','time in 365 day calendar')
        CASE ('standard')
          IRET=NF90_PUT_ATT(NCID,VARID(3),'long_name','julian day (UT)')
      END SELECT
      CALL CHECK_ERR(IRET)
      IRET=NF90_PUT_ATT(NCID,VARID(3),'standard_name','time')
      CALL CHECK_ERR(IRET)
      IRET=NF90_PUT_ATT(NCID,VARID(3),'units','days since 1990-01-01 00:00:00')
      CALL CHECK_ERR(IRET)
      IRET=NF90_PUT_ATT(NCID,VARID(3),'conventions', &
        'relative julian days with decimal part (as parts of the day )')
      IRET=NF90_PUT_ATT(NCID,VARID(3),'axis','T')
      CALL CHECK_ERR(IRET)
      IRET=NF90_PUT_ATT(NCID,VARID(3),'calendar',TRIM(CALTYPE))
      CALL CHECK_ERR(IRET)
!
! triangles for irregular grids
!
      IF (GTYPE.EQ.UNGTYPE) THEN
        DIMTRI(1)=DIMID(4+EXTRADIM+1)
        DIMTRI(2)=DIMID(3)
        IRET = NF90_DEF_VAR(NCID, 'tri', NF90_INT, DIMTRI, VARID(4))
!/NC4        IF (NCTYPE.EQ.4) IRET = NF90_DEF_VAR_DEFLATE(NCID, VARID(4), 1, 1, DEFLATE)
      END IF
!
!  Status map: useful for grid combination
!
      IF (MAPSTAOUT.EQ.1) THEN 
        IF (GTYPE.EQ.UNGTYPE) THEN 
          IRET = NF90_DEF_VAR(NCID,'MAPSTA', NF90_SHORT,(/ DIMID(2) /), VARID(20))
        ELSE 
          IRET = NF90_DEF_VAR(NCID,'MAPSTA', NF90_SHORT,(/ DIMID(2) , DIMID(3) /), &
                                                                       VARID(20))
          ENDIF
!/NC4          IF (NCTYPE.EQ.4) IRET = NF90_DEF_VAR_DEFLATE(NCID, VARID(20), 1, 1, DEFLATE)
!
        IRET=NF90_PUT_ATT(NCID,VARID(20),'long_name','status map')
        IRET=NF90_PUT_ATT(NCID,VARID(20),'standard_name','status map')
        IRET=NF90_PUT_ATT(NCID,VARID(20),'units','1')
        CALL CHECK_ERR(IRET)
        IRET=NF90_PUT_ATT(NCID,VARID(20),'valid_min',-32)
        CALL CHECK_ERR(IRET)
        IRET=NF90_PUT_ATT(NCID,VARID(20),'valid_max',32)
        CALL CHECK_ERR(IRET)
      END IF

!
! Global attributes
!
      IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,'WAVEWATCH_III_version_number' ,TRIM(WWVER))   
      CALL CHECK_ERR(IRET)
      IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,'WAVEWATCH_III_switches',TRIM(SWITCHES))
      CALL CHECK_ERR(IRET)
!/ST4    IF (ZZWND.NE.10)      IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,'SIN4 namelist parameter ZWD',ZZWND)
!/ST4    IF (AALPHA.NE.0.0095) IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,'SIN4 namelist parameter ALPHA0',AALPHA)
!/ST4    IF (BBETA.NE.1.43)    IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,'SIN4 namelist parameter BETAMAX',BBETA)
!/ST4    IF(SSDSC(7).NE.0.3)   IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,'SDS4 namelist parameter WHITECAPWIDTH', SSDSC(7))
! ... TO BE CONTINUED ... 

      IF(SMCGRD) THEN
!/SMC         IF(SMCTYPE .EQ. 1) THEN
!/SMC           IRET = NF90_PUT_ATT(NCID, NF90_GLOBAL, 'first_lat', Y0)
!/SMC           call CHECK_ERR(IRET)
!/SMC           IRET = NF90_PUT_ATT(NCID, NF90_GLOBAL, 'first_lon', X0)
!/SMC           call CHECK_ERR(IRET)
!/SMC           IRET = NF90_PUT_ATT(NCID, NF90_GLOBAL, 'base_lat_size', dlat)
!/SMC           call CHECK_ERR(IRET)
!/SMC           IRET = NF90_PUT_ATT(NCID, NF90_GLOBAL, 'base_lon_size', dlon)
!/SMC           call CHECK_ERR(IRET)
!/SMC           IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,'SMC_grid_type','seapoint')
!/SMC           call CHECK_ERR(IRET)
!/SMC         ELSE IF(SMCTYPE .EQ. 2) THEN
!/SMC           IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,'SMC_grid_type','regular_regridded')
!/SMC           call CHECK_ERR(IRET)
!/SMC         ENDIF
      ENDIF

      ! ChrisB: Write user global attributes:
      CALL WRITE_GLOBAL_META(NCID, IRET)
      CALL CHECK_ERR(IRET)

      open(unit=994,file='NC_globatt.inp',status='old',iostat=ICODE)
      IF (ICODE.EQ.0) THEN
        DO WHILE (ICODE.EQ.0)
          read(994,'(a)',iostat=ICODE) ATTNAME
          read(994,'(a)',iostat=ICODE) ATTVAL
          IF (ICODE.EQ.0) THEN
            STRL=LEN_TRIM(ATTNAME)
            STRL2=LEN_TRIM(ATTVAL)
            IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,ATTNAME(1:STRL),ATTVAL(1:STRL2))
            CALL CHECK_ERR(IRET)
          END IF
        END DO
      ENDIF
      CLOSE(994)
      IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,'product_name' ,TRIM(NCFILE))   
      CALL CHECK_ERR(IRET)
      IRET=NF90_PUT_ATT(NCID,NF90_GLOBAL,'area',TRIM(GNAME))
      CALL CHECK_ERR(IRET)

      RETURN

      END SUBROUTINE W3CRNC 

!==============================================================================

      SUBROUTINE CHECK_ERROR(IRET, ILINE)

      USE NETCDF
      USE W3ODATMD, ONLY: NDSE
      USE W3SERVMD, ONLY: EXTCDE

      IMPLICIT NONE

      INTEGER IRET, ILINE

      IF (IRET .NE. NF90_NOERR) THEN
        WRITE(NDSE,*) ' *** WAVEWATCH III ERROR IN OUNF :'
        WRITE(NDSE,*) ' LINE NUMBER ', ILINE
        WRITE(NDSE,*) ' NETCDF ERROR MESSAGE: '
        WRITE(NDSE,*) NF90_STRERROR(IRET)
        CALL EXTCDE ( 59 )
      END IF
      RETURN

      END SUBROUTINE CHECK_ERROR

!==============================================================================


!/
!/ End of W3OUNF ----------------------------------------------------- /
!/
      END PROGRAM W3OUNF





